// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: options_info_details.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOptionInfoDetail = `-- name: CreateOptionInfoDetail :one
INSERT INTO options_info_details (
    option_id,
    option_highlight
) VALUES (
    $1, $2
) RETURNING option_id, des, space_des, guest_access_des, interact_with_guests_des, pets_allowed, other_des, neighborhood_des, get_around_des, host_name_option, option_highlight, created_at, updated_at
`

type CreateOptionInfoDetailParams struct {
	OptionID        uuid.UUID `json:"option_id"`
	OptionHighlight []string  `json:"option_highlight"`
}

func (q *Queries) CreateOptionInfoDetail(ctx context.Context, arg CreateOptionInfoDetailParams) (OptionsInfoDetail, error) {
	row := q.db.QueryRow(ctx, createOptionInfoDetail, arg.OptionID, arg.OptionHighlight)
	var i OptionsInfoDetail
	err := row.Scan(
		&i.OptionID,
		&i.Des,
		&i.SpaceDes,
		&i.GuestAccessDes,
		&i.InteractWithGuestsDes,
		&i.PetsAllowed,
		&i.OtherDes,
		&i.NeighborhoodDes,
		&i.GetAroundDes,
		&i.HostNameOption,
		&i.OptionHighlight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionInfoDetail = `-- name: GetOptionInfoDetail :one
SELECT option_id, des, space_des, guest_access_des, interact_with_guests_des, pets_allowed, other_des, neighborhood_des, get_around_des, host_name_option, option_highlight, created_at, updated_at 
FROM options_info_details
WHERE option_id = $1
`

func (q *Queries) GetOptionInfoDetail(ctx context.Context, optionID uuid.UUID) (OptionsInfoDetail, error) {
	row := q.db.QueryRow(ctx, getOptionInfoDetail, optionID)
	var i OptionsInfoDetail
	err := row.Scan(
		&i.OptionID,
		&i.Des,
		&i.SpaceDes,
		&i.GuestAccessDes,
		&i.InteractWithGuestsDes,
		&i.PetsAllowed,
		&i.OtherDes,
		&i.NeighborhoodDes,
		&i.GetAroundDes,
		&i.HostNameOption,
		&i.OptionHighlight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionInfoDetailHighlight = `-- name: GetOptionInfoDetailHighlight :one
SELECT option_highlight
FROM options_info_details
WHERE option_id = $1
`

func (q *Queries) GetOptionInfoDetailHighlight(ctx context.Context, optionID uuid.UUID) ([]string, error) {
	row := q.db.QueryRow(ctx, getOptionInfoDetailHighlight, optionID)
	var option_highlight []string
	err := row.Scan(&option_highlight)
	return option_highlight, err
}

const getOptionInfoDetailPetsAllow = `-- name: GetOptionInfoDetailPetsAllow :one
SELECT pets_allowed
FROM options_info_details
WHERE option_id = $1
`

func (q *Queries) GetOptionInfoDetailPetsAllow(ctx context.Context, optionID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, getOptionInfoDetailPetsAllow, optionID)
	var pets_allowed bool
	err := row.Scan(&pets_allowed)
	return pets_allowed, err
}

const listOIDSearchByName = `-- name: ListOIDSearchByName :many
SELECT o_i_d.host_name_option, o_i.id, o_i_p.main_image, o_i.main_option_type, o_i.is_complete, o_i_s.status AS option_status
FROM options_info_details o_i_d
    JOIN options_infos o_i on o_i_d.option_id = o_i.id
    JOIN options_infos_status o_i_s on o_i_s.option_id = o_i.id
    JOIN options_info_photos o_i_p on o_i_d.option_id = o_i_p.option_id
    JOIN users u on u.id = o_i.host_id 
WHERE LOWER(o_i_d.host_name_option) LIKE $1 AND u.id=$2 AND o_i.is_active = $3
`

type ListOIDSearchByNameParams struct {
	HostNameOption string    `json:"host_name_option"`
	ID             uuid.UUID `json:"id"`
	IsActive       bool      `json:"is_active"`
}

type ListOIDSearchByNameRow struct {
	HostNameOption string    `json:"host_name_option"`
	ID             uuid.UUID `json:"id"`
	MainImage      string    `json:"main_image"`
	MainOptionType string    `json:"main_option_type"`
	IsComplete     bool      `json:"is_complete"`
	OptionStatus   string    `json:"option_status"`
}

func (q *Queries) ListOIDSearchByName(ctx context.Context, arg ListOIDSearchByNameParams) ([]ListOIDSearchByNameRow, error) {
	rows, err := q.db.Query(ctx, listOIDSearchByName, arg.HostNameOption, arg.ID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOIDSearchByNameRow{}
	for rows.Next() {
		var i ListOIDSearchByNameRow
		if err := rows.Scan(
			&i.HostNameOption,
			&i.ID,
			&i.MainImage,
			&i.MainOptionType,
			&i.IsComplete,
			&i.OptionStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOIDSearchByNameCal = `-- name: ListOIDSearchByNameCal :many
SELECT o_i_d.host_name_option, o_i.id, o_i.main_option_type, o_i.currency, o_i_s.status AS option_status
FROM options_info_details o_i_d
    JOIN options_infos o_i on o_i_d.option_id = o_i.id
    JOIN options_infos_status o_i_s on o_i_s.option_id = o_i.id
    JOIN users u on u.id = o_i.host_id 
WHERE LOWER(o_i_d.host_name_option) LIKE $1 AND u.id=$2 AND o_i.is_active = $3 AND o_i.is_complete = $4 AND (o_i_s.status = 'list' OR o_i_s.status = 'staged')
`

type ListOIDSearchByNameCalParams struct {
	HostNameOption string    `json:"host_name_option"`
	ID             uuid.UUID `json:"id"`
	IsActive       bool      `json:"is_active"`
	IsComplete     bool      `json:"is_complete"`
}

type ListOIDSearchByNameCalRow struct {
	HostNameOption string    `json:"host_name_option"`
	ID             uuid.UUID `json:"id"`
	MainOptionType string    `json:"main_option_type"`
	Currency       string    `json:"currency"`
	OptionStatus   string    `json:"option_status"`
}

func (q *Queries) ListOIDSearchByNameCal(ctx context.Context, arg ListOIDSearchByNameCalParams) ([]ListOIDSearchByNameCalRow, error) {
	rows, err := q.db.Query(ctx, listOIDSearchByNameCal,
		arg.HostNameOption,
		arg.ID,
		arg.IsActive,
		arg.IsComplete,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOIDSearchByNameCalRow{}
	for rows.Next() {
		var i ListOIDSearchByNameCalRow
		if err := rows.Scan(
			&i.HostNameOption,
			&i.ID,
			&i.MainOptionType,
			&i.Currency,
			&i.OptionStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOIDSearchByNameNoPhoto = `-- name: ListOIDSearchByNameNoPhoto :many
SELECT oi.id, oi.is_complete, oi.currency, oi.main_option_type, oi.created_at, oi.option_type, od.host_name_option, coi.current_state, coi.previous_state, op.main_image, ois.status AS option_status,
CASE
    WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
    WHEN oi.host_id = $1 THEN 'main_host'
    ELSE 'none' -- Optional: Handle other cases if needed
END AS host_type
FROM options_infos oi
    JOIN options_info_details od on oi.id = od.option_id
    JOIN options_infos_status ois on ois.option_id = od.option_id
    JOIN complete_option_info coi on oi.id = coi.option_id
    JOIN options_info_photos op on oi.id = op.option_id
    LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, edit_option_info, edit_event_dates_times
    FROM option_co_hosts AS och
    WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $1 OR och_subquery.option_id IS NOT NULL) AND oi.is_active = $3 AND LOWER(od.host_name_option) LIKE $4
ORDER BY oi.created_at DESC
`

type ListOIDSearchByNameNoPhotoParams struct {
	HostID         uuid.UUID `json:"host_id"`
	CoUserID       string    `json:"co_user_id"`
	IsActive       bool      `json:"is_active"`
	HostNameOption string    `json:"host_name_option"`
}

type ListOIDSearchByNameNoPhotoRow struct {
	ID             uuid.UUID `json:"id"`
	IsComplete     bool      `json:"is_complete"`
	Currency       string    `json:"currency"`
	MainOptionType string    `json:"main_option_type"`
	CreatedAt      time.Time `json:"created_at"`
	OptionType     string    `json:"option_type"`
	HostNameOption string    `json:"host_name_option"`
	CurrentState   string    `json:"current_state"`
	PreviousState  string    `json:"previous_state"`
	MainImage      string    `json:"main_image"`
	OptionStatus   string    `json:"option_status"`
	HostType       string    `json:"host_type"`
}

func (q *Queries) ListOIDSearchByNameNoPhoto(ctx context.Context, arg ListOIDSearchByNameNoPhotoParams) ([]ListOIDSearchByNameNoPhotoRow, error) {
	rows, err := q.db.Query(ctx, listOIDSearchByNameNoPhoto,
		arg.HostID,
		arg.CoUserID,
		arg.IsActive,
		arg.HostNameOption,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOIDSearchByNameNoPhotoRow{}
	for rows.Next() {
		var i ListOIDSearchByNameNoPhotoRow
		if err := rows.Scan(
			&i.ID,
			&i.IsComplete,
			&i.Currency,
			&i.MainOptionType,
			&i.CreatedAt,
			&i.OptionType,
			&i.HostNameOption,
			&i.CurrentState,
			&i.PreviousState,
			&i.MainImage,
			&i.OptionStatus,
			&i.HostType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSearchEventByName = `-- name: ListUserSearchEventByName :many
SELECT o_i_d.host_name_option, o_i.option_user_id, o_i.is_verified, o_i_p.main_image
FROM options_info_details o_i_d
    JOIN options_infos o_i on o_i_d.option_id = o_i.id
    JOIN options_info_photos o_i_p on o_i_p.option_id = o_i.id
    JOIN options_infos_status o_i_s on o_i_s.option_id = o_i.id
WHERE LOWER(o_i_d.host_name_option) LIKE $1 AND o_i.is_active = $2 AND o_i.is_complete = $3 AND o_i_s.status = (option_status)
`

type ListUserSearchEventByNameParams struct {
	HostNameOption string `json:"host_name_option"`
	IsActive       bool   `json:"is_active"`
	IsComplete     bool   `json:"is_complete"`
}

type ListUserSearchEventByNameRow struct {
	HostNameOption string    `json:"host_name_option"`
	OptionUserID   uuid.UUID `json:"option_user_id"`
	IsVerified     bool      `json:"is_verified"`
	MainImage      string    `json:"main_image"`
}

// -- This is for the user end
func (q *Queries) ListUserSearchEventByName(ctx context.Context, arg ListUserSearchEventByNameParams) ([]ListUserSearchEventByNameRow, error) {
	rows, err := q.db.Query(ctx, listUserSearchEventByName, arg.HostNameOption, arg.IsActive, arg.IsComplete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSearchEventByNameRow{}
	for rows.Next() {
		var i ListUserSearchEventByNameRow
		if err := rows.Scan(
			&i.HostNameOption,
			&i.OptionUserID,
			&i.IsVerified,
			&i.MainImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOptionInfoDetail = `-- name: RemoveOptionInfoDetail :exec
DELETE FROM options_info_details 
WHERE option_id = $1
`

func (q *Queries) RemoveOptionInfoDetail(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeOptionInfoDetail, optionID)
	return err
}

const removeOptionInfoDetails = `-- name: RemoveOptionInfoDetails :exec
DELETE FROM options_info_details
WHERE option_id = $1
`

func (q *Queries) RemoveOptionInfoDetails(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeOptionInfoDetails, optionID)
	return err
}

const updateOptionInfoDetail = `-- name: UpdateOptionInfoDetail :one
UPDATE options_info_details 
SET 
    space_des = COALESCE($1, space_des),
    guest_access_des = COALESCE($2, guest_access_des),
    interact_with_guests_des = COALESCE($3, interact_with_guests_des),
    other_des = COALESCE($4, other_des),
    neighborhood_des = COALESCE($5, neighborhood_des),
    get_around_des = COALESCE($6, get_around_des),
    des = COALESCE($7, des),
    option_highlight = COALESCE($8, option_highlight),
    host_name_option = COALESCE($9, host_name_option),
    pets_allowed = COALESCE($10, pets_allowed),
    updated_at = NOW()
WHERE option_id = $11 
RETURNING option_id, des, space_des, guest_access_des, interact_with_guests_des, pets_allowed, other_des, neighborhood_des, get_around_des, host_name_option, option_highlight, created_at, updated_at
`

type UpdateOptionInfoDetailParams struct {
	SpaceDes              pgtype.Text `json:"space_des"`
	GuestAccessDes        pgtype.Text `json:"guest_access_des"`
	InteractWithGuestsDes pgtype.Text `json:"interact_with_guests_des"`
	OtherDes              pgtype.Text `json:"other_des"`
	NeighborhoodDes       pgtype.Text `json:"neighborhood_des"`
	GetAroundDes          pgtype.Text `json:"get_around_des"`
	Des                   pgtype.Text `json:"des"`
	OptionHighlight       []string    `json:"option_highlight"`
	HostNameOption        pgtype.Text `json:"host_name_option"`
	PetsAllowed           pgtype.Bool `json:"pets_allowed"`
	OptionID              uuid.UUID   `json:"option_id"`
}

func (q *Queries) UpdateOptionInfoDetail(ctx context.Context, arg UpdateOptionInfoDetailParams) (OptionsInfoDetail, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoDetail,
		arg.SpaceDes,
		arg.GuestAccessDes,
		arg.InteractWithGuestsDes,
		arg.OtherDes,
		arg.NeighborhoodDes,
		arg.GetAroundDes,
		arg.Des,
		arg.OptionHighlight,
		arg.HostNameOption,
		arg.PetsAllowed,
		arg.OptionID,
	)
	var i OptionsInfoDetail
	err := row.Scan(
		&i.OptionID,
		&i.Des,
		&i.SpaceDes,
		&i.GuestAccessDes,
		&i.InteractWithGuestsDes,
		&i.PetsAllowed,
		&i.OtherDes,
		&i.NeighborhoodDes,
		&i.GetAroundDes,
		&i.HostNameOption,
		&i.OptionHighlight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOptionInfoDetailHighlight = `-- name: UpdateOptionInfoDetailHighlight :one
UPDATE options_info_details
SET 
    option_highlight = $1,
    updated_at = NOW()
WHERE option_id = $2
RETURNING option_highlight
`

type UpdateOptionInfoDetailHighlightParams struct {
	OptionHighlight []string  `json:"option_highlight"`
	OptionID        uuid.UUID `json:"option_id"`
}

func (q *Queries) UpdateOptionInfoDetailHighlight(ctx context.Context, arg UpdateOptionInfoDetailHighlightParams) ([]string, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoDetailHighlight, arg.OptionHighlight, arg.OptionID)
	var option_highlight []string
	err := row.Scan(&option_highlight)
	return option_highlight, err
}
