// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: options_infos_two.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOptionInfoInsight = `-- name: CountOptionInfoInsight :one
SELECT Count(*)
FROM options_infos oi
   JOIN options_info_details od on oi.id = od.option_id
   JOIN options_infos_status ois on ois.option_id = od.option_id
   JOIN complete_option_info coi on oi.id = coi.option_id
   JOIN options_info_photos op on oi.id = op.option_id
   LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $1 OR och_subquery.option_id IS NOT NULL) AND (oi.host_id = $1 OR och_subquery.insights = true) AND oi.is_complete = $3 AND oi.is_active = $4 AND oi.main_option_type = $5
`

type CountOptionInfoInsightParams struct {
	HostID         uuid.UUID `json:"host_id"`
	CoUserID       string    `json:"co_user_id"`
	IsComplete     bool      `json:"is_complete"`
	IsActive       bool      `json:"is_active"`
	MainOptionType string    `json:"main_option_type"`
}

func (q *Queries) CountOptionInfoInsight(ctx context.Context, arg CountOptionInfoInsightParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOptionInfoInsight,
		arg.HostID,
		arg.CoUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.MainOptionType,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEventExperienceByDeepLinkID = `-- name: GetEventExperienceByDeepLinkID :one
SELECT o_i.id, o_i.option_user_id, o_i.currency, o_i.option_type, o_i_d.host_name_option, o_i_p.cover_image, o_i_p.photo, o_i.is_verified, e_i.event_type, e_i.sub_category_type, o_q.host_as_individual, u.photo, u.first_name, u.created_at, i_d.is_verified, o_i.category
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN event_infos e_i on o_i.id = e_i.option_id
   JOIN users u on o_i.host_id = u.id
   JOIN identity i_d on u.id = i_d.user_id
LEFT JOIN event_date_times e_d_t on e_i.option_id = e_d_t.event_info_id
LEFT JOIN event_date_locations e_d_l ON e_d_t.id = e_d_l.event_date_time_id
WHERE o_i.deep_link_id  = $1 AND o_i.is_complete = $2 AND u.is_active = $3 AND o_i.is_active = $4 AND o_i_s.status != 'unlist' AND o_i_s.status != 'snooze'
`

type GetEventExperienceByDeepLinkIDParams struct {
	DeepLinkID uuid.UUID `json:"deep_link_id"`
	IsComplete bool      `json:"is_complete"`
	IsActive   bool      `json:"is_active"`
	IsActive_2 bool      `json:"is_active_2"`
}

type GetEventExperienceByDeepLinkIDRow struct {
	ID               uuid.UUID `json:"id"`
	OptionUserID     uuid.UUID `json:"option_user_id"`
	Currency         string    `json:"currency"`
	OptionType       string    `json:"option_type"`
	HostNameOption   string    `json:"host_name_option"`
	CoverImage       string    `json:"cover_image"`
	Photo            []string  `json:"photo"`
	IsVerified       bool      `json:"is_verified"`
	EventType        string    `json:"event_type"`
	SubCategoryType  string    `json:"sub_category_type"`
	HostAsIndividual bool      `json:"host_as_individual"`
	Photo_2          string    `json:"photo_2"`
	FirstName        string    `json:"first_name"`
	CreatedAt        time.Time `json:"created_at"`
	IsVerified_2     bool      `json:"is_verified_2"`
	Category         string    `json:"category"`
}

func (q *Queries) GetEventExperienceByDeepLinkID(ctx context.Context, arg GetEventExperienceByDeepLinkIDParams) (GetEventExperienceByDeepLinkIDRow, error) {
	row := q.db.QueryRow(ctx, getEventExperienceByDeepLinkID,
		arg.DeepLinkID,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
	)
	var i GetEventExperienceByDeepLinkIDRow
	err := row.Scan(
		&i.ID,
		&i.OptionUserID,
		&i.Currency,
		&i.OptionType,
		&i.HostNameOption,
		&i.CoverImage,
		&i.Photo,
		&i.IsVerified,
		&i.EventType,
		&i.SubCategoryType,
		&i.HostAsIndividual,
		&i.Photo_2,
		&i.FirstName,
		&i.CreatedAt,
		&i.IsVerified_2,
		&i.Category,
	)
	return i, err
}

const getEventExperienceByOptionUserID = `-- name: GetEventExperienceByOptionUserID :one
SELECT o_i.id, o_i.option_user_id, o_i.currency, o_i.option_type, o_i_d.host_name_option, o_i_p.cover_image, o_i_p.photo, o_i.is_verified, e_i.event_type, e_i.sub_category_type, o_q.host_as_individual, u.photo, u.first_name, u.created_at, i_d.is_verified, o_i.category
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN event_infos e_i on o_i.id = e_i.option_id
   JOIN users u on o_i.host_id = u.id
   JOIN identity i_d on u.id = i_d.user_id
LEFT JOIN event_date_times e_d_t on e_i.option_id = e_d_t.event_info_id
LEFT JOIN event_date_locations e_d_l ON e_d_t.id = e_d_l.event_date_time_id
WHERE o_i.option_user_id  = $1 AND o_i.is_complete = $2 AND u.is_active = $3 AND o_i.is_active = $4 AND o_i_s.status != 'unlist' AND o_i_s.status != 'snooze'
`

type GetEventExperienceByOptionUserIDParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	IsComplete   bool      `json:"is_complete"`
	IsActive     bool      `json:"is_active"`
	IsActive_2   bool      `json:"is_active_2"`
}

type GetEventExperienceByOptionUserIDRow struct {
	ID               uuid.UUID `json:"id"`
	OptionUserID     uuid.UUID `json:"option_user_id"`
	Currency         string    `json:"currency"`
	OptionType       string    `json:"option_type"`
	HostNameOption   string    `json:"host_name_option"`
	CoverImage       string    `json:"cover_image"`
	Photo            []string  `json:"photo"`
	IsVerified       bool      `json:"is_verified"`
	EventType        string    `json:"event_type"`
	SubCategoryType  string    `json:"sub_category_type"`
	HostAsIndividual bool      `json:"host_as_individual"`
	Photo_2          string    `json:"photo_2"`
	FirstName        string    `json:"first_name"`
	CreatedAt        time.Time `json:"created_at"`
	IsVerified_2     bool      `json:"is_verified_2"`
	Category         string    `json:"category"`
}

func (q *Queries) GetEventExperienceByOptionUserID(ctx context.Context, arg GetEventExperienceByOptionUserIDParams) (GetEventExperienceByOptionUserIDRow, error) {
	row := q.db.QueryRow(ctx, getEventExperienceByOptionUserID,
		arg.OptionUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
	)
	var i GetEventExperienceByOptionUserIDRow
	err := row.Scan(
		&i.ID,
		&i.OptionUserID,
		&i.Currency,
		&i.OptionType,
		&i.HostNameOption,
		&i.CoverImage,
		&i.Photo,
		&i.IsVerified,
		&i.EventType,
		&i.SubCategoryType,
		&i.HostAsIndividual,
		&i.Photo_2,
		&i.FirstName,
		&i.CreatedAt,
		&i.IsVerified_2,
		&i.Category,
	)
	return i, err
}

const getEventExperienceCount = `-- name: GetEventExperienceCount :one
SELECT COUNT(*)
FROM options_infos o_i
LEFT JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
LEFT JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
LEFT JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
LEFT JOIN event_infos e_i on o_i.id = e_i.option_id
LEFT JOIN event_date_times e_d_t on e_i.option_id = e_d_t.event_info_id
LEFT JOIN event_date_locations e_d_l ON e_d_t.id = e_d_l.event_date_time_id
LEFT JOIN users u on u.id = o_i.host_id
WHERE o_i.is_complete = $1 AND o_i.is_active = $2 AND o_i.main_option_type = $3 AND e_d_t.is_active = true AND (o_i.category = $4 OR o_i.category_two = $4 OR o_i.category_three = $4) AND u.is_active = $5 AND o_i_s.status != 'unlist' AND o_i_s.status != 'snooze'
`

type GetEventExperienceCountParams struct {
	IsComplete     bool   `json:"is_complete"`
	IsActive       bool   `json:"is_active"`
	MainOptionType string `json:"main_option_type"`
	Category       string `json:"category"`
	IsActive_2     bool   `json:"is_active_2"`
}

func (q *Queries) GetEventExperienceCount(ctx context.Context, arg GetEventExperienceCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getEventExperienceCount,
		arg.IsComplete,
		arg.IsActive,
		arg.MainOptionType,
		arg.Category,
		arg.IsActive_2,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOptionCount = `-- name: GetOptionCount :one
SELECT COUNT(*)
FROM options_infos o_i
WHERE host_id = $1
`

func (q *Queries) GetOptionCount(ctx context.Context, hostID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getOptionCount, hostID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOptionExperienceByDeepLinkID = `-- name: GetOptionExperienceByDeepLinkID :one
SELECT o_i.id, o_i.option_user_id, o_i.currency, o_i.option_type, o_i_d.host_name_option, o_i_p.cover_image, o_i_p.photo, s.type_of_shortlet, o_q.host_as_individual, o_i.is_verified, o_p.price, o_p.weekend_price, l.state, l.country, u.photo, u.first_name, u.created_at, i_d.is_verified, o_i.category, oas.advance_notice, oas.auto_block_dates, oas.advance_notice_condition, oas.preparation_time, oas.availability_window, otl.min_stay_day, otl.max_stay_night, otl.manual_approve_request_pass_max, otl.allow_reservation_request
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN shortlets s on o_i.id = s.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN options_prices o_p on o_i.id = o_p.option_id
   JOIN locations l on o_i.id = l.option_id
   JOIN users u on o_i.host_id = u.id
   JOIN identity i_d on u.id = i_d.user_id
   JOIN option_availability_settings oas on o_i.id = oas.option_id
   JOIN option_trip_lengths otl on o_i.id = otl.option_id
WHERE  o_i.deep_link_id = $1 AND o_i.is_complete = $2 AND u.is_active = $3 AND o_i.is_active = $4 AND o_i_s.status != 'unlist' AND o_i_s.status != 'snooze'
`

type GetOptionExperienceByDeepLinkIDParams struct {
	DeepLinkID uuid.UUID `json:"deep_link_id"`
	IsComplete bool      `json:"is_complete"`
	IsActive   bool      `json:"is_active"`
	IsActive_2 bool      `json:"is_active_2"`
}

type GetOptionExperienceByDeepLinkIDRow struct {
	ID                          uuid.UUID `json:"id"`
	OptionUserID                uuid.UUID `json:"option_user_id"`
	Currency                    string    `json:"currency"`
	OptionType                  string    `json:"option_type"`
	HostNameOption              string    `json:"host_name_option"`
	CoverImage                  string    `json:"cover_image"`
	Photo                       []string  `json:"photo"`
	TypeOfShortlet              string    `json:"type_of_shortlet"`
	HostAsIndividual            bool      `json:"host_as_individual"`
	IsVerified                  bool      `json:"is_verified"`
	Price                       int64     `json:"price"`
	WeekendPrice                int64     `json:"weekend_price"`
	State                       string    `json:"state"`
	Country                     string    `json:"country"`
	Photo_2                     string    `json:"photo_2"`
	FirstName                   string    `json:"first_name"`
	CreatedAt                   time.Time `json:"created_at"`
	IsVerified_2                bool      `json:"is_verified_2"`
	Category                    string    `json:"category"`
	AdvanceNotice               string    `json:"advance_notice"`
	AutoBlockDates              bool      `json:"auto_block_dates"`
	AdvanceNoticeCondition      string    `json:"advance_notice_condition"`
	PreparationTime             string    `json:"preparation_time"`
	AvailabilityWindow          string    `json:"availability_window"`
	MinStayDay                  int32     `json:"min_stay_day"`
	MaxStayNight                int32     `json:"max_stay_night"`
	ManualApproveRequestPassMax bool      `json:"manual_approve_request_pass_max"`
	AllowReservationRequest     bool      `json:"allow_reservation_request"`
}

func (q *Queries) GetOptionExperienceByDeepLinkID(ctx context.Context, arg GetOptionExperienceByDeepLinkIDParams) (GetOptionExperienceByDeepLinkIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionExperienceByDeepLinkID,
		arg.DeepLinkID,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
	)
	var i GetOptionExperienceByDeepLinkIDRow
	err := row.Scan(
		&i.ID,
		&i.OptionUserID,
		&i.Currency,
		&i.OptionType,
		&i.HostNameOption,
		&i.CoverImage,
		&i.Photo,
		&i.TypeOfShortlet,
		&i.HostAsIndividual,
		&i.IsVerified,
		&i.Price,
		&i.WeekendPrice,
		&i.State,
		&i.Country,
		&i.Photo_2,
		&i.FirstName,
		&i.CreatedAt,
		&i.IsVerified_2,
		&i.Category,
		&i.AdvanceNotice,
		&i.AutoBlockDates,
		&i.AdvanceNoticeCondition,
		&i.PreparationTime,
		&i.AvailabilityWindow,
		&i.MinStayDay,
		&i.MaxStayNight,
		&i.ManualApproveRequestPassMax,
		&i.AllowReservationRequest,
	)
	return i, err
}

const getOptionExperienceByOptionUserID = `-- name: GetOptionExperienceByOptionUserID :one
SELECT o_i.id, o_i.option_user_id, o_i.currency, o_i.option_type, o_i_d.host_name_option, o_i_p.cover_image, o_i_p.photo, s.type_of_shortlet, o_q.host_as_individual, o_i.is_verified, o_p.price, o_p.weekend_price, l.state, l.country, u.photo, u.first_name, u.created_at, i_d.is_verified, o_i.category, oas.advance_notice, oas.auto_block_dates, oas.advance_notice_condition, oas.preparation_time, oas.availability_window, otl.min_stay_day, otl.max_stay_night, otl.manual_approve_request_pass_max, otl.allow_reservation_request
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN shortlets s on o_i.id = s.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN options_prices o_p on o_i.id = o_p.option_id
   JOIN locations l on o_i.id = l.option_id
   JOIN users u on o_i.host_id = u.id
   JOIN identity i_d on u.id = i_d.user_id
   JOIN option_availability_settings oas on o_i.id = oas.option_id
   JOIN option_trip_lengths otl on o_i.id = otl.option_id
WHERE  o_i.option_user_id  = $1 AND o_i.is_complete = $2 AND u.is_active = $3 AND o_i.is_active = $4 AND o_i_s.status != 'unlist' AND o_i_s.status != 'snooze'
`

type GetOptionExperienceByOptionUserIDParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	IsComplete   bool      `json:"is_complete"`
	IsActive     bool      `json:"is_active"`
	IsActive_2   bool      `json:"is_active_2"`
}

type GetOptionExperienceByOptionUserIDRow struct {
	ID                          uuid.UUID `json:"id"`
	OptionUserID                uuid.UUID `json:"option_user_id"`
	Currency                    string    `json:"currency"`
	OptionType                  string    `json:"option_type"`
	HostNameOption              string    `json:"host_name_option"`
	CoverImage                  string    `json:"cover_image"`
	Photo                       []string  `json:"photo"`
	TypeOfShortlet              string    `json:"type_of_shortlet"`
	HostAsIndividual            bool      `json:"host_as_individual"`
	IsVerified                  bool      `json:"is_verified"`
	Price                       int64     `json:"price"`
	WeekendPrice                int64     `json:"weekend_price"`
	State                       string    `json:"state"`
	Country                     string    `json:"country"`
	Photo_2                     string    `json:"photo_2"`
	FirstName                   string    `json:"first_name"`
	CreatedAt                   time.Time `json:"created_at"`
	IsVerified_2                bool      `json:"is_verified_2"`
	Category                    string    `json:"category"`
	AdvanceNotice               string    `json:"advance_notice"`
	AutoBlockDates              bool      `json:"auto_block_dates"`
	AdvanceNoticeCondition      string    `json:"advance_notice_condition"`
	PreparationTime             string    `json:"preparation_time"`
	AvailabilityWindow          string    `json:"availability_window"`
	MinStayDay                  int32     `json:"min_stay_day"`
	MaxStayNight                int32     `json:"max_stay_night"`
	ManualApproveRequestPassMax bool      `json:"manual_approve_request_pass_max"`
	AllowReservationRequest     bool      `json:"allow_reservation_request"`
}

func (q *Queries) GetOptionExperienceByOptionUserID(ctx context.Context, arg GetOptionExperienceByOptionUserIDParams) (GetOptionExperienceByOptionUserIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionExperienceByOptionUserID,
		arg.OptionUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
	)
	var i GetOptionExperienceByOptionUserIDRow
	err := row.Scan(
		&i.ID,
		&i.OptionUserID,
		&i.Currency,
		&i.OptionType,
		&i.HostNameOption,
		&i.CoverImage,
		&i.Photo,
		&i.TypeOfShortlet,
		&i.HostAsIndividual,
		&i.IsVerified,
		&i.Price,
		&i.WeekendPrice,
		&i.State,
		&i.Country,
		&i.Photo_2,
		&i.FirstName,
		&i.CreatedAt,
		&i.IsVerified_2,
		&i.Category,
		&i.AdvanceNotice,
		&i.AutoBlockDates,
		&i.AdvanceNoticeCondition,
		&i.PreparationTime,
		&i.AvailabilityWindow,
		&i.MinStayDay,
		&i.MaxStayNight,
		&i.ManualApproveRequestPassMax,
		&i.AllowReservationRequest,
	)
	return i, err
}

const getOptionExperienceCount = `-- name: GetOptionExperienceCount :one
SELECT COUNT(*)
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN shortlets s on o_i.id = s.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN options_prices o_p on o_i.id = o_p.option_id
   JOIN users u on u.id = o_i.host_id
WHERE o_i.is_complete = $1 AND o_i.is_active = $2 AND o_i.main_option_type = $3 AND (o_i.category = $4 OR o_i.category_two = $4 OR o_i.category_three = $4) AND u.is_active = $5 AND o_i_s.status != 'unlist' AND o_i_s.status != 'snooze'
`

type GetOptionExperienceCountParams struct {
	IsComplete     bool   `json:"is_complete"`
	IsActive       bool   `json:"is_active"`
	MainOptionType string `json:"main_option_type"`
	Category       string `json:"category"`
	IsActive_2     bool   `json:"is_active_2"`
}

func (q *Queries) GetOptionExperienceCount(ctx context.Context, arg GetOptionExperienceCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getOptionExperienceCount,
		arg.IsComplete,
		arg.IsActive,
		arg.MainOptionType,
		arg.Category,
		arg.IsActive_2,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOptionExperienceMap = `-- name: GetOptionExperienceMap :one
SELECT o_i.option_user_id, o_i.currency, o_i_d.host_name_option, o_i_p.cover_image, o_i.is_verified, o_p.price, l.state, l.country, o_i.category
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN options_prices o_p on o_i.id = o_p.option_id
   JOIN locations l on o_i.id = l.option_id
   JOIN users u on o_i.host_id = u.id
WHERE  o_i.option_user_id  = $1 AND o_i.is_complete = $2 AND u.is_active = $3 AND o_i.is_active = $4 AND o_i_s.status != 'unlist' AND o_i_s.status != 'snooze'
`

type GetOptionExperienceMapParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	IsComplete   bool      `json:"is_complete"`
	IsActive     bool      `json:"is_active"`
	IsActive_2   bool      `json:"is_active_2"`
}

type GetOptionExperienceMapRow struct {
	OptionUserID   uuid.UUID `json:"option_user_id"`
	Currency       string    `json:"currency"`
	HostNameOption string    `json:"host_name_option"`
	CoverImage     string    `json:"cover_image"`
	IsVerified     bool      `json:"is_verified"`
	Price          int64     `json:"price"`
	State          string    `json:"state"`
	Country        string    `json:"country"`
	Category       string    `json:"category"`
}

func (q *Queries) GetOptionExperienceMap(ctx context.Context, arg GetOptionExperienceMapParams) (GetOptionExperienceMapRow, error) {
	row := q.db.QueryRow(ctx, getOptionExperienceMap,
		arg.OptionUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
	)
	var i GetOptionExperienceMapRow
	err := row.Scan(
		&i.OptionUserID,
		&i.Currency,
		&i.HostNameOption,
		&i.CoverImage,
		&i.IsVerified,
		&i.Price,
		&i.State,
		&i.Country,
		&i.Category,
	)
	return i, err
}

const getOptionInfoMain = `-- name: GetOptionInfoMain :one
SELECT oi.id,
oi.co_host_id,
oi.option_user_id,
oi.host_id,
oi.primary_user_id,
oi.deep_link_id,
oi.is_active,
oi.is_complete,
oi.is_verified,
od.host_name_option,
oi.category,
oi.category_two,
oi.category_three,
oi.category_four,
oi.is_top_seller,
oi.time_zone,
oi.currency,
oi.option_img,
oi.option_type,
oi.main_option_type,
oi.created_at,
oi.completed,
oi.updated_at,
u.id AS u_id,
u.user_id,
u.deep_link_id AS user_deep_link_id,
u.firebase_id,
u.hashed_password,
u.firebase_password,
u.email,
u.phone_number,
u.first_name,
u.username,
u.last_name,
u.date_of_birth,
u.dial_code,
u.dial_country,
u.current_option_id,
u.currency AS u_currency,
u.default_card,
u.default_payout_card,
u.default_account_id,
u.is_active AS u_is_active,
u.photo,
u.password_changed_at AS u_password_changed_at,
u.created_at AS u_created_at,
u.updated_at AS u_updated_at,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.insights::boolean
   WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS insight,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.calender::boolean
   WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS calender,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_co_hosts::boolean
   WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_co_hosts,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_option_info::boolean
   WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_option_info,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_event_dates_times::boolean
   WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_event_dates_times,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.post::boolean
   WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS post,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.scan_code::boolean
   WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS scan_code,
CASE WHEN och_subquery.reservations IS NOT NULL THEN och_subquery.scan_code::boolean
   WHEN oi.host_id = $1 THEN true
   ELSE false -- Optional: Handle other cases if needed
END AS reservations,
CASE WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
   WHEN oi.host_id = $1 THEN 'main_host'
   ELSE 'none' -- Optional: Handle other cases if needed
END AS host_type
FROM options_infos oi
JOIN options_info_details od ON od.option_id = oi.id
JOIN users u ON u.id = oi.host_id
LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, edit_option_info, edit_event_dates_times, insights
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE ((oi.id = $3 AND oi.host_id = $1) OR (oi.co_host_id = $4 AND och_subquery.option_id IS NOT NULL)) AND oi.is_complete = true
`

type GetOptionInfoMainParams struct {
	MainHostID     uuid.UUID `json:"main_host_id"`
	CoUserID       string    `json:"co_user_id"`
	OptionID       uuid.UUID `json:"option_id"`
	OptionCoHostID uuid.UUID `json:"option_co_host_id"`
}

type GetOptionInfoMainRow struct {
	ID                  uuid.UUID `json:"id"`
	CoHostID            uuid.UUID `json:"co_host_id"`
	OptionUserID        uuid.UUID `json:"option_user_id"`
	HostID              uuid.UUID `json:"host_id"`
	PrimaryUserID       uuid.UUID `json:"primary_user_id"`
	DeepLinkID          uuid.UUID `json:"deep_link_id"`
	IsActive            bool      `json:"is_active"`
	IsComplete          bool      `json:"is_complete"`
	IsVerified          bool      `json:"is_verified"`
	HostNameOption      string    `json:"host_name_option"`
	Category            string    `json:"category"`
	CategoryTwo         string    `json:"category_two"`
	CategoryThree       string    `json:"category_three"`
	CategoryFour        string    `json:"category_four"`
	IsTopSeller         bool      `json:"is_top_seller"`
	TimeZone            string    `json:"time_zone"`
	Currency            string    `json:"currency"`
	OptionImg           string    `json:"option_img"`
	OptionType          string    `json:"option_type"`
	MainOptionType      string    `json:"main_option_type"`
	CreatedAt           time.Time `json:"created_at"`
	Completed           time.Time `json:"completed"`
	UpdatedAt           time.Time `json:"updated_at"`
	UID                 uuid.UUID `json:"u_id"`
	UserID              uuid.UUID `json:"user_id"`
	UserDeepLinkID      uuid.UUID `json:"user_deep_link_id"`
	FirebaseID          uuid.UUID `json:"firebase_id"`
	HashedPassword      string    `json:"hashed_password"`
	FirebasePassword    string    `json:"firebase_password"`
	Email               string    `json:"email"`
	PhoneNumber         string    `json:"phone_number"`
	FirstName           string    `json:"first_name"`
	Username            string    `json:"username"`
	LastName            string    `json:"last_name"`
	DateOfBirth         time.Time `json:"date_of_birth"`
	DialCode            string    `json:"dial_code"`
	DialCountry         string    `json:"dial_country"`
	CurrentOptionID     string    `json:"current_option_id"`
	UCurrency           string    `json:"u_currency"`
	DefaultCard         string    `json:"default_card"`
	DefaultPayoutCard   string    `json:"default_payout_card"`
	DefaultAccountID    string    `json:"default_account_id"`
	UIsActive           bool      `json:"u_is_active"`
	Photo               string    `json:"photo"`
	UPasswordChangedAt  time.Time `json:"u_password_changed_at"`
	UCreatedAt          time.Time `json:"u_created_at"`
	UUpdatedAt          time.Time `json:"u_updated_at"`
	Insight             bool      `json:"insight"`
	Calender            bool      `json:"calender"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Reservations        bool      `json:"reservations"`
	HostType            string    `json:"host_type"`
}

func (q *Queries) GetOptionInfoMain(ctx context.Context, arg GetOptionInfoMainParams) (GetOptionInfoMainRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoMain,
		arg.MainHostID,
		arg.CoUserID,
		arg.OptionID,
		arg.OptionCoHostID,
	)
	var i GetOptionInfoMainRow
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.PrimaryUserID,
		&i.DeepLinkID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.HostNameOption,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
		&i.UID,
		&i.UserID,
		&i.UserDeepLinkID,
		&i.FirebaseID,
		&i.HashedPassword,
		&i.FirebasePassword,
		&i.Email,
		&i.PhoneNumber,
		&i.FirstName,
		&i.Username,
		&i.LastName,
		&i.DateOfBirth,
		&i.DialCode,
		&i.DialCountry,
		&i.CurrentOptionID,
		&i.UCurrency,
		&i.DefaultCard,
		&i.DefaultPayoutCard,
		&i.DefaultAccountID,
		&i.UIsActive,
		&i.Photo,
		&i.UPasswordChangedAt,
		&i.UCreatedAt,
		&i.UUpdatedAt,
		&i.Insight,
		&i.Calender,
		&i.EditCoHosts,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.Post,
		&i.ScanCode,
		&i.Reservations,
		&i.HostType,
	)
	return i, err
}

const getOptionInfoStartYear = `-- name: GetOptionInfoStartYear :one
SELECT oi.created_at AS start_year
FROM options_infos oi
   LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $1 OR och_subquery.option_id IS NOT NULL) AND (oi.host_id = $1 OR och_subquery.insights = true) AND oi.is_complete = $3 AND oi.is_active = $4 AND oi.main_option_type = $5
ORDER BY oi.created_at ASC
`

type GetOptionInfoStartYearParams struct {
	HostID         uuid.UUID `json:"host_id"`
	CoUserID       string    `json:"co_user_id"`
	IsComplete     bool      `json:"is_complete"`
	IsActive       bool      `json:"is_active"`
	MainOptionType string    `json:"main_option_type"`
}

func (q *Queries) GetOptionInfoStartYear(ctx context.Context, arg GetOptionInfoStartYearParams) (time.Time, error) {
	row := q.db.QueryRow(ctx, getOptionInfoStartYear,
		arg.HostID,
		arg.CoUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.MainOptionType,
	)
	var start_year time.Time
	err := row.Scan(&start_year)
	return start_year, err
}

const listEventExperience = `-- name: ListEventExperience :many
SELECT o_i.id, o_i.option_user_id, o_i.currency, o_i.option_type, o_i_d.host_name_option, o_i_p.cover_image, o_i_p.photo, o_i.is_verified, e_i.event_type, e_i.sub_category_type, o_q.host_as_individual, u.photo, u.first_name, u.created_at, i_d.is_verified, o_i.category, o_i_s.status, o_i.category_two, o_i.category_three
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN event_infos e_i on o_i.id = e_i.option_id
   JOIN users u on o_i.host_id = u.id
   JOIN identity i_d on u.id = i_d.user_id
WHERE o_i.is_complete = $1 AND u.is_active = $2 AND o_i.is_active = $3 AND o_i.main_option_type = $4
`

type ListEventExperienceParams struct {
	IsComplete     bool   `json:"is_complete"`
	IsActive       bool   `json:"is_active"`
	IsActive_2     bool   `json:"is_active_2"`
	MainOptionType string `json:"main_option_type"`
}

type ListEventExperienceRow struct {
	ID               uuid.UUID `json:"id"`
	OptionUserID     uuid.UUID `json:"option_user_id"`
	Currency         string    `json:"currency"`
	OptionType       string    `json:"option_type"`
	HostNameOption   string    `json:"host_name_option"`
	CoverImage       string    `json:"cover_image"`
	Photo            []string  `json:"photo"`
	IsVerified       bool      `json:"is_verified"`
	EventType        string    `json:"event_type"`
	SubCategoryType  string    `json:"sub_category_type"`
	HostAsIndividual bool      `json:"host_as_individual"`
	Photo_2          string    `json:"photo_2"`
	FirstName        string    `json:"first_name"`
	CreatedAt        time.Time `json:"created_at"`
	IsVerified_2     bool      `json:"is_verified_2"`
	Category         string    `json:"category"`
	Status           string    `json:"status"`
	CategoryTwo      string    `json:"category_two"`
	CategoryThree    string    `json:"category_three"`
}

func (q *Queries) ListEventExperience(ctx context.Context, arg ListEventExperienceParams) ([]ListEventExperienceRow, error) {
	rows, err := q.db.Query(ctx, listEventExperience,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
		arg.MainOptionType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventExperienceRow{}
	for rows.Next() {
		var i ListEventExperienceRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionUserID,
			&i.Currency,
			&i.OptionType,
			&i.HostNameOption,
			&i.CoverImage,
			&i.Photo,
			&i.IsVerified,
			&i.EventType,
			&i.SubCategoryType,
			&i.HostAsIndividual,
			&i.Photo_2,
			&i.FirstName,
			&i.CreatedAt,
			&i.IsVerified_2,
			&i.Category,
			&i.Status,
			&i.CategoryTwo,
			&i.CategoryThree,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventExperienceByLocation = `-- name: ListEventExperienceByLocation :many
SELECT o_i.id, o_i.option_user_id, o_i.currency, o_i.option_type, o_i_d.host_name_option, o_i_p.cover_image, o_i_p.photo, o_i.is_verified, e_i.event_type, e_i.sub_category_type, o_q.host_as_individual, u.photo, u.first_name, u.created_at, i_d.is_verified, o_i.category
FROM options_infos o_i
JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN event_infos e_i on o_i.id = e_i.option_id
   JOIN users u on o_i.host_id = u.id
   JOIN identity i_d on u.id = i_d.user_id
LEFT JOIN event_date_times e_d_t on e_i.option_id = e_d_t.event_info_id
LEFT JOIN event_date_locations e_d_l ON e_d_t.id = e_d_l.event_date_time_id
WHERE o_i.is_complete = $1 AND u.is_active = $2 AND o_i.is_active = $3 AND o_i.main_option_type = $4 AND (o_i_s.status = $10 OR o_i_s.status = $11) AND (o_i.category = $5 OR o_i.category_two = $5 OR o_i.category_three = $5)
ORDER BY CASE WHEN LOWER(e_d_l.country) = $6 AND LOWER(e_d_l.state) = $7 THEN 0 ELSE 1 END, o_i.created_at DESC
LIMIT $8
OFFSET $9
`

type ListEventExperienceByLocationParams struct {
	IsComplete      bool   `json:"is_complete"`
	IsActive        bool   `json:"is_active"`
	IsActive_2      bool   `json:"is_active_2"`
	MainOptionType  string `json:"main_option_type"`
	Category        string `json:"category"`
	Country         string `json:"country"`
	State           string `json:"state"`
	Limit           int32  `json:"limit"`
	Offset          int32  `json:"offset"`
	OptionStatusOne string `json:"option_status_one"`
	OptionStatusTwo string `json:"option_status_two"`
}

type ListEventExperienceByLocationRow struct {
	ID               uuid.UUID `json:"id"`
	OptionUserID     uuid.UUID `json:"option_user_id"`
	Currency         string    `json:"currency"`
	OptionType       string    `json:"option_type"`
	HostNameOption   string    `json:"host_name_option"`
	CoverImage       string    `json:"cover_image"`
	Photo            []string  `json:"photo"`
	IsVerified       bool      `json:"is_verified"`
	EventType        string    `json:"event_type"`
	SubCategoryType  string    `json:"sub_category_type"`
	HostAsIndividual bool      `json:"host_as_individual"`
	Photo_2          string    `json:"photo_2"`
	FirstName        string    `json:"first_name"`
	CreatedAt        time.Time `json:"created_at"`
	IsVerified_2     bool      `json:"is_verified_2"`
	Category         string    `json:"category"`
}

func (q *Queries) ListEventExperienceByLocation(ctx context.Context, arg ListEventExperienceByLocationParams) ([]ListEventExperienceByLocationRow, error) {
	rows, err := q.db.Query(ctx, listEventExperienceByLocation,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
		arg.MainOptionType,
		arg.Category,
		arg.Country,
		arg.State,
		arg.Limit,
		arg.Offset,
		arg.OptionStatusOne,
		arg.OptionStatusTwo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventExperienceByLocationRow{}
	for rows.Next() {
		var i ListEventExperienceByLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionUserID,
			&i.Currency,
			&i.OptionType,
			&i.HostNameOption,
			&i.CoverImage,
			&i.Photo,
			&i.IsVerified,
			&i.EventType,
			&i.SubCategoryType,
			&i.HostAsIndividual,
			&i.Photo_2,
			&i.FirstName,
			&i.CreatedAt,
			&i.IsVerified_2,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionExperience = `-- name: ListOptionExperience :many
SELECT o_i.id, o_i.option_user_id, o_i.currency, o_i.option_type, o_i_d.host_name_option, o_i_p.cover_image, o_i_p.photo, s.type_of_shortlet, o_q.host_as_individual, o_i.is_verified, o_p.price, o_p.weekend_price, l.state, l.country, u.photo, l.geolocation, u.first_name, u.created_at, i_d.is_verified, o_i.category, o_i_s.status, o_i.category_two, o_i.category_three, oas.advance_notice, oas.auto_block_dates, oas.advance_notice_condition, oas.preparation_time, oas.availability_window, otl.min_stay_day, otl.max_stay_night, otl.manual_approve_request_pass_max, otl.allow_reservation_request
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN shortlets s on o_i.id = s.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN options_prices o_p on o_i.id = o_p.option_id
   JOIN locations l on o_i.id = l.option_id
   JOIN users u on o_i.host_id = u.id
   JOIN identity i_d on u.id = i_d.user_id
   JOIN option_availability_settings oas on o_i.id = oas.option_id
   JOIN option_trip_lengths otl on o_i.id = otl.option_id
WHERE o_i.is_complete = $1 AND u.is_active = $2 AND o_i.is_active = $3 AND o_i.main_option_type = $4
ORDER BY (u.id = 'a29143e6-2dcc-45ae-ae3d-26dbe5637067' OR u.id = '80dd6eac-6367-4ad7-b202-d7502baa581d' OR u.id = '06f63694-7208-48c4-b885-3d2f4baacb68' OR u.id = '09383658-58dd-49d6-be6d-003acccbac7f'OR u.id = 'da885ea9-ed82-4071-b2a3-422eae3f9bfb') AND o_p.price > 4000000 AND o_p.price < 9600000 DESC
`

type ListOptionExperienceParams struct {
	IsComplete     bool   `json:"is_complete"`
	IsActive       bool   `json:"is_active"`
	IsActive_2     bool   `json:"is_active_2"`
	MainOptionType string `json:"main_option_type"`
}

type ListOptionExperienceRow struct {
	ID                          uuid.UUID    `json:"id"`
	OptionUserID                uuid.UUID    `json:"option_user_id"`
	Currency                    string       `json:"currency"`
	OptionType                  string       `json:"option_type"`
	HostNameOption              string       `json:"host_name_option"`
	CoverImage                  string       `json:"cover_image"`
	Photo                       []string     `json:"photo"`
	TypeOfShortlet              string       `json:"type_of_shortlet"`
	HostAsIndividual            bool         `json:"host_as_individual"`
	IsVerified                  bool         `json:"is_verified"`
	Price                       int64        `json:"price"`
	WeekendPrice                int64        `json:"weekend_price"`
	State                       string       `json:"state"`
	Country                     string       `json:"country"`
	Photo_2                     string       `json:"photo_2"`
	Geolocation                 pgtype.Point `json:"geolocation"`
	FirstName                   string       `json:"first_name"`
	CreatedAt                   time.Time    `json:"created_at"`
	IsVerified_2                bool         `json:"is_verified_2"`
	Category                    string       `json:"category"`
	Status                      string       `json:"status"`
	CategoryTwo                 string       `json:"category_two"`
	CategoryThree               string       `json:"category_three"`
	AdvanceNotice               string       `json:"advance_notice"`
	AutoBlockDates              bool         `json:"auto_block_dates"`
	AdvanceNoticeCondition      string       `json:"advance_notice_condition"`
	PreparationTime             string       `json:"preparation_time"`
	AvailabilityWindow          string       `json:"availability_window"`
	MinStayDay                  int32        `json:"min_stay_day"`
	MaxStayNight                int32        `json:"max_stay_night"`
	ManualApproveRequestPassMax bool         `json:"manual_approve_request_pass_max"`
	AllowReservationRequest     bool         `json:"allow_reservation_request"`
}

func (q *Queries) ListOptionExperience(ctx context.Context, arg ListOptionExperienceParams) ([]ListOptionExperienceRow, error) {
	rows, err := q.db.Query(ctx, listOptionExperience,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
		arg.MainOptionType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionExperienceRow{}
	for rows.Next() {
		var i ListOptionExperienceRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionUserID,
			&i.Currency,
			&i.OptionType,
			&i.HostNameOption,
			&i.CoverImage,
			&i.Photo,
			&i.TypeOfShortlet,
			&i.HostAsIndividual,
			&i.IsVerified,
			&i.Price,
			&i.WeekendPrice,
			&i.State,
			&i.Country,
			&i.Photo_2,
			&i.Geolocation,
			&i.FirstName,
			&i.CreatedAt,
			&i.IsVerified_2,
			&i.Category,
			&i.Status,
			&i.CategoryTwo,
			&i.CategoryThree,
			&i.AdvanceNotice,
			&i.AutoBlockDates,
			&i.AdvanceNoticeCondition,
			&i.PreparationTime,
			&i.AvailabilityWindow,
			&i.MinStayDay,
			&i.MaxStayNight,
			&i.ManualApproveRequestPassMax,
			&i.AllowReservationRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionExperienceByLocation = `-- name: ListOptionExperienceByLocation :many
SELECT o_i.id, o_i.option_user_id, o_i.currency, o_i.option_type, o_i_d.host_name_option, o_i_p.cover_image, o_i_p.photo, s.type_of_shortlet, o_q.host_as_individual, o_i.is_verified, o_p.price, o_p.weekend_price, l.state, l.country, u.photo, u.first_name, u.created_at, i_d.is_verified, o_i.category, oas.advance_notice, oas.auto_block_dates, oas.advance_notice_condition, oas.preparation_time, oas.availability_window, otl.min_stay_day, otl.max_stay_night, otl.manual_approve_request_pass_max, otl.allow_reservation_request
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN shortlets s on o_i.id = s.option_id
   JOIN options_infos_status o_i_s on o_i.id = o_i_s.option_id
   JOIN option_questions o_q on o_i.id = o_q.option_id
   JOIN options_prices o_p on o_i.id = o_p.option_id
   JOIN locations l on o_i.id = l.option_id
   JOIN users u on o_i.host_id = u.id
   JOIN identity i_d on u.id = i_d.user_id
   JOIN option_availability_settings oas on o_i.id = oas.option_id
   JOIN option_trip_lengths otl on o_i.id = otl.option_id
WHERE o_i.is_complete = $1 AND u.is_active = $2 AND o_i.is_active = $3 AND o_i.main_option_type = $4 AND (o_i_s.status = $10 OR o_i_s.status = $11) AND (o_i.category = $5 OR o_i.category_two = $5 OR o_i.category_three = $5)
ORDER BY CASE WHEN lOWER(l.country)= $6 AND LOWER(l.state) = $7 THEN 0 ELSE 1 END, o_i.created_at DESC
LIMIT $8
OFFSET $9
`

type ListOptionExperienceByLocationParams struct {
	IsComplete      bool   `json:"is_complete"`
	IsActive        bool   `json:"is_active"`
	IsActive_2      bool   `json:"is_active_2"`
	MainOptionType  string `json:"main_option_type"`
	Category        string `json:"category"`
	Country         string `json:"country"`
	State           string `json:"state"`
	Limit           int32  `json:"limit"`
	Offset          int32  `json:"offset"`
	OptionStatusOne string `json:"option_status_one"`
	OptionStatusTwo string `json:"option_status_two"`
}

type ListOptionExperienceByLocationRow struct {
	ID                          uuid.UUID `json:"id"`
	OptionUserID                uuid.UUID `json:"option_user_id"`
	Currency                    string    `json:"currency"`
	OptionType                  string    `json:"option_type"`
	HostNameOption              string    `json:"host_name_option"`
	CoverImage                  string    `json:"cover_image"`
	Photo                       []string  `json:"photo"`
	TypeOfShortlet              string    `json:"type_of_shortlet"`
	HostAsIndividual            bool      `json:"host_as_individual"`
	IsVerified                  bool      `json:"is_verified"`
	Price                       int64     `json:"price"`
	WeekendPrice                int64     `json:"weekend_price"`
	State                       string    `json:"state"`
	Country                     string    `json:"country"`
	Photo_2                     string    `json:"photo_2"`
	FirstName                   string    `json:"first_name"`
	CreatedAt                   time.Time `json:"created_at"`
	IsVerified_2                bool      `json:"is_verified_2"`
	Category                    string    `json:"category"`
	AdvanceNotice               string    `json:"advance_notice"`
	AutoBlockDates              bool      `json:"auto_block_dates"`
	AdvanceNoticeCondition      string    `json:"advance_notice_condition"`
	PreparationTime             string    `json:"preparation_time"`
	AvailabilityWindow          string    `json:"availability_window"`
	MinStayDay                  int32     `json:"min_stay_day"`
	MaxStayNight                int32     `json:"max_stay_night"`
	ManualApproveRequestPassMax bool      `json:"manual_approve_request_pass_max"`
	AllowReservationRequest     bool      `json:"allow_reservation_request"`
}

func (q *Queries) ListOptionExperienceByLocation(ctx context.Context, arg ListOptionExperienceByLocationParams) ([]ListOptionExperienceByLocationRow, error) {
	rows, err := q.db.Query(ctx, listOptionExperienceByLocation,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
		arg.MainOptionType,
		arg.Category,
		arg.Country,
		arg.State,
		arg.Limit,
		arg.Offset,
		arg.OptionStatusOne,
		arg.OptionStatusTwo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionExperienceByLocationRow{}
	for rows.Next() {
		var i ListOptionExperienceByLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionUserID,
			&i.Currency,
			&i.OptionType,
			&i.HostNameOption,
			&i.CoverImage,
			&i.Photo,
			&i.TypeOfShortlet,
			&i.HostAsIndividual,
			&i.IsVerified,
			&i.Price,
			&i.WeekendPrice,
			&i.State,
			&i.Country,
			&i.Photo_2,
			&i.FirstName,
			&i.CreatedAt,
			&i.IsVerified_2,
			&i.Category,
			&i.AdvanceNotice,
			&i.AutoBlockDates,
			&i.AdvanceNoticeCondition,
			&i.PreparationTime,
			&i.AvailabilityWindow,
			&i.MinStayDay,
			&i.MaxStayNight,
			&i.ManualApproveRequestPassMax,
			&i.AllowReservationRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionInfoInsight = `-- name: ListOptionInfoInsight :many
SELECT oi.id, oi.is_complete, oi.currency, oi.main_option_type, oi.created_at, oi.option_type, od.host_name_option, coi.current_state, coi.previous_state, op.cover_image, ois.status AS option_status, oi.option_user_id,
CASE
   WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
   WHEN oi.host_id = $1 THEN 'main_host'
   ELSE 'none' -- Optional: Handle other cases if needed
END AS host_type
FROM options_infos oi
   JOIN options_info_details od on oi.id = od.option_id
   JOIN options_infos_status ois on ois.option_id = od.option_id
   JOIN complete_option_info coi on oi.id = coi.option_id
   JOIN options_info_photos op on oi.id = op.option_id
   LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $1 OR och_subquery.option_id IS NOT NULL) AND (oi.host_id = $1 OR och_subquery.insights = true) AND oi.is_complete = $3 AND oi.is_active = $4  AND oi.main_option_type = $5
ORDER BY oi.created_at DESC
LIMIT $6
OFFSET $7
`

type ListOptionInfoInsightParams struct {
	HostID         uuid.UUID `json:"host_id"`
	CoUserID       string    `json:"co_user_id"`
	IsComplete     bool      `json:"is_complete"`
	IsActive       bool      `json:"is_active"`
	MainOptionType string    `json:"main_option_type"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type ListOptionInfoInsightRow struct {
	ID             uuid.UUID `json:"id"`
	IsComplete     bool      `json:"is_complete"`
	Currency       string    `json:"currency"`
	MainOptionType string    `json:"main_option_type"`
	CreatedAt      time.Time `json:"created_at"`
	OptionType     string    `json:"option_type"`
	HostNameOption string    `json:"host_name_option"`
	CurrentState   string    `json:"current_state"`
	PreviousState  string    `json:"previous_state"`
	CoverImage     string    `json:"cover_image"`
	OptionStatus   string    `json:"option_status"`
	OptionUserID   uuid.UUID `json:"option_user_id"`
	HostType       string    `json:"host_type"`
}

func (q *Queries) ListOptionInfoInsight(ctx context.Context, arg ListOptionInfoInsightParams) ([]ListOptionInfoInsightRow, error) {
	rows, err := q.db.Query(ctx, listOptionInfoInsight,
		arg.HostID,
		arg.CoUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.MainOptionType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionInfoInsightRow{}
	for rows.Next() {
		var i ListOptionInfoInsightRow
		if err := rows.Scan(
			&i.ID,
			&i.IsComplete,
			&i.Currency,
			&i.MainOptionType,
			&i.CreatedAt,
			&i.OptionType,
			&i.HostNameOption,
			&i.CurrentState,
			&i.PreviousState,
			&i.CoverImage,
			&i.OptionStatus,
			&i.OptionUserID,
			&i.HostType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
