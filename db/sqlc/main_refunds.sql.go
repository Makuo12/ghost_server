// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: main_refunds.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createMainRefund = `-- name: CreateMainRefund :one
INSERT INTO main_refunds (
    charge_id,
    user_percent,
    host_percent,
    charge_type,
    type
) VALUES ($1, $2, $3, $4, $5)
RETURNING user_percent, host_percent
`

type CreateMainRefundParams struct {
	ChargeID    uuid.UUID `json:"charge_id"`
	UserPercent int32     `json:"user_percent"`
	HostPercent int32     `json:"host_percent"`
	ChargeType  string    `json:"charge_type"`
	Type        string    `json:"type"`
}

type CreateMainRefundRow struct {
	UserPercent int32 `json:"user_percent"`
	HostPercent int32 `json:"host_percent"`
}

func (q *Queries) CreateMainRefund(ctx context.Context, arg CreateMainRefundParams) (CreateMainRefundRow, error) {
	row := q.db.QueryRow(ctx, createMainRefund,
		arg.ChargeID,
		arg.UserPercent,
		arg.HostPercent,
		arg.ChargeType,
		arg.Type,
	)
	var i CreateMainRefundRow
	err := row.Scan(&i.UserPercent, &i.HostPercent)
	return i, err
}

const listMainRefundWithCharge = `-- name: ListMainRefundWithCharge :many
SELECT c_r.currency, m_r.charge_id, c_r.reference, m_r.user_percent, u.id AS u_id, m_r.host_percent
FROM main_refunds m_r
    JOIN charge_references c_r on m_r.charge_id = c_r.id
    JOIN users u on u.user_id = c_r.user_id
WHERE m_r.is_payed = $1 AND m_r.charge_type = 'charge_reference'
`

type ListMainRefundWithChargeRow struct {
	Currency    string    `json:"currency"`
	ChargeID    uuid.UUID `json:"charge_id"`
	Reference   uuid.UUID `json:"reference"`
	UserPercent int32     `json:"user_percent"`
	UID         uuid.UUID `json:"u_id"`
	HostPercent int32     `json:"host_percent"`
}

func (q *Queries) ListMainRefundWithCharge(ctx context.Context, refundComplete bool) ([]ListMainRefundWithChargeRow, error) {
	rows, err := q.db.Query(ctx, listMainRefundWithCharge, refundComplete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMainRefundWithChargeRow{}
	for rows.Next() {
		var i ListMainRefundWithChargeRow
		if err := rows.Scan(
			&i.Currency,
			&i.ChargeID,
			&i.Reference,
			&i.UserPercent,
			&i.UID,
			&i.HostPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionMainRefundWithCharge = `-- name: ListOptionMainRefundWithCharge :many
SELECT c_o_r.total_fee, c_o_r.service_fee, us.default_account_id, us.id AS host_id, c_o_r.currency, m_r.charge_id, us.user_id AS host_user_id, c_o_r.start_date, us.first_name, c_o_r.payment_reference, m_r.user_percent, m_r.host_percent, u.id AS u_id
FROM main_refunds m_r
    JOIN charge_option_references c_o_r on m_r.charge_id = c_o_r.id
    JOIN options_infos o_i on o_i.option_user_id = c_o_r.option_user_id
    JOIN users u on u.user_id = c_o_r.user_id
    JOIN users us on o_i.host_id = us.id
WHERE m_r.is_payed = $1 AND m_r.charge_type = 'charge_option_reference'
`

type ListOptionMainRefundWithChargeRow struct {
	TotalFee         int64     `json:"total_fee"`
	ServiceFee       int64     `json:"service_fee"`
	DefaultAccountID string    `json:"default_account_id"`
	HostID           uuid.UUID `json:"host_id"`
	Currency         string    `json:"currency"`
	ChargeID         uuid.UUID `json:"charge_id"`
	HostUserID       uuid.UUID `json:"host_user_id"`
	StartDate        time.Time `json:"start_date"`
	FirstName        string    `json:"first_name"`
	PaymentReference string    `json:"payment_reference"`
	UserPercent      int32     `json:"user_percent"`
	HostPercent      int32     `json:"host_percent"`
	UID              uuid.UUID `json:"u_id"`
}

func (q *Queries) ListOptionMainRefundWithCharge(ctx context.Context, refundComplete bool) ([]ListOptionMainRefundWithChargeRow, error) {
	rows, err := q.db.Query(ctx, listOptionMainRefundWithCharge, refundComplete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionMainRefundWithChargeRow{}
	for rows.Next() {
		var i ListOptionMainRefundWithChargeRow
		if err := rows.Scan(
			&i.TotalFee,
			&i.ServiceFee,
			&i.DefaultAccountID,
			&i.HostID,
			&i.Currency,
			&i.ChargeID,
			&i.HostUserID,
			&i.StartDate,
			&i.FirstName,
			&i.PaymentReference,
			&i.UserPercent,
			&i.HostPercent,
			&i.UID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketMainRefundWithCharge = `-- name: ListTicketMainRefundWithCharge :many
SELECT c_t_r.price AS total_fee, c_t_r.service_fee, us.default_account_id, us.id AS host_id, c_e_r.currency, m_r.charge_id, us.user_id AS host_user_id, us.first_name, c_d_r.start_date, c_d_r.end_date, c_e_r.payment_reference, m_r.user_percent, m_r.host_percent, u.id AS u_id
FROM main_refunds m_r
    JOIN charge_ticket_references c_t_r on c_t_r.id = m_r.charge_id
    JOIN charge_date_references c_d_r on c_d_r.id = c_t_r.charge_date_id
    JOIN charge_event_references c_e_r on c_e_r.id = c_d_r.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = c_e_r.option_user_id
    JOIN users u on u.user_id = c_e_r.user_id
    JOIN users us on o_i.host_id = us.id
WHERE m_r.is_payed = $1 AND m_r.charge_type = 'charge_ticket_reference'
`

type ListTicketMainRefundWithChargeRow struct {
	TotalFee         int64     `json:"total_fee"`
	ServiceFee       int64     `json:"service_fee"`
	DefaultAccountID string    `json:"default_account_id"`
	HostID           uuid.UUID `json:"host_id"`
	Currency         string    `json:"currency"`
	ChargeID         uuid.UUID `json:"charge_id"`
	HostUserID       uuid.UUID `json:"host_user_id"`
	FirstName        string    `json:"first_name"`
	StartDate        time.Time `json:"start_date"`
	EndDate          time.Time `json:"end_date"`
	PaymentReference string    `json:"payment_reference"`
	UserPercent      int32     `json:"user_percent"`
	HostPercent      int32     `json:"host_percent"`
	UID              uuid.UUID `json:"u_id"`
}

func (q *Queries) ListTicketMainRefundWithCharge(ctx context.Context, refundComplete bool) ([]ListTicketMainRefundWithChargeRow, error) {
	rows, err := q.db.Query(ctx, listTicketMainRefundWithCharge, refundComplete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTicketMainRefundWithChargeRow{}
	for rows.Next() {
		var i ListTicketMainRefundWithChargeRow
		if err := rows.Scan(
			&i.TotalFee,
			&i.ServiceFee,
			&i.DefaultAccountID,
			&i.HostID,
			&i.Currency,
			&i.ChargeID,
			&i.HostUserID,
			&i.FirstName,
			&i.StartDate,
			&i.EndDate,
			&i.PaymentReference,
			&i.UserPercent,
			&i.HostPercent,
			&i.UID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMainRefund = `-- name: UpdateMainRefund :one
UPDATE main_refunds
SET 
    is_payed = $1,
    updated_at = NOW()
WHERE charge_id = $2
RETURNING charge_id, user_percent, host_percent, charge_type, type, is_payed, created_at, updated_at
`

type UpdateMainRefundParams struct {
	IsPayed  bool      `json:"is_payed"`
	ChargeID uuid.UUID `json:"charge_id"`
}

func (q *Queries) UpdateMainRefund(ctx context.Context, arg UpdateMainRefundParams) (MainRefund, error) {
	row := q.db.QueryRow(ctx, updateMainRefund, arg.IsPayed, arg.ChargeID)
	var i MainRefund
	err := row.Scan(
		&i.ChargeID,
		&i.UserPercent,
		&i.HostPercent,
		&i.ChargeType,
		&i.Type,
		&i.IsPayed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
