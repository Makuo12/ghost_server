// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: messages.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    msg_id,
    sender_id,
    receiver_id,
    message,
    type,
    main_image,
    read,
    parent_id,
    reference,
    created_at,
    updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING msg_id, id as m_id
`

type CreateMessageParams struct {
	MsgID      uuid.UUID `json:"msg_id"`
	SenderID   uuid.UUID `json:"sender_id"`
	ReceiverID uuid.UUID `json:"receiver_id"`
	Message    string    `json:"message"`
	Type       string    `json:"type"`
	MainImage  string    `json:"main_image"`
	Read       bool      `json:"read"`
	ParentID   string    `json:"parent_id"`
	Reference  string    `json:"reference"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type CreateMessageRow struct {
	MsgID uuid.UUID `json:"msg_id"`
	MID   uuid.UUID `json:"m_id"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (CreateMessageRow, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.MsgID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Message,
		arg.Type,
		arg.MainImage,
		arg.Read,
		arg.ParentID,
		arg.Reference,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i CreateMessageRow
	err := row.Scan(&i.MsgID, &i.MID)
	return i, err
}

const getMessage = `-- name: GetMessage :one
SELECT 
    m.id AS message_id,
    m.msg_id,
    m.sender_id,
    m.receiver_id,
    m.message,
    m.type,
    m.read,
    m.main_image,
    m.parent_id,
    m.reference,
    m.created_at,
    m.updated_at,
    p.id AS main_parent_id,
    p.msg_id AS parent_msg_id,
    p.sender_id AS parent_sender_id,
    p.receiver_id AS parent_receiver_id,
    p.message AS parent_message,
    p.type AS parent_type,
    p.read AS parent_read,
    p.main_image AS parent_main_image,
    p.parent_id AS parent_parent_id,
    p.reference AS parent_reference,
    p.created_at AS parent_created_at,
    p.updated_at AS parent_updated_at
FROM messages m
LEFT JOIN messages p ON m.parent_id <> 'none' AND m.parent_id = p.msg_id::VARCHAR
WHERE m.id = $1
`

type GetMessageRow struct {
	MessageID        uuid.UUID          `json:"message_id"`
	MsgID            uuid.UUID          `json:"msg_id"`
	SenderID         uuid.UUID          `json:"sender_id"`
	ReceiverID       uuid.UUID          `json:"receiver_id"`
	Message          string             `json:"message"`
	Type             string             `json:"type"`
	Read             bool               `json:"read"`
	MainImage        string             `json:"main_image"`
	ParentID         string             `json:"parent_id"`
	Reference        string             `json:"reference"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	MainParentID     pgtype.UUID        `json:"main_parent_id"`
	ParentMsgID      pgtype.UUID        `json:"parent_msg_id"`
	ParentSenderID   pgtype.UUID        `json:"parent_sender_id"`
	ParentReceiverID pgtype.UUID        `json:"parent_receiver_id"`
	ParentMessage    pgtype.Text        `json:"parent_message"`
	ParentType       pgtype.Text        `json:"parent_type"`
	ParentRead       pgtype.Bool        `json:"parent_read"`
	ParentMainImage  pgtype.Text        `json:"parent_main_image"`
	ParentParentID   pgtype.Text        `json:"parent_parent_id"`
	ParentReference  pgtype.Text        `json:"parent_reference"`
	ParentCreatedAt  pgtype.Timestamptz `json:"parent_created_at"`
	ParentUpdatedAt  pgtype.Timestamptz `json:"parent_updated_at"`
}

func (q *Queries) GetMessage(ctx context.Context, id uuid.UUID) (GetMessageRow, error) {
	row := q.db.QueryRow(ctx, getMessage, id)
	var i GetMessageRow
	err := row.Scan(
		&i.MessageID,
		&i.MsgID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Message,
		&i.Type,
		&i.Read,
		&i.MainImage,
		&i.ParentID,
		&i.Reference,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainParentID,
		&i.ParentMsgID,
		&i.ParentSenderID,
		&i.ParentReceiverID,
		&i.ParentMessage,
		&i.ParentType,
		&i.ParentRead,
		&i.ParentMainImage,
		&i.ParentParentID,
		&i.ParentReference,
		&i.ParentCreatedAt,
		&i.ParentUpdatedAt,
	)
	return i, err
}

const getMessageByMsgID = `-- name: GetMessageByMsgID :one
SELECT id, msg_id, sender_id, receiver_id, message, type, read, main_image, parent_id, reference, created_at, updated_at
FROM messages
WHERE msg_id = $1 AND (sender_id = $2 OR receiver_id = $3)
`

type GetMessageByMsgIDParams struct {
	MsgID      uuid.UUID `json:"msg_id"`
	SenderID   uuid.UUID `json:"sender_id"`
	ReceiverID uuid.UUID `json:"receiver_id"`
}

func (q *Queries) GetMessageByMsgID(ctx context.Context, arg GetMessageByMsgIDParams) (Message, error) {
	row := q.db.QueryRow(ctx, getMessageByMsgID, arg.MsgID, arg.SenderID, arg.ReceiverID)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.MsgID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Message,
		&i.Type,
		&i.Read,
		&i.MainImage,
		&i.ParentID,
		&i.Reference,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageByRef = `-- name: GetMessageByRef :one
SELECT id, msg_id, sender_id, receiver_id, message, type, read, main_image, parent_id, reference, created_at, updated_at
FROM messages
WHERE reference = $1
`

func (q *Queries) GetMessageByRef(ctx context.Context, reference string) (Message, error) {
	row := q.db.QueryRow(ctx, getMessageByRef, reference)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.MsgID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Message,
		&i.Type,
		&i.Read,
		&i.MainImage,
		&i.ParentID,
		&i.Reference,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageContact = `-- name: GetMessageContact :one
SELECT
    connected_user_id::uuid,
    u.first_name,
    u.image,
    last_message,
    last_message_time,
    send_id::uuid,
    message_id::uuid,
    COUNT(CASE WHEN unread_messages.read = false AND unread_messages.type != 'user_request' AND unread_messages.sender_id != $1 THEN 1 END) AS unread_message_count,
    COUNT(CASE WHEN unread_messages.type = 'user_request' AND NOW() < (unread_messages.created_at + INTERVAL '2 days') AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_user_request_count,
    COUNT(CASE WHEN unread_messages.type = 'user_cancel' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_user_cancel_count,
    COUNT(CASE WHEN unread_messages.type = 'host_cancel' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_host_cancel_count,
    COUNT(CASE WHEN unread_messages.type = 'host_change_dates' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_host_change_dates_count
FROM (
    SELECT DISTINCT
        CASE
            WHEN m.sender_id = $1 THEN m.receiver_id
            WHEN m.receiver_id = $1 THEN m.sender_id
        END AS connected_user_id,
        m.message AS last_message,
        m.created_at AS last_message_time,
        m.sender_id AS send_id,
        m.msg_id AS message_id
    FROM messages m
    WHERE (m.sender_id = $1 OR m.receiver_id = $1)
    AND m.created_at = (
        SELECT MAX(created_at)
        FROM messages
        WHERE (sender_id = m.sender_id AND receiver_id = m.receiver_id)
            OR (sender_id = m.receiver_id AND receiver_id = m.sender_id)
    ) AND m.msg_id = $2
) AS message_data
JOIN users u ON message_data.connected_user_id = u.user_id
LEFT JOIN messages unread_messages
    ON (message_data.connected_user_id = unread_messages.sender_id AND $1 = unread_messages.receiver_id)
        OR (message_data.connected_user_id = unread_messages.receiver_id AND $1 = unread_messages.sender_id)
        AND unread_messages.read = false AND send_id != $1 -- Check if message is not read
GROUP BY connected_user_id, u.first_name, u.image, last_message, last_message_time, send_id, message_id
`

type GetMessageContactParams struct {
	SenderID uuid.UUID `json:"sender_id"`
	MsgID    uuid.UUID `json:"msg_id"`
}

type GetMessageContactRow struct {
	ConnectedUserID            uuid.UUID `json:"connected_user_id"`
	FirstName                  string    `json:"first_name"`
	Image                      string    `json:"image"`
	LastMessage                string    `json:"last_message"`
	LastMessageTime            time.Time `json:"last_message_time"`
	SendID                     uuid.UUID `json:"send_id"`
	MessageID                  uuid.UUID `json:"message_id"`
	UnreadMessageCount         int64     `json:"unread_message_count"`
	UnreadUserRequestCount     int64     `json:"unread_user_request_count"`
	UnreadUserCancelCount      int64     `json:"unread_user_cancel_count"`
	UnreadHostCancelCount      int64     `json:"unread_host_cancel_count"`
	UnreadHostChangeDatesCount int64     `json:"unread_host_change_dates_count"`
}

func (q *Queries) GetMessageContact(ctx context.Context, arg GetMessageContactParams) (GetMessageContactRow, error) {
	row := q.db.QueryRow(ctx, getMessageContact, arg.SenderID, arg.MsgID)
	var i GetMessageContactRow
	err := row.Scan(
		&i.ConnectedUserID,
		&i.FirstName,
		&i.Image,
		&i.LastMessage,
		&i.LastMessageTime,
		&i.SendID,
		&i.MessageID,
		&i.UnreadMessageCount,
		&i.UnreadUserRequestCount,
		&i.UnreadUserCancelCount,
		&i.UnreadHostCancelCount,
		&i.UnreadHostChangeDatesCount,
	)
	return i, err
}

const getMessageContactCount = `-- name: GetMessageContactCount :one
SELECT
    COUNT(*) AS message_count
FROM (
    SELECT DISTINCT
        CASE
            WHEN m.sender_id = $1 THEN m.receiver_id
            WHEN m.receiver_id = $1 THEN m.sender_id
        END AS connected_user_id
    FROM messages m
    WHERE (m.sender_id = $1 OR m.receiver_id = $1)
) AS message_data
GROUP BY connected_user_id
`

func (q *Queries) GetMessageContactCount(ctx context.Context, senderID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getMessageContactCount, senderID)
	var message_count int64
	err := row.Scan(&message_count)
	return message_count, err
}

const getMessageCount = `-- name: GetMessageCount :one
SELECT Count(*)
FROM messages
WHERE (sender_id = $1 AND receiver_id = $2) OR (sender_id = $3 AND receiver_id = $4)
`

type GetMessageCountParams struct {
	SenderID     uuid.UUID `json:"sender_id"`
	ReceiverID   uuid.UUID `json:"receiver_id"`
	SenderID_2   uuid.UUID `json:"sender_id_2"`
	ReceiverID_2 uuid.UUID `json:"receiver_id_2"`
}

func (q *Queries) GetMessageCount(ctx context.Context, arg GetMessageCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getMessageCount,
		arg.SenderID,
		arg.ReceiverID,
		arg.SenderID_2,
		arg.ReceiverID_2,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMessageWithTime = `-- name: GetMessageWithTime :one
SELECT 
    m.id AS message_id,
    m.msg_id,
    m.sender_id,
    m.receiver_id,
    m.message,
    m.type,
    m.read,
    m.main_image,
    m.parent_id,
    m.reference,
    m.created_at,
    m.updated_at,
    p.id AS main_parent_id,
    p.msg_id AS parent_msg_id,
    p.sender_id AS parent_sender_id,
    p.receiver_id AS parent_receiver_id,
    p.message AS parent_message,
    p.type AS parent_type,
    p.read AS parent_read,
    p.main_image AS parent_main_image,
    p.parent_id AS parent_parent_id,
    p.reference AS parent_reference,
    p.created_at AS parent_created_at
FROM messages m
LEFT JOIN messages p ON m.parent_id <> 'none' AND m.parent_id = p.msg_id::VARCHAR
WHERE m.id = $1
`

type GetMessageWithTimeRow struct {
	MessageID        uuid.UUID          `json:"message_id"`
	MsgID            uuid.UUID          `json:"msg_id"`
	SenderID         uuid.UUID          `json:"sender_id"`
	ReceiverID       uuid.UUID          `json:"receiver_id"`
	Message          string             `json:"message"`
	Type             string             `json:"type"`
	Read             bool               `json:"read"`
	MainImage        string             `json:"main_image"`
	ParentID         string             `json:"parent_id"`
	Reference        string             `json:"reference"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	MainParentID     pgtype.UUID        `json:"main_parent_id"`
	ParentMsgID      pgtype.UUID        `json:"parent_msg_id"`
	ParentSenderID   pgtype.UUID        `json:"parent_sender_id"`
	ParentReceiverID pgtype.UUID        `json:"parent_receiver_id"`
	ParentMessage    pgtype.Text        `json:"parent_message"`
	ParentType       pgtype.Text        `json:"parent_type"`
	ParentRead       pgtype.Bool        `json:"parent_read"`
	ParentMainImage  pgtype.Text        `json:"parent_main_image"`
	ParentParentID   pgtype.Text        `json:"parent_parent_id"`
	ParentReference  pgtype.Text        `json:"parent_reference"`
	ParentCreatedAt  pgtype.Timestamptz `json:"parent_created_at"`
}

func (q *Queries) GetMessageWithTime(ctx context.Context, id uuid.UUID) (GetMessageWithTimeRow, error) {
	row := q.db.QueryRow(ctx, getMessageWithTime, id)
	var i GetMessageWithTimeRow
	err := row.Scan(
		&i.MessageID,
		&i.MsgID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Message,
		&i.Type,
		&i.Read,
		&i.MainImage,
		&i.ParentID,
		&i.Reference,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainParentID,
		&i.ParentMsgID,
		&i.ParentSenderID,
		&i.ParentReceiverID,
		&i.ParentMessage,
		&i.ParentType,
		&i.ParentRead,
		&i.ParentMainImage,
		&i.ParentParentID,
		&i.ParentReference,
		&i.ParentCreatedAt,
	)
	return i, err
}

const listMessage = `-- name: ListMessage :many
SELECT 
    m.id AS message_id,
    m.msg_id,
    m.sender_id,
    m.receiver_id,
    m.message,
    m.type,
    m.read,
    m.main_image,
    m.parent_id,
    m.reference,
    m.created_at,
    m.updated_at,
    p.id AS main_parent_id,
    p.msg_id AS parent_msg_id,
    p.sender_id AS parent_sender_id,
    p.receiver_id AS parent_receiver_id,
    p.message AS parent_message,
    p.type AS parent_type,
    p.read AS parent_read,
    p.main_image AS parent_main_image,
    p.parent_id AS parent_parent_id,
    p.reference AS parent_reference,
    p.created_at AS parent_created_at,
    p.updated_at AS parent_updated_at
FROM messages m
LEFT JOIN messages p ON m.parent_id <> 'none' AND m.parent_id = p.msg_id::VARCHAR
WHERE (m.sender_id = $1 AND m.receiver_id = $2) OR (m.sender_id = $3 AND m.receiver_id = $4)
ORDER BY m.created_at DESC
LIMIT $5
OFFSET $6
`

type ListMessageParams struct {
	SenderID     uuid.UUID `json:"sender_id"`
	ReceiverID   uuid.UUID `json:"receiver_id"`
	SenderID_2   uuid.UUID `json:"sender_id_2"`
	ReceiverID_2 uuid.UUID `json:"receiver_id_2"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

type ListMessageRow struct {
	MessageID        uuid.UUID          `json:"message_id"`
	MsgID            uuid.UUID          `json:"msg_id"`
	SenderID         uuid.UUID          `json:"sender_id"`
	ReceiverID       uuid.UUID          `json:"receiver_id"`
	Message          string             `json:"message"`
	Type             string             `json:"type"`
	Read             bool               `json:"read"`
	MainImage        string             `json:"main_image"`
	ParentID         string             `json:"parent_id"`
	Reference        string             `json:"reference"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	MainParentID     pgtype.UUID        `json:"main_parent_id"`
	ParentMsgID      pgtype.UUID        `json:"parent_msg_id"`
	ParentSenderID   pgtype.UUID        `json:"parent_sender_id"`
	ParentReceiverID pgtype.UUID        `json:"parent_receiver_id"`
	ParentMessage    pgtype.Text        `json:"parent_message"`
	ParentType       pgtype.Text        `json:"parent_type"`
	ParentRead       pgtype.Bool        `json:"parent_read"`
	ParentMainImage  pgtype.Text        `json:"parent_main_image"`
	ParentParentID   pgtype.Text        `json:"parent_parent_id"`
	ParentReference  pgtype.Text        `json:"parent_reference"`
	ParentCreatedAt  pgtype.Timestamptz `json:"parent_created_at"`
	ParentUpdatedAt  pgtype.Timestamptz `json:"parent_updated_at"`
}

func (q *Queries) ListMessage(ctx context.Context, arg ListMessageParams) ([]ListMessageRow, error) {
	rows, err := q.db.Query(ctx, listMessage,
		arg.SenderID,
		arg.ReceiverID,
		arg.SenderID_2,
		arg.ReceiverID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageRow{}
	for rows.Next() {
		var i ListMessageRow
		if err := rows.Scan(
			&i.MessageID,
			&i.MsgID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Message,
			&i.Type,
			&i.Read,
			&i.MainImage,
			&i.ParentID,
			&i.Reference,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MainParentID,
			&i.ParentMsgID,
			&i.ParentSenderID,
			&i.ParentReceiverID,
			&i.ParentMessage,
			&i.ParentType,
			&i.ParentRead,
			&i.ParentMainImage,
			&i.ParentParentID,
			&i.ParentReference,
			&i.ParentCreatedAt,
			&i.ParentUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageContact = `-- name: ListMessageContact :many
SELECT
    connected_user_id::uuid,
    u.first_name,
    u.image,
    last_message,
    last_message_time,
    send_id::uuid,
    message_id::uuid,
    COUNT(CASE WHEN unread_messages.read = false AND unread_messages.type != 'user_request' AND unread_messages.sender_id != $1 THEN 1 END) AS unread_message_count,
    COUNT(CASE WHEN unread_messages.type = 'user_request' AND NOW() < (unread_messages.created_at + INTERVAL '2 days') AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_user_request_count,
    COUNT(CASE WHEN unread_messages.type = 'user_cancel' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_user_cancel_count,
    COUNT(CASE WHEN unread_messages.type = 'host_cancel' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_host_cancel_count,
    COUNT(CASE WHEN unread_messages.type = 'host_change_dates' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_host_change_dates_count
FROM (
    SELECT DISTINCT
        CASE
            WHEN m.sender_id = $1 THEN m.receiver_id
            WHEN m.receiver_id = $1 THEN m.sender_id
        END AS connected_user_id,
        m.message AS last_message,
        m.created_at AS last_message_time,
        m.sender_id AS send_id,
        m.msg_id AS message_id
    FROM messages m
    WHERE (m.sender_id = $1 OR m.receiver_id = $1)
    AND m.created_at = (
        SELECT MAX(created_at)
        FROM messages
        WHERE (sender_id = m.sender_id AND receiver_id = m.receiver_id)
            OR (sender_id = m.receiver_id AND receiver_id = m.sender_id)
    )
) AS message_data
JOIN users u ON message_data.connected_user_id = u.user_id
LEFT JOIN messages unread_messages
    ON (message_data.connected_user_id = unread_messages.sender_id AND $1 = unread_messages.receiver_id)
        OR (message_data.connected_user_id = unread_messages.receiver_id AND $1 = unread_messages.sender_id)
        AND unread_messages.read = false AND send_id != $1 -- Check if message is not read
GROUP BY connected_user_id, u.first_name, u.image, last_message, last_message_time, send_id, message_id
ORDER BY last_message_time DESC -- Sort by last message's created_at in descending order
    LIMIT $2
    OFFSET $3
`

type ListMessageContactParams struct {
	SenderID uuid.UUID `json:"sender_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListMessageContactRow struct {
	ConnectedUserID            uuid.UUID `json:"connected_user_id"`
	FirstName                  string    `json:"first_name"`
	Image                      string    `json:"image"`
	LastMessage                string    `json:"last_message"`
	LastMessageTime            time.Time `json:"last_message_time"`
	SendID                     uuid.UUID `json:"send_id"`
	MessageID                  uuid.UUID `json:"message_id"`
	UnreadMessageCount         int64     `json:"unread_message_count"`
	UnreadUserRequestCount     int64     `json:"unread_user_request_count"`
	UnreadUserCancelCount      int64     `json:"unread_user_cancel_count"`
	UnreadHostCancelCount      int64     `json:"unread_host_cancel_count"`
	UnreadHostChangeDatesCount int64     `json:"unread_host_change_dates_count"`
}

func (q *Queries) ListMessageContact(ctx context.Context, arg ListMessageContactParams) ([]ListMessageContactRow, error) {
	rows, err := q.db.Query(ctx, listMessageContact, arg.SenderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageContactRow{}
	for rows.Next() {
		var i ListMessageContactRow
		if err := rows.Scan(
			&i.ConnectedUserID,
			&i.FirstName,
			&i.Image,
			&i.LastMessage,
			&i.LastMessageTime,
			&i.SendID,
			&i.MessageID,
			&i.UnreadMessageCount,
			&i.UnreadUserRequestCount,
			&i.UnreadUserCancelCount,
			&i.UnreadHostCancelCount,
			&i.UnreadHostChangeDatesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageContactByTime = `-- name: ListMessageContactByTime :many
SELECT
    connected_user_id::uuid,
    u.first_name,
    u.image AS host_image,
    last_message,
    last_message_time,
    send_id::uuid,
    message_id::uuid,
    COUNT(CASE WHEN unread_messages.read = false AND unread_messages.type != 'user_request' AND unread_messages.sender_id != $1 THEN 1 END) AS unread_message_count,
    COUNT(CASE WHEN unread_messages.type = 'user_request' AND NOW() < (unread_messages.created_at + INTERVAL '2 days') AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_user_request_count,
    COUNT(CASE WHEN unread_messages.type = 'user_cancel' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_user_cancel_count,
    COUNT(CASE WHEN unread_messages.type = 'host_cancel' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_host_cancel_count,
    COUNT(CASE WHEN unread_messages.type = 'host_change_dates' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_host_change_dates_count
FROM (
    SELECT DISTINCT
        CASE
            WHEN m.sender_id = $1 THEN m.receiver_id
            WHEN m.receiver_id = $1 THEN m.sender_id
        END AS connected_user_id,
        m.message AS last_message,
        m.created_at AS last_message_time,
        m.sender_id AS send_id,
        m.msg_id AS message_id
    FROM messages m
    WHERE (m.sender_id = $1 OR m.receiver_id = $1) AND m.created_at > $2
    AND m.created_at = (
        SELECT MAX(created_at)
        FROM messages
        WHERE (sender_id = m.sender_id AND receiver_id = m.receiver_id)
            OR (sender_id = m.receiver_id AND receiver_id = m.sender_id)
    )
) AS message_data
JOIN users u ON message_data.connected_user_id = u.user_id
LEFT JOIN messages unread_messages
    ON (message_data.connected_user_id = unread_messages.sender_id AND $1 = unread_messages.receiver_id)
        OR (message_data.connected_user_id = unread_messages.receiver_id AND $1 = unread_messages.sender_id)
        AND unread_messages.read = false AND send_id != $1 -- Check if message is not read
GROUP BY connected_user_id, u.first_name, u.image, last_message, last_message_time, send_id, message_id
ORDER BY last_message_time DESC -- Sort by last message's created_at in descending order
    LIMIT $3
    OFFSET $4
`

type ListMessageContactByTimeParams struct {
	SenderID  uuid.UUID `json:"sender_id"`
	CreatedAt time.Time `json:"created_at"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListMessageContactByTimeRow struct {
	ConnectedUserID            uuid.UUID `json:"connected_user_id"`
	FirstName                  string    `json:"first_name"`
	HostImage                  string    `json:"host_image"`
	LastMessage                string    `json:"last_message"`
	LastMessageTime            time.Time `json:"last_message_time"`
	SendID                     uuid.UUID `json:"send_id"`
	MessageID                  uuid.UUID `json:"message_id"`
	UnreadMessageCount         int64     `json:"unread_message_count"`
	UnreadUserRequestCount     int64     `json:"unread_user_request_count"`
	UnreadUserCancelCount      int64     `json:"unread_user_cancel_count"`
	UnreadHostCancelCount      int64     `json:"unread_host_cancel_count"`
	UnreadHostChangeDatesCount int64     `json:"unread_host_change_dates_count"`
}

func (q *Queries) ListMessageContactByTime(ctx context.Context, arg ListMessageContactByTimeParams) ([]ListMessageContactByTimeRow, error) {
	rows, err := q.db.Query(ctx, listMessageContactByTime,
		arg.SenderID,
		arg.CreatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageContactByTimeRow{}
	for rows.Next() {
		var i ListMessageContactByTimeRow
		if err := rows.Scan(
			&i.ConnectedUserID,
			&i.FirstName,
			&i.HostImage,
			&i.LastMessage,
			&i.LastMessageTime,
			&i.SendID,
			&i.MessageID,
			&i.UnreadMessageCount,
			&i.UnreadUserRequestCount,
			&i.UnreadUserCancelCount,
			&i.UnreadHostCancelCount,
			&i.UnreadHostChangeDatesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageContactNoLimit = `-- name: ListMessageContactNoLimit :many
SELECT
    connected_user_id::uuid,
    u.first_name,
    u.image,
    last_message,
    last_message_time,
    send_id::uuid,
    message_id::uuid,
    COUNT(CASE WHEN unread_messages.read = false AND unread_messages.type != 'user_request' AND unread_messages.sender_id != $1 THEN 1 END) AS unread_message_count,
    COUNT(CASE WHEN unread_messages.type = 'user_request' AND NOW() < (unread_messages.created_at + INTERVAL '2 days') AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_user_request_count,
    COUNT(CASE WHEN unread_messages.type = 'user_cancel' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_user_cancel_count,
    COUNT(CASE WHEN unread_messages.type = 'host_cancel' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_host_cancel_count,
    COUNT(CASE WHEN unread_messages.type = 'host_change_dates' AND unread_messages.sender_id != $1 AND unread_messages.read = false THEN 1 END) AS unread_host_change_dates_count
FROM (
    SELECT DISTINCT
        CASE
            WHEN m.sender_id = $1 THEN m.receiver_id
            WHEN m.receiver_id = $1 THEN m.sender_id
        END AS connected_user_id,
        m.message AS last_message,
        m.created_at AS last_message_time,
        m.sender_id AS send_id,
        m.msg_id AS message_id
    FROM messages m
    WHERE (m.sender_id = $1 OR m.receiver_id = $1)
    AND m.created_at = (
        SELECT MAX(created_at)
        FROM messages
        WHERE (sender_id = m.sender_id AND receiver_id = m.receiver_id)
            OR (sender_id = m.receiver_id AND receiver_id = m.sender_id)
    )
) AS message_data
JOIN users u ON message_data.connected_user_id = u.user_id
LEFT JOIN messages unread_messages
    ON (message_data.connected_user_id = unread_messages.sender_id AND $1 = unread_messages.receiver_id)
        OR (message_data.connected_user_id = unread_messages.receiver_id AND $1 = unread_messages.sender_id)
        AND unread_messages.read = false AND send_id != $1 -- Check if message is not read
GROUP BY connected_user_id, u.first_name, u.image, last_message, last_message_time, send_id, message_id
ORDER BY
    COUNT(CASE WHEN unread_messages.type = 'user_request' AND send_id != $1 AND unread_messages.read = false  THEN 1 END),
    COUNT(CASE WHEN unread_messages.type = 'user_cancel' AND send_id != $1 AND unread_messages.read = false THEN 1 END),
    COUNT(CASE WHEN unread_messages.type = 'host_cancel' AND unread_messages.read = false AND send_id != $1 THEN 1 END),
    COUNT(CASE WHEN unread_messages.type = 'host_change_dates' AND unread_messages.read = false AND send_id != $1 THEN 1 END),
    last_message_time DESC -- Sort by last message's created_at in descending order
`

type ListMessageContactNoLimitRow struct {
	ConnectedUserID            uuid.UUID `json:"connected_user_id"`
	FirstName                  string    `json:"first_name"`
	Image                      string    `json:"image"`
	LastMessage                string    `json:"last_message"`
	LastMessageTime            time.Time `json:"last_message_time"`
	SendID                     uuid.UUID `json:"send_id"`
	MessageID                  uuid.UUID `json:"message_id"`
	UnreadMessageCount         int64     `json:"unread_message_count"`
	UnreadUserRequestCount     int64     `json:"unread_user_request_count"`
	UnreadUserCancelCount      int64     `json:"unread_user_cancel_count"`
	UnreadHostCancelCount      int64     `json:"unread_host_cancel_count"`
	UnreadHostChangeDatesCount int64     `json:"unread_host_change_dates_count"`
}

func (q *Queries) ListMessageContactNoLimit(ctx context.Context, senderID uuid.UUID) ([]ListMessageContactNoLimitRow, error) {
	rows, err := q.db.Query(ctx, listMessageContactNoLimit, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageContactNoLimitRow{}
	for rows.Next() {
		var i ListMessageContactNoLimitRow
		if err := rows.Scan(
			&i.ConnectedUserID,
			&i.FirstName,
			&i.Image,
			&i.LastMessage,
			&i.LastMessageTime,
			&i.SendID,
			&i.MessageID,
			&i.UnreadMessageCount,
			&i.UnreadUserRequestCount,
			&i.UnreadUserCancelCount,
			&i.UnreadHostCancelCount,
			&i.UnreadHostChangeDatesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageReceive = `-- name: ListMessageReceive :many
SELECT id, msg_id, sender_id, receiver_id, message, type, read, main_image, parent_id, reference, created_at, updated_at
FROM messages
WHERE receiver_id = $1 AND created_at > $2
`

type ListMessageReceiveParams struct {
	ReceiverID uuid.UUID `json:"receiver_id"`
	CreatedAt  time.Time `json:"created_at"`
}

func (q *Queries) ListMessageReceive(ctx context.Context, arg ListMessageReceiveParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessageReceive, arg.ReceiverID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.MsgID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Message,
			&i.Type,
			&i.Read,
			&i.MainImage,
			&i.ParentID,
			&i.Reference,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageWithTime = `-- name: ListMessageWithTime :many
SELECT 
    m.id AS message_id,
    m.msg_id,
    m.sender_id,
    m.receiver_id,
    m.message,
    m.type,
    m.read,
    m.main_image,
    m.parent_id,
    m.reference,
    m.created_at,
    m.updated_at,
    p.id AS main_parent_id,
    p.msg_id AS parent_msg_id,
    p.sender_id AS parent_sender_id,
    p.receiver_id AS parent_receiver_id,
    p.message AS parent_message,
    p.type AS parent_type,
    p.read AS parent_read,
    p.main_image AS parent_main_image,
    p.parent_id AS parent_parent_id,
    p.reference AS parent_reference,
    p.created_at AS parent_created_at
FROM messages m
LEFT JOIN messages p ON m.parent_id <> 'none' AND m.parent_id = p.msg_id::VARCHAR
WHERE (m.sender_id = $1 AND m.receiver_id = $2) OR (m.sender_id = $3 AND m.receiver_id = $4) AND m.created_at > $5
ORDER BY m.created_at DESC
`

type ListMessageWithTimeParams struct {
	SenderID     uuid.UUID `json:"sender_id"`
	ReceiverID   uuid.UUID `json:"receiver_id"`
	SenderID_2   uuid.UUID `json:"sender_id_2"`
	ReceiverID_2 uuid.UUID `json:"receiver_id_2"`
	CreatedAt    time.Time `json:"created_at"`
}

type ListMessageWithTimeRow struct {
	MessageID        uuid.UUID          `json:"message_id"`
	MsgID            uuid.UUID          `json:"msg_id"`
	SenderID         uuid.UUID          `json:"sender_id"`
	ReceiverID       uuid.UUID          `json:"receiver_id"`
	Message          string             `json:"message"`
	Type             string             `json:"type"`
	Read             bool               `json:"read"`
	MainImage        string             `json:"main_image"`
	ParentID         string             `json:"parent_id"`
	Reference        string             `json:"reference"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	MainParentID     pgtype.UUID        `json:"main_parent_id"`
	ParentMsgID      pgtype.UUID        `json:"parent_msg_id"`
	ParentSenderID   pgtype.UUID        `json:"parent_sender_id"`
	ParentReceiverID pgtype.UUID        `json:"parent_receiver_id"`
	ParentMessage    pgtype.Text        `json:"parent_message"`
	ParentType       pgtype.Text        `json:"parent_type"`
	ParentRead       pgtype.Bool        `json:"parent_read"`
	ParentMainImage  pgtype.Text        `json:"parent_main_image"`
	ParentParentID   pgtype.Text        `json:"parent_parent_id"`
	ParentReference  pgtype.Text        `json:"parent_reference"`
	ParentCreatedAt  pgtype.Timestamptz `json:"parent_created_at"`
}

func (q *Queries) ListMessageWithTime(ctx context.Context, arg ListMessageWithTimeParams) ([]ListMessageWithTimeRow, error) {
	rows, err := q.db.Query(ctx, listMessageWithTime,
		arg.SenderID,
		arg.ReceiverID,
		arg.SenderID_2,
		arg.ReceiverID_2,
		arg.CreatedAt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageWithTimeRow{}
	for rows.Next() {
		var i ListMessageWithTimeRow
		if err := rows.Scan(
			&i.MessageID,
			&i.MsgID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Message,
			&i.Type,
			&i.Read,
			&i.MainImage,
			&i.ParentID,
			&i.Reference,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MainParentID,
			&i.ParentMsgID,
			&i.ParentSenderID,
			&i.ParentReceiverID,
			&i.ParentMessage,
			&i.ParentType,
			&i.ParentRead,
			&i.ParentMainImage,
			&i.ParentParentID,
			&i.ParentReference,
			&i.ParentCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageRead = `-- name: UpdateMessageRead :many
UPDATE messages
SET
    read = $1
WHERE sender_id = $2 AND receiver_id = $3 AND read = false AND type <> 'user_request'
RETURNING id
`

type UpdateMessageReadParams struct {
	Read       bool      `json:"read"`
	SenderID   uuid.UUID `json:"sender_id"`
	ReceiverID uuid.UUID `json:"receiver_id"`
}

func (q *Queries) UpdateMessageRead(ctx context.Context, arg UpdateMessageReadParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, updateMessageRead, arg.Read, arg.SenderID, arg.ReceiverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageReadByID = `-- name: UpdateMessageReadByID :one
UPDATE messages
SET
    read = $1
WHERE sender_id = $2 AND receiver_id = $3 AND msg_id = $4
RETURNING id
`

type UpdateMessageReadByIDParams struct {
	Read       bool      `json:"read"`
	SenderID   uuid.UUID `json:"sender_id"`
	ReceiverID uuid.UUID `json:"receiver_id"`
	MsgID      uuid.UUID `json:"msg_id"`
}

func (q *Queries) UpdateMessageReadByID(ctx context.Context, arg UpdateMessageReadByIDParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateMessageReadByID,
		arg.Read,
		arg.SenderID,
		arg.ReceiverID,
		arg.MsgID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
