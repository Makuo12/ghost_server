// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: charge_date_references.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createChargeDateReference = `-- name: CreateChargeDateReference :one
INSERT INTO charge_date_references (
    charge_event_id,
    event_date_id,
    start_date,
    end_date,
    total_date_service_fee,
    total_date_absorb_fee,
    start_time,
    date_booked,
    end_time,
    total_date_fee
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, charge_event_id, event_date_id, start_date, end_date, date_booked, start_time, end_time, total_date_fee, total_date_service_fee, total_date_absorb_fee, created_at, updated_at
`

type CreateChargeDateReferenceParams struct {
	ChargeEventID       uuid.UUID `json:"charge_event_id"`
	EventDateID         uuid.UUID `json:"event_date_id"`
	StartDate           time.Time `json:"start_date"`
	EndDate             time.Time `json:"end_date"`
	TotalDateServiceFee int64     `json:"total_date_service_fee"`
	TotalDateAbsorbFee  int64     `json:"total_date_absorb_fee"`
	StartTime           string    `json:"start_time"`
	DateBooked          time.Time `json:"date_booked"`
	EndTime             string    `json:"end_time"`
	TotalDateFee        int64     `json:"total_date_fee"`
}

func (q *Queries) CreateChargeDateReference(ctx context.Context, arg CreateChargeDateReferenceParams) (ChargeDateReference, error) {
	row := q.db.QueryRow(ctx, createChargeDateReference,
		arg.ChargeEventID,
		arg.EventDateID,
		arg.StartDate,
		arg.EndDate,
		arg.TotalDateServiceFee,
		arg.TotalDateAbsorbFee,
		arg.StartTime,
		arg.DateBooked,
		arg.EndTime,
		arg.TotalDateFee,
	)
	var i ChargeDateReference
	err := row.Scan(
		&i.ID,
		&i.ChargeEventID,
		&i.EventDateID,
		&i.StartDate,
		&i.EndDate,
		&i.DateBooked,
		&i.StartTime,
		&i.EndTime,
		&i.TotalDateFee,
		&i.TotalDateServiceFee,
		&i.TotalDateAbsorbFee,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listChargeDateReferenceDates = `-- name: ListChargeDateReferenceDates :many
SELECT
    cd.start_date,
    cd.end_date,
    array_agg(cd.id) AS reference_ids,
    count(*) AS item_count
FROM charge_date_references cd
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN charge_ticket_references ct on cd.id = ct.charge_date_id
WHERE event_date_id = $1 AND ce.is_complete = $2 AND ct.cancelled = $3
GROUP BY start_date, end_date
HAVING count(*) > 1
`

type ListChargeDateReferenceDatesParams struct {
	EventDateID uuid.UUID `json:"event_date_id"`
	IsComplete  bool      `json:"is_complete"`
	Cancelled   bool      `json:"cancelled"`
}

type ListChargeDateReferenceDatesRow struct {
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	ReferenceIds interface{} `json:"reference_ids"`
	ItemCount    int64       `json:"item_count"`
}

func (q *Queries) ListChargeDateReferenceDates(ctx context.Context, arg ListChargeDateReferenceDatesParams) ([]ListChargeDateReferenceDatesRow, error) {
	rows, err := q.db.Query(ctx, listChargeDateReferenceDates, arg.EventDateID, arg.IsComplete, arg.Cancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeDateReferenceDatesRow{}
	for rows.Next() {
		var i ListChargeDateReferenceDatesRow
		if err := rows.Scan(
			&i.StartDate,
			&i.EndDate,
			&i.ReferenceIds,
			&i.ItemCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChargeDateReferenceDates = `-- name: UpdateChargeDateReferenceDates :one
UPDATE charge_date_references
SET 
    start_date = $1,
    end_date = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id, charge_event_id, event_date_id, start_date, end_date, date_booked, start_time, end_time, total_date_fee, total_date_service_fee, total_date_absorb_fee, created_at, updated_at
`

type UpdateChargeDateReferenceDatesParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) UpdateChargeDateReferenceDates(ctx context.Context, arg UpdateChargeDateReferenceDatesParams) (ChargeDateReference, error) {
	row := q.db.QueryRow(ctx, updateChargeDateReferenceDates, arg.StartDate, arg.EndDate, arg.ID)
	var i ChargeDateReference
	err := row.Scan(
		&i.ID,
		&i.ChargeEventID,
		&i.EventDateID,
		&i.StartDate,
		&i.EndDate,
		&i.DateBooked,
		&i.StartTime,
		&i.EndTime,
		&i.TotalDateFee,
		&i.TotalDateServiceFee,
		&i.TotalDateAbsorbFee,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
