// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: payouts.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPayout = `-- name: CreatePayout :one
INSERT INTO payouts (
    payout_ids,
    send_medium,
    user_id,
    amount,
    amount_payed,
    parent_type,
    account_number
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, payout_ids, user_id, send_medium, parent_type, amount, amount_payed, account_number, time_paid, transfer_code, is_complete, created_at, updated_at
`

type CreatePayoutParams struct {
	PayoutIds     []uuid.UUID `json:"payout_ids"`
	SendMedium    string      `json:"send_medium"`
	UserID        uuid.UUID   `json:"user_id"`
	Amount        int64       `json:"amount"`
	AmountPayed   int64       `json:"amount_payed"`
	ParentType    string      `json:"parent_type"`
	AccountNumber string      `json:"account_number"`
}

func (q *Queries) CreatePayout(ctx context.Context, arg CreatePayoutParams) (Payout, error) {
	row := q.db.QueryRow(ctx, createPayout,
		arg.PayoutIds,
		arg.SendMedium,
		arg.UserID,
		arg.Amount,
		arg.AmountPayed,
		arg.ParentType,
		arg.AccountNumber,
	)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.PayoutIds,
		&i.UserID,
		&i.SendMedium,
		&i.ParentType,
		&i.Amount,
		&i.AmountPayed,
		&i.AccountNumber,
		&i.TimePaid,
		&i.TransferCode,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPayout = `-- name: ListPayout :many
SELECT id, payout_ids, user_id, send_medium, parent_type, amount, amount_payed, account_number, time_paid, transfer_code, is_complete, created_at, updated_at
FROM payouts
`

func (q *Queries) ListPayout(ctx context.Context) ([]Payout, error) {
	rows, err := q.db.Query(ctx, listPayout)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payout{}
	for rows.Next() {
		var i Payout
		if err := rows.Scan(
			&i.ID,
			&i.PayoutIds,
			&i.UserID,
			&i.SendMedium,
			&i.ParentType,
			&i.Amount,
			&i.AmountPayed,
			&i.AccountNumber,
			&i.TimePaid,
			&i.TransferCode,
			&i.IsComplete,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayout = `-- name: UpdatePayout :one
UPDATE payouts
SET 
    transfer_code = COALESCE($1, transfer_code),
    amount_payed = COALESCE($2, amount_payed),
    is_complete = COALESCE($3, is_complete),
    time_paid = COALESCE($4, time_paid),
    updated_at = NOW()
WHERE id = $5 
RETURNING payout_ids, user_id, parent_type, account_number, time_paid
`

type UpdatePayoutParams struct {
	TransferCode pgtype.Text        `json:"transfer_code"`
	AmountPayed  pgtype.Int8        `json:"amount_payed"`
	IsComplete   pgtype.Bool        `json:"is_complete"`
	TimePaid     pgtype.Timestamptz `json:"time_paid"`
	ID           uuid.UUID          `json:"id"`
}

type UpdatePayoutRow struct {
	PayoutIds     []uuid.UUID `json:"payout_ids"`
	UserID        uuid.UUID   `json:"user_id"`
	ParentType    string      `json:"parent_type"`
	AccountNumber string      `json:"account_number"`
	TimePaid      time.Time   `json:"time_paid"`
}

func (q *Queries) UpdatePayout(ctx context.Context, arg UpdatePayoutParams) (UpdatePayoutRow, error) {
	row := q.db.QueryRow(ctx, updatePayout,
		arg.TransferCode,
		arg.AmountPayed,
		arg.IsComplete,
		arg.TimePaid,
		arg.ID,
	)
	var i UpdatePayoutRow
	err := row.Scan(
		&i.PayoutIds,
		&i.UserID,
		&i.ParentType,
		&i.AccountNumber,
		&i.TimePaid,
	)
	return i, err
}
