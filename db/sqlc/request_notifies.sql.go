// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: request_notifies.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRequestNotifyID = `-- name: CountRequestNotifyID :one
SELECT Count(*)
FROM request_notifies r_n
    JOIN messages m on m.id = r_n.m_id 
    JOIN users u on u.user_id = m.sender_id
    --- We believe that m.receiver_id = $2 is user_id and m.sender_id is contact_id
WHERE NOW() < (r_n.created_at + INTERVAL '2 days') AND (m.sender_id = $1 AND m.receiver_id = $2) AND (m.type = $3 OR m.type = $4) AND r_n.cancelled = $5 AND r_n.approved = $6
`

type CountRequestNotifyIDParams struct {
	SenderID   uuid.UUID `json:"sender_id"`
	ReceiverID uuid.UUID `json:"receiver_id"`
	Type       string    `json:"type"`
	Type_2     string    `json:"type_2"`
	Cancelled  bool      `json:"cancelled"`
	Approved   bool      `json:"approved"`
}

func (q *Queries) CountRequestNotifyID(ctx context.Context, arg CountRequestNotifyIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRequestNotifyID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Type,
		arg.Type_2,
		arg.Cancelled,
		arg.Approved,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRequestNotify = `-- name: CreateRequestNotify :exec
INSERT INTO request_notifies (
    m_id,
    start_date,
    end_date,
    has_price,
    same_price,
    price,
    item_id
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateRequestNotifyParams struct {
	MID       uuid.UUID `json:"m_id"`
	StartDate string    `json:"start_date"`
	EndDate   string    `json:"end_date"`
	HasPrice  bool      `json:"has_price"`
	SamePrice bool      `json:"same_price"`
	Price     int64     `json:"price"`
	ItemID    string    `json:"item_id"`
}

func (q *Queries) CreateRequestNotify(ctx context.Context, arg CreateRequestNotifyParams) error {
	_, err := q.db.Exec(ctx, createRequestNotify,
		arg.MID,
		arg.StartDate,
		arg.EndDate,
		arg.HasPrice,
		arg.SamePrice,
		arg.Price,
		arg.ItemID,
	)
	return err
}

const getRequestNotifyItem = `-- name: GetRequestNotifyItem :one
SELECT o_i.main_option_type, o_i.category, o_i_d.host_name_option
FROM options_infos o_i
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
WHERE o_i.option_user_id = $1
`

type GetRequestNotifyItemRow struct {
	MainOptionType string `json:"main_option_type"`
	Category       string `json:"category"`
	HostNameOption string `json:"host_name_option"`
}

func (q *Queries) GetRequestNotifyItem(ctx context.Context, optionUserID uuid.UUID) (GetRequestNotifyItemRow, error) {
	row := q.db.QueryRow(ctx, getRequestNotifyItem, optionUserID)
	var i GetRequestNotifyItemRow
	err := row.Scan(&i.MainOptionType, &i.Category, &i.HostNameOption)
	return i, err
}

const listRequestNotifyID = `-- name: ListRequestNotifyID :many
SELECT r_n.item_id, r_n.m_id, r_n.start_date, r_n.end_date, m.type, u.first_name, m.reference, m.msg_id
FROM request_notifies r_n
    JOIN messages m on m.id = r_n.m_id 
    JOIN users u on u.user_id = m.sender_id
    --- We believe that m.receiver_id = $2 is user_id and m.sender_id is contact_id
WHERE NOW() < (r_n.created_at + INTERVAL '2 days') AND (m.sender_id = $1 AND m.receiver_id = $2) AND (m.type = $3 OR m.type = $4) AND r_n.cancelled = $5 AND r_n.approved = $6
LIMIT $7
OFFSET $8
`

type ListRequestNotifyIDParams struct {
	SenderID   uuid.UUID `json:"sender_id"`
	ReceiverID uuid.UUID `json:"receiver_id"`
	Type       string    `json:"type"`
	Type_2     string    `json:"type_2"`
	Cancelled  bool      `json:"cancelled"`
	Approved   bool      `json:"approved"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type ListRequestNotifyIDRow struct {
	ItemID    string    `json:"item_id"`
	MID       uuid.UUID `json:"m_id"`
	StartDate string    `json:"start_date"`
	EndDate   string    `json:"end_date"`
	Type      string    `json:"type"`
	FirstName string    `json:"first_name"`
	Reference string    `json:"reference"`
	MsgID     uuid.UUID `json:"msg_id"`
}

func (q *Queries) ListRequestNotifyID(ctx context.Context, arg ListRequestNotifyIDParams) ([]ListRequestNotifyIDRow, error) {
	rows, err := q.db.Query(ctx, listRequestNotifyID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Type,
		arg.Type_2,
		arg.Cancelled,
		arg.Approved,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRequestNotifyIDRow{}
	for rows.Next() {
		var i ListRequestNotifyIDRow
		if err := rows.Scan(
			&i.ItemID,
			&i.MID,
			&i.StartDate,
			&i.EndDate,
			&i.Type,
			&i.FirstName,
			&i.Reference,
			&i.MsgID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestNotifyPayment = `-- name: ListRequestNotifyPayment :many
SELECT cor.id AS charge_id, rn.m_id, u.first_name AS guest_first_name, u.user_id AS guest_user_id, hu.first_name AS host_first_name, hu.user_id AS host_user_id, cor.reference 
FROM request_notifies rn
JOIN messages m on m.id = rn.m_id
JOIN charge_option_references cor on cor.reference = m.reference
JOIN users u on u.user_id = cor.user_id
JOIN options_infos oi on oi.option_user_id = cor.option_user_id
JOIN users hu on hu.id = oi.host_id
WHERE rn.status = 'request_payment'
`

type ListRequestNotifyPaymentRow struct {
	ChargeID       uuid.UUID `json:"charge_id"`
	MID            uuid.UUID `json:"m_id"`
	GuestFirstName string    `json:"guest_first_name"`
	GuestUserID    uuid.UUID `json:"guest_user_id"`
	HostFirstName  string    `json:"host_first_name"`
	HostUserID     uuid.UUID `json:"host_user_id"`
	Reference      string    `json:"reference"`
}

func (q *Queries) ListRequestNotifyPayment(ctx context.Context) ([]ListRequestNotifyPaymentRow, error) {
	rows, err := q.db.Query(ctx, listRequestNotifyPayment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRequestNotifyPaymentRow{}
	for rows.Next() {
		var i ListRequestNotifyPaymentRow
		if err := rows.Scan(
			&i.ChargeID,
			&i.MID,
			&i.GuestFirstName,
			&i.GuestUserID,
			&i.HostFirstName,
			&i.HostUserID,
			&i.Reference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequestNotify = `-- name: UpdateRequestNotify :one
UPDATE request_notifies
SET 
    start_date = COALESCE($1, start_date),
    end_date = COALESCE($2, end_date),
    has_price = COALESCE($3, has_price),
    same_price = COALESCE($4, same_price),
    item_id = COALESCE($5, item_id),
    approved = COALESCE($6, approved),
    cancelled = COALESCE($7, cancelled),
    status = COALESCE($8, status),
    updated_at = NOW()
WHERE m_id = $9 
RETURNING m_id, start_date, end_date, has_price, same_price, price, item_id, status, approved, cancelled, created_at, updated_at
`

type UpdateRequestNotifyParams struct {
	StartDate pgtype.Text `json:"start_date"`
	EndDate   pgtype.Text `json:"end_date"`
	HasPrice  pgtype.Bool `json:"has_price"`
	SamePrice pgtype.Bool `json:"same_price"`
	ItemID    pgtype.Text `json:"item_id"`
	Approved  pgtype.Bool `json:"approved"`
	Cancelled pgtype.Bool `json:"cancelled"`
	Status    pgtype.Text `json:"status"`
	MID       uuid.UUID   `json:"m_id"`
}

func (q *Queries) UpdateRequestNotify(ctx context.Context, arg UpdateRequestNotifyParams) (RequestNotify, error) {
	row := q.db.QueryRow(ctx, updateRequestNotify,
		arg.StartDate,
		arg.EndDate,
		arg.HasPrice,
		arg.SamePrice,
		arg.ItemID,
		arg.Approved,
		arg.Cancelled,
		arg.Status,
		arg.MID,
	)
	var i RequestNotify
	err := row.Scan(
		&i.MID,
		&i.StartDate,
		&i.EndDate,
		&i.HasPrice,
		&i.SamePrice,
		&i.Price,
		&i.ItemID,
		&i.Status,
		&i.Approved,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
