// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: options_info_photos.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createOptionInfoPhoto = `-- name: CreateOptionInfoPhoto :one
INSERT INTO options_info_photos (
    option_id,
    cover_image,
    photo,
    public_cover_image,
    public_photo
)
VALUES ($1, $2, $3, $4, $5)
RETURNING option_id, cover_image, has_meta_data, public_cover_image, public_photo, photo, created_at, updated_at
`

type CreateOptionInfoPhotoParams struct {
	OptionID         uuid.UUID `json:"option_id"`
	CoverImage       string    `json:"cover_image"`
	Photo            []string  `json:"photo"`
	PublicCoverImage string    `json:"public_cover_image"`
	PublicPhoto      []string  `json:"public_photo"`
}

func (q *Queries) CreateOptionInfoPhoto(ctx context.Context, arg CreateOptionInfoPhotoParams) (OptionsInfoPhoto, error) {
	row := q.db.QueryRow(ctx, createOptionInfoPhoto,
		arg.OptionID,
		arg.CoverImage,
		arg.Photo,
		arg.PublicCoverImage,
		arg.PublicPhoto,
	)
	var i OptionsInfoPhoto
	err := row.Scan(
		&i.OptionID,
		&i.CoverImage,
		&i.HasMetaData,
		&i.PublicCoverImage,
		&i.PublicPhoto,
		&i.Photo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionInfoPhoto = `-- name: GetOptionInfoPhoto :one
SELECT option_id, cover_image, has_meta_data, public_cover_image, public_photo, photo, created_at, updated_at 
FROM options_info_photos
WHERE option_id = $1
`

func (q *Queries) GetOptionInfoPhoto(ctx context.Context, optionID uuid.UUID) (OptionsInfoPhoto, error) {
	row := q.db.QueryRow(ctx, getOptionInfoPhoto, optionID)
	var i OptionsInfoPhoto
	err := row.Scan(
		&i.OptionID,
		&i.CoverImage,
		&i.HasMetaData,
		&i.PublicCoverImage,
		&i.PublicPhoto,
		&i.Photo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionInfoPhotoCoverOnly = `-- name: GetOptionInfoPhotoCoverOnly :one
SELECT cover_image 
FROM options_info_photos
WHERE option_id = $1
`

func (q *Queries) GetOptionInfoPhotoCoverOnly(ctx context.Context, optionID uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getOptionInfoPhotoCoverOnly, optionID)
	var cover_image string
	err := row.Scan(&cover_image)
	return cover_image, err
}

const getOptionInfoPhotoOnly = `-- name: GetOptionInfoPhotoOnly :one
SELECT photo 
FROM options_info_photos
WHERE option_id = $1
`

func (q *Queries) GetOptionInfoPhotoOnly(ctx context.Context, optionID uuid.UUID) ([]string, error) {
	row := q.db.QueryRow(ctx, getOptionInfoPhotoOnly, optionID)
	var photo []string
	err := row.Scan(&photo)
	return photo, err
}

const listAllPhoto = `-- name: ListAllPhoto :many
SELECT option_id, cover_image, has_meta_data, public_cover_image, public_photo, photo, created_at, updated_at
FROM options_info_photos
`

func (q *Queries) ListAllPhoto(ctx context.Context) ([]OptionsInfoPhoto, error) {
	rows, err := q.db.Query(ctx, listAllPhoto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OptionsInfoPhoto{}
	for rows.Next() {
		var i OptionsInfoPhoto
		if err := rows.Scan(
			&i.OptionID,
			&i.CoverImage,
			&i.HasMetaData,
			&i.PublicCoverImage,
			&i.PublicPhoto,
			&i.Photo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllUserPhoto = `-- name: ListAllUserPhoto :many
SELECT id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, oi.created_at, completed, oi.updated_at, option_id, cover_image, has_meta_data, public_cover_image, public_photo, photo, oip.created_at, oip.updated_at
FROM options_infos oi
JOIN options_info_photos oip on oip.option_id = oi.id
WHERE oi.host_id = $1
`

type ListAllUserPhotoRow struct {
	ID               uuid.UUID `json:"id"`
	CoHostID         uuid.UUID `json:"co_host_id"`
	OptionUserID     uuid.UUID `json:"option_user_id"`
	HostID           uuid.UUID `json:"host_id"`
	DeepLinkID       uuid.UUID `json:"deep_link_id"`
	PrimaryUserID    uuid.UUID `json:"primary_user_id"`
	IsActive         bool      `json:"is_active"`
	IsComplete       bool      `json:"is_complete"`
	IsVerified       bool      `json:"is_verified"`
	Category         string    `json:"category"`
	CategoryTwo      string    `json:"category_two"`
	CategoryThree    string    `json:"category_three"`
	CategoryFour     string    `json:"category_four"`
	IsTopSeller      bool      `json:"is_top_seller"`
	TimeZone         string    `json:"time_zone"`
	Currency         string    `json:"currency"`
	OptionImg        string    `json:"option_img"`
	OptionType       string    `json:"option_type"`
	MainOptionType   string    `json:"main_option_type"`
	CreatedAt        time.Time `json:"created_at"`
	Completed        time.Time `json:"completed"`
	UpdatedAt        time.Time `json:"updated_at"`
	OptionID         uuid.UUID `json:"option_id"`
	CoverImage       string    `json:"cover_image"`
	HasMetaData      bool      `json:"has_meta_data"`
	PublicCoverImage string    `json:"public_cover_image"`
	PublicPhoto      []string  `json:"public_photo"`
	Photo            []string  `json:"photo"`
	CreatedAt_2      time.Time `json:"created_at_2"`
	UpdatedAt_2      time.Time `json:"updated_at_2"`
}

func (q *Queries) ListAllUserPhoto(ctx context.Context, hostID uuid.UUID) ([]ListAllUserPhotoRow, error) {
	rows, err := q.db.Query(ctx, listAllUserPhoto, hostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllUserPhotoRow{}
	for rows.Next() {
		var i ListAllUserPhotoRow
		if err := rows.Scan(
			&i.ID,
			&i.CoHostID,
			&i.OptionUserID,
			&i.HostID,
			&i.DeepLinkID,
			&i.PrimaryUserID,
			&i.IsActive,
			&i.IsComplete,
			&i.IsVerified,
			&i.Category,
			&i.CategoryTwo,
			&i.CategoryThree,
			&i.CategoryFour,
			&i.IsTopSeller,
			&i.TimeZone,
			&i.Currency,
			&i.OptionImg,
			&i.OptionType,
			&i.MainOptionType,
			&i.CreatedAt,
			&i.Completed,
			&i.UpdatedAt,
			&i.OptionID,
			&i.CoverImage,
			&i.HasMetaData,
			&i.PublicCoverImage,
			&i.PublicPhoto,
			&i.Photo,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionPhotoByAdmin = `-- name: ListOptionPhotoByAdmin :many
SELECT option_id, cover_image, has_meta_data, public_cover_image, public_photo, photo, created_at, updated_at
FROM options_info_photos
`

func (q *Queries) ListOptionPhotoByAdmin(ctx context.Context) ([]OptionsInfoPhoto, error) {
	rows, err := q.db.Query(ctx, listOptionPhotoByAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OptionsInfoPhoto{}
	for rows.Next() {
		var i OptionsInfoPhoto
		if err := rows.Scan(
			&i.OptionID,
			&i.CoverImage,
			&i.HasMetaData,
			&i.PublicCoverImage,
			&i.PublicPhoto,
			&i.Photo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOptionInfoPhoto = `-- name: RemoveOptionInfoPhoto :exec
DELETE FROM options_info_photos
WHERE option_id = $1
`

func (q *Queries) RemoveOptionInfoPhoto(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeOptionInfoPhoto, optionID)
	return err
}

const updateOptionInfoAllPhotoCover = `-- name: UpdateOptionInfoAllPhotoCover :one
UPDATE options_info_photos
SET 
    public_cover_image = $1,
    cover_image = $2,
    updated_at = NOW()
WHERE option_id = $3
RETURNING cover_image, photo
`

type UpdateOptionInfoAllPhotoCoverParams struct {
	PublicCoverImage string    `json:"public_cover_image"`
	CoverImage       string    `json:"cover_image"`
	OptionID         uuid.UUID `json:"option_id"`
}

type UpdateOptionInfoAllPhotoCoverRow struct {
	CoverImage string   `json:"cover_image"`
	Photo      []string `json:"photo"`
}

func (q *Queries) UpdateOptionInfoAllPhotoCover(ctx context.Context, arg UpdateOptionInfoAllPhotoCoverParams) (UpdateOptionInfoAllPhotoCoverRow, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoAllPhotoCover, arg.PublicCoverImage, arg.CoverImage, arg.OptionID)
	var i UpdateOptionInfoAllPhotoCoverRow
	err := row.Scan(&i.CoverImage, &i.Photo)
	return i, err
}

const updateOptionInfoAllPhotoOnly = `-- name: UpdateOptionInfoAllPhotoOnly :one
UPDATE options_info_photos
SET
    public_photo = $1,
    photo = $2,
    updated_at = NOW()
WHERE option_id = $3
RETURNING cover_image, photo
`

type UpdateOptionInfoAllPhotoOnlyParams struct {
	PublicPhoto []string  `json:"public_photo"`
	Photo       []string  `json:"photo"`
	OptionID    uuid.UUID `json:"option_id"`
}

type UpdateOptionInfoAllPhotoOnlyRow struct {
	CoverImage string   `json:"cover_image"`
	Photo      []string `json:"photo"`
}

func (q *Queries) UpdateOptionInfoAllPhotoOnly(ctx context.Context, arg UpdateOptionInfoAllPhotoOnlyParams) (UpdateOptionInfoAllPhotoOnlyRow, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoAllPhotoOnly, arg.PublicPhoto, arg.Photo, arg.OptionID)
	var i UpdateOptionInfoAllPhotoOnlyRow
	err := row.Scan(&i.CoverImage, &i.Photo)
	return i, err
}

const updateOptionInfoPhoto = `-- name: UpdateOptionInfoPhoto :one
UPDATE options_info_photos
SET 
    cover_image = $1,
    photo = $2,
    updated_at = NOW()
WHERE option_id = $3
RETURNING cover_image, photo
`

type UpdateOptionInfoPhotoParams struct {
	CoverImage string    `json:"cover_image"`
	Photo      []string  `json:"photo"`
	OptionID   uuid.UUID `json:"option_id"`
}

type UpdateOptionInfoPhotoRow struct {
	CoverImage string   `json:"cover_image"`
	Photo      []string `json:"photo"`
}

func (q *Queries) UpdateOptionInfoPhoto(ctx context.Context, arg UpdateOptionInfoPhotoParams) (UpdateOptionInfoPhotoRow, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoPhoto, arg.CoverImage, arg.Photo, arg.OptionID)
	var i UpdateOptionInfoPhotoRow
	err := row.Scan(&i.CoverImage, &i.Photo)
	return i, err
}

const updateOptionInfoPhotoCover = `-- name: UpdateOptionInfoPhotoCover :one
UPDATE options_info_photos
SET 
    cover_image = $1,
    updated_at = NOW()
WHERE option_id = $2 
RETURNING cover_image, photo
`

type UpdateOptionInfoPhotoCoverParams struct {
	CoverImage string    `json:"cover_image"`
	OptionID   uuid.UUID `json:"option_id"`
}

type UpdateOptionInfoPhotoCoverRow struct {
	CoverImage string   `json:"cover_image"`
	Photo      []string `json:"photo"`
}

func (q *Queries) UpdateOptionInfoPhotoCover(ctx context.Context, arg UpdateOptionInfoPhotoCoverParams) (UpdateOptionInfoPhotoCoverRow, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoPhotoCover, arg.CoverImage, arg.OptionID)
	var i UpdateOptionInfoPhotoCoverRow
	err := row.Scan(&i.CoverImage, &i.Photo)
	return i, err
}

const updateOptionInfoPhotoCoverUrl = `-- name: UpdateOptionInfoPhotoCoverUrl :one
UPDATE options_info_photos
SET 
    public_cover_image = $1,
    updated_at = NOW()
WHERE option_id = $2 
RETURNING cover_image, photo
`

type UpdateOptionInfoPhotoCoverUrlParams struct {
	PublicCoverImage string    `json:"public_cover_image"`
	OptionID         uuid.UUID `json:"option_id"`
}

type UpdateOptionInfoPhotoCoverUrlRow struct {
	CoverImage string   `json:"cover_image"`
	Photo      []string `json:"photo"`
}

func (q *Queries) UpdateOptionInfoPhotoCoverUrl(ctx context.Context, arg UpdateOptionInfoPhotoCoverUrlParams) (UpdateOptionInfoPhotoCoverUrlRow, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoPhotoCoverUrl, arg.PublicCoverImage, arg.OptionID)
	var i UpdateOptionInfoPhotoCoverUrlRow
	err := row.Scan(&i.CoverImage, &i.Photo)
	return i, err
}

const updateOptionInfoPhotoOnly = `-- name: UpdateOptionInfoPhotoOnly :one
UPDATE options_info_photos
SET
    photo = $1,
    updated_at = NOW()
WHERE option_id = $2
RETURNING cover_image, photo
`

type UpdateOptionInfoPhotoOnlyParams struct {
	Photo    []string  `json:"photo"`
	OptionID uuid.UUID `json:"option_id"`
}

type UpdateOptionInfoPhotoOnlyRow struct {
	CoverImage string   `json:"cover_image"`
	Photo      []string `json:"photo"`
}

func (q *Queries) UpdateOptionInfoPhotoOnly(ctx context.Context, arg UpdateOptionInfoPhotoOnlyParams) (UpdateOptionInfoPhotoOnlyRow, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoPhotoOnly, arg.Photo, arg.OptionID)
	var i UpdateOptionInfoPhotoOnlyRow
	err := row.Scan(&i.CoverImage, &i.Photo)
	return i, err
}

const updateOptionInfoPhotoOnlyUrl = `-- name: UpdateOptionInfoPhotoOnlyUrl :one
UPDATE options_info_photos
SET
    public_photo = $1,
    updated_at = NOW()
WHERE option_id = $2
RETURNING cover_image, photo
`

type UpdateOptionInfoPhotoOnlyUrlParams struct {
	PublicPhoto []string  `json:"public_photo"`
	OptionID    uuid.UUID `json:"option_id"`
}

type UpdateOptionInfoPhotoOnlyUrlRow struct {
	CoverImage string   `json:"cover_image"`
	Photo      []string `json:"photo"`
}

func (q *Queries) UpdateOptionInfoPhotoOnlyUrl(ctx context.Context, arg UpdateOptionInfoPhotoOnlyUrlParams) (UpdateOptionInfoPhotoOnlyUrlRow, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoPhotoOnlyUrl, arg.PublicPhoto, arg.OptionID)
	var i UpdateOptionInfoPhotoOnlyUrlRow
	err := row.Scan(&i.CoverImage, &i.Photo)
	return i, err
}
