// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: charge_option_references.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countChargeOptionReferenceBook = `-- name: CountChargeOptionReferenceBook :one
SELECT Count(*)
FROM charge_option_references co
    JOIN users u on u.user_id = co.user_id
WHERE co.option_user_id = $1 AND co.is_complete=$2 AND co.cancelled=$3
`

type CountChargeOptionReferenceBookParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	IsComplete   bool      `json:"is_complete"`
	Cancelled    bool      `json:"cancelled"`
}

func (q *Queries) CountChargeOptionReferenceBook(ctx context.Context, arg CountChargeOptionReferenceBookParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeOptionReferenceBook, arg.OptionUserID, arg.IsComplete, arg.Cancelled)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChargeOptionReferenceCurrent = `-- name: CountChargeOptionReferenceCurrent :one
SELECT Count(*)
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN options_info_photos o_p_p on oi.id = o_p_p.option_id
    JOIN check_in_out_details cid on oi.id = cid.option_id
    JOIN users u on u.id = oi.host_id
    JOIN shortlets s on oi.id = s.option_id
    JOIN locations l on l.option_id = oi.id
    LEFT JOIN charge_reviews cr on cr.charge_id = co.id
WHERE co.user_id = $1 AND co.cancelled = $2 AND co.is_complete = $3 AND (NOW() <= co.end_date + INTERVAL '13 days' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id AND cr.is_published = false) OR NOW() <= co.end_date + INTERVAL '13 days' AND NOT EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id))
`

type CountChargeOptionReferenceCurrentParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) CountChargeOptionReferenceCurrent(ctx context.Context, arg CountChargeOptionReferenceCurrentParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeOptionReferenceCurrent, arg.UserID, arg.Cancelled, arg.IsComplete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChargeOptionReferenceVisited = `-- name: CountChargeOptionReferenceVisited :one
SELECT Count(*)
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN options_info_photos o_p_p on oi.id = o_p_p.option_id
    JOIN check_in_out_details cid on oi.id = cid.option_id
    JOIN users u on u.id = oi.host_id
    JOIN shortlets s on oi.id = s.option_id
    JOIN locations l on l.option_id = oi.id
    LEFT JOIN charge_reviews cr on cr.charge_id = co.id
WHERE co.user_id = $1 AND co.cancelled = $2 AND co.is_complete = $3 AND (NOW() > co.end_date + INTERVAL '8 hours' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id AND cr.is_published = TRUE) OR NOW() > co.end_date + INTERVAL '13 days')
`

type CountChargeOptionReferenceVisitedParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) CountChargeOptionReferenceVisited(ctx context.Context, arg CountChargeOptionReferenceVisitedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeOptionReferenceVisited, arg.UserID, arg.Cancelled, arg.IsComplete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOptionPaymentByUserID = `-- name: CountOptionPaymentByUserID :one
SELECT COUNT(*) 
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN users u on u.id = oi.host_id
WHERE co.user_id = $1 AND co.is_complete=$2
`

type CountOptionPaymentByUserIDParams struct {
	UserID     uuid.UUID `json:"user_id"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) CountOptionPaymentByUserID(ctx context.Context, arg CountOptionPaymentByUserIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOptionPaymentByUserID, arg.UserID, arg.IsComplete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChargeOptionReference = `-- name: CreateChargeOptionReference :one
INSERT INTO charge_option_references (
    user_id,
    option_user_id,
    discount,
    main_price,
    service_fee,
    total_fee,
    date_price,
    currency,
    start_date,
    guests,
    end_date,
    guest_fee,
    pet_fee,
    clean_fee,
    nightly_pet_fee,
    nightly_guest_fee,
    can_instant_book,
    require_request,
    request_type,
    date_booked,
    reference,
    payment_reference,
    request_approved,
    is_complete
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24)
RETURNING id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
`

type CreateChargeOptionReferenceParams struct {
	UserID           uuid.UUID `json:"user_id"`
	OptionUserID     uuid.UUID `json:"option_user_id"`
	Discount         string    `json:"discount"`
	MainPrice        int64     `json:"main_price"`
	ServiceFee       int64     `json:"service_fee"`
	TotalFee         int64     `json:"total_fee"`
	DatePrice        []string  `json:"date_price"`
	Currency         string    `json:"currency"`
	StartDate        time.Time `json:"start_date"`
	Guests           []string  `json:"guests"`
	EndDate          time.Time `json:"end_date"`
	GuestFee         int64     `json:"guest_fee"`
	PetFee           int64     `json:"pet_fee"`
	CleanFee         int64     `json:"clean_fee"`
	NightlyPetFee    int64     `json:"nightly_pet_fee"`
	NightlyGuestFee  int64     `json:"nightly_guest_fee"`
	CanInstantBook   bool      `json:"can_instant_book"`
	RequireRequest   bool      `json:"require_request"`
	RequestType      string    `json:"request_type"`
	DateBooked       time.Time `json:"date_booked"`
	Reference        string    `json:"reference"`
	PaymentReference string    `json:"payment_reference"`
	RequestApproved  bool      `json:"request_approved"`
	IsComplete       bool      `json:"is_complete"`
}

func (q *Queries) CreateChargeOptionReference(ctx context.Context, arg CreateChargeOptionReferenceParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, createChargeOptionReference,
		arg.UserID,
		arg.OptionUserID,
		arg.Discount,
		arg.MainPrice,
		arg.ServiceFee,
		arg.TotalFee,
		arg.DatePrice,
		arg.Currency,
		arg.StartDate,
		arg.Guests,
		arg.EndDate,
		arg.GuestFee,
		arg.PetFee,
		arg.CleanFee,
		arg.NightlyPetFee,
		arg.NightlyGuestFee,
		arg.CanInstantBook,
		arg.RequireRequest,
		arg.RequestType,
		arg.DateBooked,
		arg.Reference,
		arg.PaymentReference,
		arg.RequestApproved,
		arg.IsComplete,
	)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargeOptionReference = `-- name: GetChargeOptionReference :one
SELECT id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
FROM charge_option_references
WHERE id = $1 AND user_id = $2 AND is_complete = $3 AND cancelled = $4 AND request_approved = $5
`

type GetChargeOptionReferenceParams struct {
	ID               uuid.UUID `json:"id"`
	UserID           uuid.UUID `json:"user_id"`
	PaymentCompleted bool      `json:"payment_completed"`
	ChargeCancelled  bool      `json:"charge_cancelled"`
	RequestApproved  bool      `json:"request_approved"`
}

func (q *Queries) GetChargeOptionReference(ctx context.Context, arg GetChargeOptionReferenceParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReference,
		arg.ID,
		arg.UserID,
		arg.PaymentCompleted,
		arg.ChargeCancelled,
		arg.RequestApproved,
	)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargeOptionReferenceByHostID = `-- name: GetChargeOptionReferenceByHostID :one
SELECT m_p.is_complete AS main_payout_complete, co.start_date, co.date_booked, o_r_i.cancel_policy_one, co.id AS charge_id, u.first_name AS user_first_name, us.first_name AS host_first_name, us.user_id AS host_user_id, od.host_name_option, m_p.type AS charge_type, co.end_date
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN main_payouts m_p on m_p.charge_id = co.id
    JOIN option_reference_infos o_r_i on o_r_i.option_charge_id = co.id
    JOIN users u on u.user_id = co.user_id
    JOIN users us on us.id = oi.host_id
WHERE co.user_id = $1 AND co.cancelled = $2 AND co.is_complete=$3 AND co.id = $4 AND us.user_id = $5
`

type GetChargeOptionReferenceByHostIDParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
	ID         uuid.UUID `json:"id"`
	HostUserID uuid.UUID `json:"host_user_id"`
}

type GetChargeOptionReferenceByHostIDRow struct {
	MainPayoutComplete bool      `json:"main_payout_complete"`
	StartDate          time.Time `json:"start_date"`
	DateBooked         time.Time `json:"date_booked"`
	CancelPolicyOne    string    `json:"cancel_policy_one"`
	ChargeID           uuid.UUID `json:"charge_id"`
	UserFirstName      string    `json:"user_first_name"`
	HostFirstName      string    `json:"host_first_name"`
	HostUserID         uuid.UUID `json:"host_user_id"`
	HostNameOption     string    `json:"host_name_option"`
	ChargeType         string    `json:"charge_type"`
	EndDate            time.Time `json:"end_date"`
}

func (q *Queries) GetChargeOptionReferenceByHostID(ctx context.Context, arg GetChargeOptionReferenceByHostIDParams) (GetChargeOptionReferenceByHostIDRow, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceByHostID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
		arg.ID,
		arg.HostUserID,
	)
	var i GetChargeOptionReferenceByHostIDRow
	err := row.Scan(
		&i.MainPayoutComplete,
		&i.StartDate,
		&i.DateBooked,
		&i.CancelPolicyOne,
		&i.ChargeID,
		&i.UserFirstName,
		&i.HostFirstName,
		&i.HostUserID,
		&i.HostNameOption,
		&i.ChargeType,
		&i.EndDate,
	)
	return i, err
}

const getChargeOptionReferenceByID = `-- name: GetChargeOptionReferenceByID :one
SELECT id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
FROM charge_option_references
WHERE id = $1 AND user_id = $2
`

type GetChargeOptionReferenceByIDParams struct {
	ChargeID uuid.UUID `json:"charge_id"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) GetChargeOptionReferenceByID(ctx context.Context, arg GetChargeOptionReferenceByIDParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceByID, arg.ChargeID, arg.UserID)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargeOptionReferenceByMsg = `-- name: GetChargeOptionReferenceByMsg :one
SELECT od.host_name_option, oi_p.cover_image, u_s.first_name, co.guests, co.start_date, co.end_date, co.total_fee, co.service_fee, u_s.email, u_s.phone_number, u_s.photo, i_d.is_verified, co.currency
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN options_info_photos oi_p on oi.id = oi_p.option_id
    JOIN users u on u.id = oi.host_id
    JOIN users u_s on u_s.user_id = co.user_id
    JOIN identity i_d on u_s.id = i_d.user_id
WHERE co.reference = $1 AND co.user_id = $2 AND u.user_id = $3
`

type GetChargeOptionReferenceByMsgParams struct {
	Reference  string    `json:"reference"`
	SenderID   uuid.UUID `json:"sender_id"`
	ReceiverID uuid.UUID `json:"receiver_id"`
}

type GetChargeOptionReferenceByMsgRow struct {
	HostNameOption string    `json:"host_name_option"`
	CoverImage     string    `json:"cover_image"`
	FirstName      string    `json:"first_name"`
	Guests         []string  `json:"guests"`
	StartDate      time.Time `json:"start_date"`
	EndDate        time.Time `json:"end_date"`
	TotalFee       int64     `json:"total_fee"`
	ServiceFee     int64     `json:"service_fee"`
	Email          string    `json:"email"`
	PhoneNumber    string    `json:"phone_number"`
	Photo          string    `json:"photo"`
	IsVerified     bool      `json:"is_verified"`
	Currency       string    `json:"currency"`
}

// - GetChargeOptionReferenceByMsg this is using the message table reference and senderID is the contactID
func (q *Queries) GetChargeOptionReferenceByMsg(ctx context.Context, arg GetChargeOptionReferenceByMsgParams) (GetChargeOptionReferenceByMsgRow, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceByMsg, arg.Reference, arg.SenderID, arg.ReceiverID)
	var i GetChargeOptionReferenceByMsgRow
	err := row.Scan(
		&i.HostNameOption,
		&i.CoverImage,
		&i.FirstName,
		&i.Guests,
		&i.StartDate,
		&i.EndDate,
		&i.TotalFee,
		&i.ServiceFee,
		&i.Email,
		&i.PhoneNumber,
		&i.Photo,
		&i.IsVerified,
		&i.Currency,
	)
	return i, err
}

const getChargeOptionReferenceByRef = `-- name: GetChargeOptionReferenceByRef :one
SELECT id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
FROM charge_option_references
WHERE reference = $1 AND user_id = $2
`

type GetChargeOptionReferenceByRefParams struct {
	Reference string    `json:"reference"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) GetChargeOptionReferenceByRef(ctx context.Context, arg GetChargeOptionReferenceByRefParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceByRef, arg.Reference, arg.UserID)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargeOptionReferenceByUserID = `-- name: GetChargeOptionReferenceByUserID :one
SELECT m_p.is_complete AS main_payout_complete, co.start_date, co.date_booked, o_r_i.cancel_policy_one, co.id AS charge_id, u.first_name AS user_first_name, us.first_name AS host_first_name, us.user_id AS host_user_id, od.host_name_option, m_p.type AS charge_type, co.end_date, oi.time_zone, co.clean_fee, co.pet_fee, co.guest_fee, co.main_price, co.total_fee, co.service_fee, co.currency
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN main_payouts m_p on m_p.charge_id = co.id
    JOIN option_reference_infos o_r_i on o_r_i.option_charge_id = co.id
    JOIN users u on u.user_id = co.user_id
    JOIN users us on us.id = oi.host_id
WHERE co.user_id = $1 AND co.cancelled = $2 AND co.is_complete=$3 AND co.id = $4
`

type GetChargeOptionReferenceByUserIDParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
	ID         uuid.UUID `json:"id"`
}

type GetChargeOptionReferenceByUserIDRow struct {
	MainPayoutComplete bool      `json:"main_payout_complete"`
	StartDate          time.Time `json:"start_date"`
	DateBooked         time.Time `json:"date_booked"`
	CancelPolicyOne    string    `json:"cancel_policy_one"`
	ChargeID           uuid.UUID `json:"charge_id"`
	UserFirstName      string    `json:"user_first_name"`
	HostFirstName      string    `json:"host_first_name"`
	HostUserID         uuid.UUID `json:"host_user_id"`
	HostNameOption     string    `json:"host_name_option"`
	ChargeType         string    `json:"charge_type"`
	EndDate            time.Time `json:"end_date"`
	TimeZone           string    `json:"time_zone"`
	CleanFee           int64     `json:"clean_fee"`
	PetFee             int64     `json:"pet_fee"`
	GuestFee           int64     `json:"guest_fee"`
	MainPrice          int64     `json:"main_price"`
	TotalFee           int64     `json:"total_fee"`
	ServiceFee         int64     `json:"service_fee"`
	Currency           string    `json:"currency"`
}

func (q *Queries) GetChargeOptionReferenceByUserID(ctx context.Context, arg GetChargeOptionReferenceByUserIDParams) (GetChargeOptionReferenceByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceByUserID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
		arg.ID,
	)
	var i GetChargeOptionReferenceByUserIDRow
	err := row.Scan(
		&i.MainPayoutComplete,
		&i.StartDate,
		&i.DateBooked,
		&i.CancelPolicyOne,
		&i.ChargeID,
		&i.UserFirstName,
		&i.HostFirstName,
		&i.HostUserID,
		&i.HostNameOption,
		&i.ChargeType,
		&i.EndDate,
		&i.TimeZone,
		&i.CleanFee,
		&i.PetFee,
		&i.GuestFee,
		&i.MainPrice,
		&i.TotalFee,
		&i.ServiceFee,
		&i.Currency,
	)
	return i, err
}

const getChargeOptionReferenceCheckInStep = `-- name: GetChargeOptionReferenceCheckInStep :many
SELECT cis.photo, cis.des, cis.id
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN check_in_steps cis on oi.id = cis.option_id
    JOIN shortlets s on s.option_id = oi.id
WHERE co.id = $1 AND co.user_id = $2 AND co.cancelled = $3 AND co.is_complete=$4 AND s.publish_check_in_steps = true
ORDER BY cis.created_at
`

type GetChargeOptionReferenceCheckInStepParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeOptionReferenceCheckInStepRow struct {
	Photo string    `json:"photo"`
	Des   string    `json:"des"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) GetChargeOptionReferenceCheckInStep(ctx context.Context, arg GetChargeOptionReferenceCheckInStepParams) ([]GetChargeOptionReferenceCheckInStepRow, error) {
	rows, err := q.db.Query(ctx, getChargeOptionReferenceCheckInStep,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChargeOptionReferenceCheckInStepRow{}
	for rows.Next() {
		var i GetChargeOptionReferenceCheckInStepRow
		if err := rows.Scan(&i.Photo, &i.Des, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChargeOptionReferenceCheckMethod = `-- name: GetChargeOptionReferenceCheckMethod :one
SELECT s.check_in_method, s.check_in_method_des
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN shortlets s on oi.id = s.option_id
WHERE co.id = $1 AND co.user_id = $2 AND co.cancelled = $3 AND co.is_complete=$4
`

type GetChargeOptionReferenceCheckMethodParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeOptionReferenceCheckMethodRow struct {
	CheckInMethod    string `json:"check_in_method"`
	CheckInMethodDes string `json:"check_in_method_des"`
}

func (q *Queries) GetChargeOptionReferenceCheckMethod(ctx context.Context, arg GetChargeOptionReferenceCheckMethodParams) (GetChargeOptionReferenceCheckMethodRow, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceCheckMethod,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var i GetChargeOptionReferenceCheckMethodRow
	err := row.Scan(&i.CheckInMethod, &i.CheckInMethodDes)
	return i, err
}

const getChargeOptionReferenceDetailByRef = `-- name: GetChargeOptionReferenceDetailByRef :one
SELECT co.start_date, co.date_booked, co.id AS charge_id, u.first_name AS user_first_name, us.first_name AS host_first_name, us.user_id AS host_user_id, od.host_name_option, co.end_date, oi.time_zone, co.clean_fee, co.pet_fee, co.guest_fee, co.main_price, co.total_fee, co.service_fee, co.currency, u.default_card AS user_default_card, u.id AS guest_id, co.reference, oi.id AS option_id, oi.option_user_id AS option_user_id
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN users u on u.user_id = co.user_id
    JOIN users us on us.id = oi.host_id
WHERE co.reference = $1
`

type GetChargeOptionReferenceDetailByRefRow struct {
	StartDate       time.Time `json:"start_date"`
	DateBooked      time.Time `json:"date_booked"`
	ChargeID        uuid.UUID `json:"charge_id"`
	UserFirstName   string    `json:"user_first_name"`
	HostFirstName   string    `json:"host_first_name"`
	HostUserID      uuid.UUID `json:"host_user_id"`
	HostNameOption  string    `json:"host_name_option"`
	EndDate         time.Time `json:"end_date"`
	TimeZone        string    `json:"time_zone"`
	CleanFee        int64     `json:"clean_fee"`
	PetFee          int64     `json:"pet_fee"`
	GuestFee        int64     `json:"guest_fee"`
	MainPrice       int64     `json:"main_price"`
	TotalFee        int64     `json:"total_fee"`
	ServiceFee      int64     `json:"service_fee"`
	Currency        string    `json:"currency"`
	UserDefaultCard string    `json:"user_default_card"`
	GuestID         uuid.UUID `json:"guest_id"`
	Reference       string    `json:"reference"`
	OptionID        uuid.UUID `json:"option_id"`
	OptionUserID    uuid.UUID `json:"option_user_id"`
}

// -- This is just just used to get information for notification
func (q *Queries) GetChargeOptionReferenceDetailByRef(ctx context.Context, reference string) (GetChargeOptionReferenceDetailByRefRow, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceDetailByRef, reference)
	var i GetChargeOptionReferenceDetailByRefRow
	err := row.Scan(
		&i.StartDate,
		&i.DateBooked,
		&i.ChargeID,
		&i.UserFirstName,
		&i.HostFirstName,
		&i.HostUserID,
		&i.HostNameOption,
		&i.EndDate,
		&i.TimeZone,
		&i.CleanFee,
		&i.PetFee,
		&i.GuestFee,
		&i.MainPrice,
		&i.TotalFee,
		&i.ServiceFee,
		&i.Currency,
		&i.UserDefaultCard,
		&i.GuestID,
		&i.Reference,
		&i.OptionID,
		&i.OptionUserID,
	)
	return i, err
}

const getChargeOptionReferenceDirection = `-- name: GetChargeOptionReferenceDirection :one
SELECT l.street, l.city, l.state, l.country, l.postcode, o_e_i.info, o_e_i.type, l.geolocation
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN locations l on oi.id = l.option_id
    LEFT JOIN options_extra_infos o_e_i on o_e_i.option_id = oi.id
WHERE co.id = $1 AND co.user_id = $2 AND co.cancelled = $3 AND co.is_complete = $4
`

type GetChargeOptionReferenceDirectionParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeOptionReferenceDirectionRow struct {
	Street      string       `json:"street"`
	City        string       `json:"city"`
	State       string       `json:"state"`
	Country     string       `json:"country"`
	Postcode    string       `json:"postcode"`
	Info        pgtype.Text  `json:"info"`
	Type        pgtype.Text  `json:"type"`
	Geolocation pgtype.Point `json:"geolocation"`
}

func (q *Queries) GetChargeOptionReferenceDirection(ctx context.Context, arg GetChargeOptionReferenceDirectionParams) (GetChargeOptionReferenceDirectionRow, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceDirection,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var i GetChargeOptionReferenceDirectionRow
	err := row.Scan(
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Info,
		&i.Type,
		&i.Geolocation,
	)
	return i, err
}

const getChargeOptionReferenceHelp = `-- name: GetChargeOptionReferenceHelp :one
SELECT o_e_i.info
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_extra_infos o_e_i on o_e_i.option_id = oi.id
WHERE co.id = $1 AND o_e_i.type = $2 AND co.user_id = $3 AND co.cancelled = $4 AND co.is_complete=$5
`

type GetChargeOptionReferenceHelpParams struct {
	ID         uuid.UUID `json:"id"`
	Type       string    `json:"type"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) GetChargeOptionReferenceHelp(ctx context.Context, arg GetChargeOptionReferenceHelpParams) (string, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceHelp,
		arg.ID,
		arg.Type,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var info string
	err := row.Scan(&info)
	return info, err
}

const getChargeOptionReferenceReceipt = `-- name: GetChargeOptionReferenceReceipt :one
SELECT od.host_name_option, co.discount, co.main_price, co.service_fee, co.total_fee, co.date_price, co.currency, co.guest_fee, co.pet_fee, co.clean_fee, co.nightly_pet_fee, co.nightly_guest_fee
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
WHERE co.id = $1 AND co.user_id = $2 AND co.cancelled = $3 AND co.is_complete=$4
`

type GetChargeOptionReferenceReceiptParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeOptionReferenceReceiptRow struct {
	HostNameOption  string   `json:"host_name_option"`
	Discount        string   `json:"discount"`
	MainPrice       int64    `json:"main_price"`
	ServiceFee      int64    `json:"service_fee"`
	TotalFee        int64    `json:"total_fee"`
	DatePrice       []string `json:"date_price"`
	Currency        string   `json:"currency"`
	GuestFee        int64    `json:"guest_fee"`
	PetFee          int64    `json:"pet_fee"`
	CleanFee        int64    `json:"clean_fee"`
	NightlyPetFee   int64    `json:"nightly_pet_fee"`
	NightlyGuestFee int64    `json:"nightly_guest_fee"`
}

func (q *Queries) GetChargeOptionReferenceReceipt(ctx context.Context, arg GetChargeOptionReferenceReceiptParams) (GetChargeOptionReferenceReceiptRow, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceReceipt,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var i GetChargeOptionReferenceReceiptRow
	err := row.Scan(
		&i.HostNameOption,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Currency,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
	)
	return i, err
}

const getChargeOptionReferenceWifi = `-- name: GetChargeOptionReferenceWifi :one
SELECT w_d.network_name, w_d.password
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN wifi_details w_d on w_d.option_id = oi.id
WHERE co.id = $1 AND co.user_id = $2 AND co.cancelled = $3 AND co.is_complete=$4
`

type GetChargeOptionReferenceWifiParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeOptionReferenceWifiRow struct {
	NetworkName string `json:"network_name"`
	Password    string `json:"password"`
}

func (q *Queries) GetChargeOptionReferenceWifi(ctx context.Context, arg GetChargeOptionReferenceWifiParams) (GetChargeOptionReferenceWifiRow, error) {
	row := q.db.QueryRow(ctx, getChargeOptionReferenceWifi,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var i GetChargeOptionReferenceWifiRow
	err := row.Scan(&i.NetworkName, &i.Password)
	return i, err
}

const listAllIDChargeOptionReference = `-- name: ListAllIDChargeOptionReference :many
SELECT id
FROM charge_option_references
WHERE option_user_id = $1
`

func (q *Queries) ListAllIDChargeOptionReference(ctx context.Context, optionUserID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, listAllIDChargeOptionReference, optionUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeOptionReferenceBook = `-- name: ListChargeOptionReferenceBook :many
SELECT u.user_id, co.start_date, co.end_date, co.id AS reference_id, u.first_name, u.photo
FROM charge_option_references co
    JOIN users u on u.user_id = co.user_id
WHERE co.option_user_id = $1 AND co.is_complete=$2 AND co.cancelled=$3
`

type ListChargeOptionReferenceBookParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	IsComplete   bool      `json:"is_complete"`
	Cancelled    bool      `json:"cancelled"`
}

type ListChargeOptionReferenceBookRow struct {
	UserID      uuid.UUID `json:"user_id"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	ReferenceID uuid.UUID `json:"reference_id"`
	FirstName   string    `json:"first_name"`
	Photo       string    `json:"photo"`
}

func (q *Queries) ListChargeOptionReferenceBook(ctx context.Context, arg ListChargeOptionReferenceBookParams) ([]ListChargeOptionReferenceBookRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReferenceBook, arg.OptionUserID, arg.IsComplete, arg.Cancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReferenceBookRow{}
	for rows.Next() {
		var i ListChargeOptionReferenceBookRow
		if err := rows.Scan(
			&i.UserID,
			&i.StartDate,
			&i.EndDate,
			&i.ReferenceID,
			&i.FirstName,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeOptionReferenceByOptionUserID = `-- name: ListChargeOptionReferenceByOptionUserID :many
SELECT oi.main_option_type, u.user_id, od.host_name_option, co.start_date, u.photo, co.end_date, u.first_name, co.id, cid.arrive_after, cid.arrive_before, cid.leave_before, s.check_in_method, o_p_p.cover_image, o_p_p.photo
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN options_info_photos o_p_p on oi.id = o_p_p.option_id
    JOIN check_in_out_details cid on oi.id = cid.option_id
    JOIN users u on u.id = oi.host_id
    JOIN shortlets s on oi.id = s.option_id
WHERE co.option_user_id = $1 AND co.cancelled = $2 AND co.is_complete=$3
`

type ListChargeOptionReferenceByOptionUserIDParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	Cancelled    bool      `json:"cancelled"`
	IsComplete   bool      `json:"is_complete"`
}

type ListChargeOptionReferenceByOptionUserIDRow struct {
	MainOptionType string    `json:"main_option_type"`
	UserID         uuid.UUID `json:"user_id"`
	HostNameOption string    `json:"host_name_option"`
	StartDate      time.Time `json:"start_date"`
	Photo          string    `json:"photo"`
	EndDate        time.Time `json:"end_date"`
	FirstName      string    `json:"first_name"`
	ID             uuid.UUID `json:"id"`
	ArriveAfter    string    `json:"arrive_after"`
	ArriveBefore   string    `json:"arrive_before"`
	LeaveBefore    string    `json:"leave_before"`
	CheckInMethod  string    `json:"check_in_method"`
	CoverImage     string    `json:"cover_image"`
	Photo_2        []string  `json:"photo_2"`
}

func (q *Queries) ListChargeOptionReferenceByOptionUserID(ctx context.Context, arg ListChargeOptionReferenceByOptionUserIDParams) ([]ListChargeOptionReferenceByOptionUserIDRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReferenceByOptionUserID, arg.OptionUserID, arg.Cancelled, arg.IsComplete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReferenceByOptionUserIDRow{}
	for rows.Next() {
		var i ListChargeOptionReferenceByOptionUserIDRow
		if err := rows.Scan(
			&i.MainOptionType,
			&i.UserID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Photo,
			&i.EndDate,
			&i.FirstName,
			&i.ID,
			&i.ArriveAfter,
			&i.ArriveBefore,
			&i.LeaveBefore,
			&i.CheckInMethod,
			&i.CoverImage,
			&i.Photo_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeOptionReferenceCurrent = `-- name: ListChargeOptionReferenceCurrent :many
SELECT oi.main_option_type, u.user_id, od.host_name_option, co.start_date, u.photo, co.end_date, u.first_name, co.id, cid.arrive_after, cid.arrive_before, cid.leave_before, s.check_in_method, s.type_of_shortlet, s.space_type, o_p_p.cover_image, o_p_p.photo, co.total_fee, co.date_booked, co.currency, l.street, l.city, l.state, l.country, oi.time_zone, o_p_p.public_cover_image, o_p_p.public_photo AS option_public_photo, u.public_photo AS host_public_photo,
CASE
    WHEN NOW() > co.end_date + INTERVAL '4 hours' AND NOT EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id) THEN 'started'
    WHEN NOW() > co.end_date + INTERVAL '4 hours' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id) THEN cr.status
    ELSE 'none'
END AS review_stage
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN options_info_photos o_p_p on oi.id = o_p_p.option_id
    JOIN check_in_out_details cid on oi.id = cid.option_id
    JOIN users u on u.id = oi.host_id
    JOIN shortlets s on oi.id = s.option_id
    JOIN locations l on l.option_id = oi.id
    LEFT JOIN charge_reviews cr on cr.charge_id = co.id
WHERE co.user_id = $1 AND co.cancelled = $2 AND co.is_complete = $3 AND (NOW() <= co.end_date + INTERVAL '13 days' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id AND cr.is_published = false) OR NOW() <= co.end_date + INTERVAL '13 days' AND NOT EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id))
ORDER BY
CASE
    WHEN co.end_date + INTERVAL '13 days' <= NOW() AND NOT EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id) THEN 1
    WHEN co.end_date + INTERVAL '13 days' <= NOW() AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id AND cr.is_published = false) THEN 2
    WHEN co.start_date = CURRENT_DATE OR co.start_date - INTERVAL '1 day' <= CURRENT_DATE THEN 3
    ELSE 4
END, co.start_date ASC
LIMIT $4
OFFSET $5
`

type ListChargeOptionReferenceCurrentParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type ListChargeOptionReferenceCurrentRow struct {
	MainOptionType    string    `json:"main_option_type"`
	UserID            uuid.UUID `json:"user_id"`
	HostNameOption    string    `json:"host_name_option"`
	StartDate         time.Time `json:"start_date"`
	Photo             string    `json:"photo"`
	EndDate           time.Time `json:"end_date"`
	FirstName         string    `json:"first_name"`
	ID                uuid.UUID `json:"id"`
	ArriveAfter       string    `json:"arrive_after"`
	ArriveBefore      string    `json:"arrive_before"`
	LeaveBefore       string    `json:"leave_before"`
	CheckInMethod     string    `json:"check_in_method"`
	TypeOfShortlet    string    `json:"type_of_shortlet"`
	SpaceType         string    `json:"space_type"`
	CoverImage        string    `json:"cover_image"`
	Photo_2           []string  `json:"photo_2"`
	TotalFee          int64     `json:"total_fee"`
	DateBooked        time.Time `json:"date_booked"`
	Currency          string    `json:"currency"`
	Street            string    `json:"street"`
	City              string    `json:"city"`
	State             string    `json:"state"`
	Country           string    `json:"country"`
	TimeZone          string    `json:"time_zone"`
	PublicCoverImage  string    `json:"public_cover_image"`
	OptionPublicPhoto []string  `json:"option_public_photo"`
	HostPublicPhoto   string    `json:"host_public_photo"`
	ReviewStage       string    `json:"review_stage"`
}

func (q *Queries) ListChargeOptionReferenceCurrent(ctx context.Context, arg ListChargeOptionReferenceCurrentParams) ([]ListChargeOptionReferenceCurrentRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReferenceCurrent,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReferenceCurrentRow{}
	for rows.Next() {
		var i ListChargeOptionReferenceCurrentRow
		if err := rows.Scan(
			&i.MainOptionType,
			&i.UserID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Photo,
			&i.EndDate,
			&i.FirstName,
			&i.ID,
			&i.ArriveAfter,
			&i.ArriveBefore,
			&i.LeaveBefore,
			&i.CheckInMethod,
			&i.TypeOfShortlet,
			&i.SpaceType,
			&i.CoverImage,
			&i.Photo_2,
			&i.TotalFee,
			&i.DateBooked,
			&i.Currency,
			&i.Street,
			&i.City,
			&i.State,
			&i.Country,
			&i.TimeZone,
			&i.PublicCoverImage,
			&i.OptionPublicPhoto,
			&i.HostPublicPhoto,
			&i.ReviewStage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeOptionReferenceDates = `-- name: ListChargeOptionReferenceDates :many
SELECT start_date, end_date
FROM charge_option_references
WHERE option_user_id = $1 AND is_complete=$2 AND cancelled=$3
`

type ListChargeOptionReferenceDatesParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	IsComplete   bool      `json:"is_complete"`
	Cancelled    bool      `json:"cancelled"`
}

type ListChargeOptionReferenceDatesRow struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) ListChargeOptionReferenceDates(ctx context.Context, arg ListChargeOptionReferenceDatesParams) ([]ListChargeOptionReferenceDatesRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReferenceDates, arg.OptionUserID, arg.IsComplete, arg.Cancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReferenceDatesRow{}
	for rows.Next() {
		var i ListChargeOptionReferenceDatesRow
		if err := rows.Scan(&i.StartDate, &i.EndDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeOptionReferenceDatesMore = `-- name: ListChargeOptionReferenceDatesMore :many
SELECT start_date, end_date
FROM charge_option_references
WHERE option_user_id = $1 AND is_complete=$2 AND cancelled=$3 AND start_date > NOW()
`

type ListChargeOptionReferenceDatesMoreParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	IsComplete   bool      `json:"is_complete"`
	Cancelled    bool      `json:"cancelled"`
}

type ListChargeOptionReferenceDatesMoreRow struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) ListChargeOptionReferenceDatesMore(ctx context.Context, arg ListChargeOptionReferenceDatesMoreParams) ([]ListChargeOptionReferenceDatesMoreRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReferenceDatesMore, arg.OptionUserID, arg.IsComplete, arg.Cancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReferenceDatesMoreRow{}
	for rows.Next() {
		var i ListChargeOptionReferenceDatesMoreRow
		if err := rows.Scan(&i.StartDate, &i.EndDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeOptionReferenceHost = `-- name: ListChargeOptionReferenceHost :many
SELECT
    u.user_id,
    co.start_date,
    co.end_date,
    co.id AS reference_id,
    oi.id AS option_id,
    op.cover_image,
    u.first_name,
    od.host_name_option,
    u.photo,
    cid.arrive_after,
    cid.arrive_before,
    cid.leave_before,
    oi.time_zone,
    os.status,
    oi.co_host_id,
    op.cover_image,
    CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.scan_code::boolean
        WHEN oi.host_id = $2 THEN true
        ELSE false -- Optional: Handle other cases if needed
    END AS scan_code,
    CASE WHEN och_subquery.reservations IS NOT NULL THEN och_subquery.scan_code::boolean
        WHEN oi.host_id = $2 THEN true
        ELSE false -- Optional: Handle other cases if needed
    END AS reservations,
    CASE
        WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
        WHEN oi.host_id = $2 THEN 'main_host'
        ELSE 'none' -- Optional: Handle other cases if needed
    END AS host_type
FROM
    charge_option_references co
JOIN options_infos oi ON co.option_user_id = oi.option_user_id
JOIN options_info_details od ON od.option_id = oi.id
JOIN options_info_photos op ON op.option_id = oi.id
JOIN check_in_out_details cid ON cid.option_id = oi.id
JOIN users u ON u.user_id = co.user_id
JOIN options_infos_status AS os ON os.option_id = oi.id
LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations
    FROM option_co_hosts
    WHERE co_user_id = $1
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE
    (oi.host_id = $2 OR och_subquery.option_id IS NOT NULL)
    AND oi.is_complete = true
    AND oi.is_active = true
    AND co.is_complete = true
    AND co.cancelled = false
ORDER BY
    co.created_at DESC
`

type ListChargeOptionReferenceHostParams struct {
	CoUserID string    `json:"co_user_id"`
	HostID   uuid.UUID `json:"host_id"`
}

type ListChargeOptionReferenceHostRow struct {
	UserID         uuid.UUID `json:"user_id"`
	StartDate      time.Time `json:"start_date"`
	EndDate        time.Time `json:"end_date"`
	ReferenceID    uuid.UUID `json:"reference_id"`
	OptionID       uuid.UUID `json:"option_id"`
	CoverImage     string    `json:"cover_image"`
	FirstName      string    `json:"first_name"`
	HostNameOption string    `json:"host_name_option"`
	Photo          string    `json:"photo"`
	ArriveAfter    string    `json:"arrive_after"`
	ArriveBefore   string    `json:"arrive_before"`
	LeaveBefore    string    `json:"leave_before"`
	TimeZone       string    `json:"time_zone"`
	Status         string    `json:"status"`
	CoHostID       uuid.UUID `json:"co_host_id"`
	CoverImage_2   string    `json:"cover_image_2"`
	ScanCode       bool      `json:"scan_code"`
	Reservations   bool      `json:"reservations"`
	HostType       string    `json:"host_type"`
}

func (q *Queries) ListChargeOptionReferenceHost(ctx context.Context, arg ListChargeOptionReferenceHostParams) ([]ListChargeOptionReferenceHostRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReferenceHost, arg.CoUserID, arg.HostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReferenceHostRow{}
	for rows.Next() {
		var i ListChargeOptionReferenceHostRow
		if err := rows.Scan(
			&i.UserID,
			&i.StartDate,
			&i.EndDate,
			&i.ReferenceID,
			&i.OptionID,
			&i.CoverImage,
			&i.FirstName,
			&i.HostNameOption,
			&i.Photo,
			&i.ArriveAfter,
			&i.ArriveBefore,
			&i.LeaveBefore,
			&i.TimeZone,
			&i.Status,
			&i.CoHostID,
			&i.CoverImage_2,
			&i.ScanCode,
			&i.Reservations,
			&i.HostType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeOptionReferenceVisited = `-- name: ListChargeOptionReferenceVisited :many
SELECT oi.main_option_type, u.user_id, od.host_name_option, co.start_date, u.photo, co.end_date, u.first_name, co.id, cid.arrive_after, cid.arrive_before, cid.leave_before, s.check_in_method, s.type_of_shortlet, s.space_type, o_p_p.cover_image, o_p_p.photo, co.total_fee, co.date_booked, co.currency, l.street, l.city, l.state, l.country, oi.time_zone, o_p_p.public_cover_image, o_p_p.public_photo AS option_public_photo, u.public_photo AS host_public_photo
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN options_info_photos o_p_p on oi.id = o_p_p.option_id
    JOIN check_in_out_details cid on oi.id = cid.option_id
    JOIN users u on u.id = oi.host_id
    JOIN shortlets s on oi.id = s.option_id
    JOIN locations l on l.option_id = oi.id
    LEFT JOIN charge_reviews cr on cr.charge_id = co.id
WHERE co.user_id = $1 AND co.cancelled = $2 AND co.is_complete = $3 AND (NOW() > co.end_date + INTERVAL '8 hours' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = co.id AND cr.is_published = TRUE) OR NOW() > co.end_date + INTERVAL '13 days')
ORDER BY co.end_date DESC
LIMIT $4
OFFSET $5
`

type ListChargeOptionReferenceVisitedParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type ListChargeOptionReferenceVisitedRow struct {
	MainOptionType    string    `json:"main_option_type"`
	UserID            uuid.UUID `json:"user_id"`
	HostNameOption    string    `json:"host_name_option"`
	StartDate         time.Time `json:"start_date"`
	Photo             string    `json:"photo"`
	EndDate           time.Time `json:"end_date"`
	FirstName         string    `json:"first_name"`
	ID                uuid.UUID `json:"id"`
	ArriveAfter       string    `json:"arrive_after"`
	ArriveBefore      string    `json:"arrive_before"`
	LeaveBefore       string    `json:"leave_before"`
	CheckInMethod     string    `json:"check_in_method"`
	TypeOfShortlet    string    `json:"type_of_shortlet"`
	SpaceType         string    `json:"space_type"`
	CoverImage        string    `json:"cover_image"`
	Photo_2           []string  `json:"photo_2"`
	TotalFee          int64     `json:"total_fee"`
	DateBooked        time.Time `json:"date_booked"`
	Currency          string    `json:"currency"`
	Street            string    `json:"street"`
	City              string    `json:"city"`
	State             string    `json:"state"`
	Country           string    `json:"country"`
	TimeZone          string    `json:"time_zone"`
	PublicCoverImage  string    `json:"public_cover_image"`
	OptionPublicPhoto []string  `json:"option_public_photo"`
	HostPublicPhoto   string    `json:"host_public_photo"`
}

func (q *Queries) ListChargeOptionReferenceVisited(ctx context.Context, arg ListChargeOptionReferenceVisitedParams) ([]ListChargeOptionReferenceVisitedRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReferenceVisited,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReferenceVisitedRow{}
	for rows.Next() {
		var i ListChargeOptionReferenceVisitedRow
		if err := rows.Scan(
			&i.MainOptionType,
			&i.UserID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Photo,
			&i.EndDate,
			&i.FirstName,
			&i.ID,
			&i.ArriveAfter,
			&i.ArriveBefore,
			&i.LeaveBefore,
			&i.CheckInMethod,
			&i.TypeOfShortlet,
			&i.SpaceType,
			&i.CoverImage,
			&i.Photo_2,
			&i.TotalFee,
			&i.DateBooked,
			&i.Currency,
			&i.Street,
			&i.City,
			&i.State,
			&i.Country,
			&i.TimeZone,
			&i.PublicCoverImage,
			&i.OptionPublicPhoto,
			&i.HostPublicPhoto,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionPaymentByUserID = `-- name: ListOptionPaymentByUserID :many
SELECT oi.main_option_type, u.user_id, od.host_name_option, co.start_date, u.photo, co.end_date, u.first_name, co.id, cid.arrive_after, cid.arrive_before, cid.leave_before, s.check_in_method, o_p_p.cover_image, o_p_p.photo, co.total_fee, co.date_booked, co.currency, co.cancelled
FROM charge_option_references co
    JOIN options_infos oi on oi.option_user_id = co.option_user_id
    JOIN options_info_details od on oi.id = od.option_id
    JOIN options_info_photos o_p_p on oi.id = o_p_p.option_id
    JOIN check_in_out_details cid on oi.id = cid.option_id
    JOIN users u on u.id = oi.host_id
    JOIN shortlets s on oi.id = s.option_id
WHERE co.user_id = $1 AND co.is_complete=$2
ORDER BY co.start_date DESC
LIMIT $3
OFFSET $4
`

type ListOptionPaymentByUserIDParams struct {
	UserID     uuid.UUID `json:"user_id"`
	IsComplete bool      `json:"is_complete"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type ListOptionPaymentByUserIDRow struct {
	MainOptionType string    `json:"main_option_type"`
	UserID         uuid.UUID `json:"user_id"`
	HostNameOption string    `json:"host_name_option"`
	StartDate      time.Time `json:"start_date"`
	Photo          string    `json:"photo"`
	EndDate        time.Time `json:"end_date"`
	FirstName      string    `json:"first_name"`
	ID             uuid.UUID `json:"id"`
	ArriveAfter    string    `json:"arrive_after"`
	ArriveBefore   string    `json:"arrive_before"`
	LeaveBefore    string    `json:"leave_before"`
	CheckInMethod  string    `json:"check_in_method"`
	CoverImage     string    `json:"cover_image"`
	Photo_2        []string  `json:"photo_2"`
	TotalFee       int64     `json:"total_fee"`
	DateBooked     time.Time `json:"date_booked"`
	Currency       string    `json:"currency"`
	Cancelled      bool      `json:"cancelled"`
}

func (q *Queries) ListOptionPaymentByUserID(ctx context.Context, arg ListOptionPaymentByUserIDParams) ([]ListOptionPaymentByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listOptionPaymentByUserID,
		arg.UserID,
		arg.IsComplete,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionPaymentByUserIDRow{}
	for rows.Next() {
		var i ListOptionPaymentByUserIDRow
		if err := rows.Scan(
			&i.MainOptionType,
			&i.UserID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Photo,
			&i.EndDate,
			&i.FirstName,
			&i.ID,
			&i.ArriveAfter,
			&i.ArriveBefore,
			&i.LeaveBefore,
			&i.CheckInMethod,
			&i.CoverImage,
			&i.Photo_2,
			&i.TotalFee,
			&i.DateBooked,
			&i.Currency,
			&i.Cancelled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeChargeOptionReference = `-- name: RemoveChargeOptionReference :exec
DELETE FROM charge_option_references
WHERE id = $1
`

func (q *Queries) RemoveChargeOptionReference(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeChargeOptionReference, id)
	return err
}

const updateChargeOptionReferenceByID = `-- name: UpdateChargeOptionReferenceByID :one
UPDATE charge_option_references
SET 
    discount = COALESCE($1, discount),
    main_price = COALESCE($2, main_price),
    service_fee = COALESCE($3, service_fee),
    total_fee = COALESCE($4, total_fee),
    currency = COALESCE($5, currency),
    end_date = COALESCE($6, end_date),
    guest_fee = COALESCE($7, guest_fee),
    pet_fee = COALESCE($8, pet_fee),
    clean_fee = COALESCE($9, clean_fee),
    nightly_pet_fee = COALESCE($10, nightly_pet_fee),
    nightly_guest_fee = COALESCE($11, nightly_guest_fee),
    date_booked = COALESCE($12, date_booked),
    can_instant_book = COALESCE($13, can_instant_book),
    require_request = COALESCE($14, require_request),
    request_type = COALESCE($15, request_type),
    request_approved = COALESCE($16, request_approved),
    payment_reference = COALESCE($17, payment_reference),
    is_complete = COALESCE($18, is_complete),
    cancelled = COALESCE($19, cancelled),
    updated_at = NOW()
WHERE id = $20
RETURNING id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
`

type UpdateChargeOptionReferenceByIDParams struct {
	Discount         pgtype.Text        `json:"discount"`
	MainPrice        pgtype.Int8        `json:"main_price"`
	ServiceFee       pgtype.Int8        `json:"service_fee"`
	TotalFee         pgtype.Int8        `json:"total_fee"`
	Currency         pgtype.Text        `json:"currency"`
	EndDate          pgtype.Date        `json:"end_date"`
	GuestFee         pgtype.Int8        `json:"guest_fee"`
	PetFee           pgtype.Int8        `json:"pet_fee"`
	CleanFee         pgtype.Int8        `json:"clean_fee"`
	NightlyPetFee    pgtype.Int8        `json:"nightly_pet_fee"`
	NightlyGuestFee  pgtype.Int8        `json:"nightly_guest_fee"`
	DateBooked       pgtype.Timestamptz `json:"date_booked"`
	CanInstantBook   pgtype.Bool        `json:"can_instant_book"`
	RequireRequest   pgtype.Bool        `json:"require_request"`
	RequestType      pgtype.Text        `json:"request_type"`
	RequestApproved  pgtype.Bool        `json:"request_approved"`
	PaymentReference pgtype.Text        `json:"payment_reference"`
	IsComplete       pgtype.Bool        `json:"is_complete"`
	Cancelled        pgtype.Bool        `json:"cancelled"`
	ID               uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateChargeOptionReferenceByID(ctx context.Context, arg UpdateChargeOptionReferenceByIDParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, updateChargeOptionReferenceByID,
		arg.Discount,
		arg.MainPrice,
		arg.ServiceFee,
		arg.TotalFee,
		arg.Currency,
		arg.EndDate,
		arg.GuestFee,
		arg.PetFee,
		arg.CleanFee,
		arg.NightlyPetFee,
		arg.NightlyGuestFee,
		arg.DateBooked,
		arg.CanInstantBook,
		arg.RequireRequest,
		arg.RequestType,
		arg.RequestApproved,
		arg.PaymentReference,
		arg.IsComplete,
		arg.Cancelled,
		arg.ID,
	)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChargeOptionReferenceByRef = `-- name: UpdateChargeOptionReferenceByRef :one
UPDATE charge_option_references
SET 
    discount = COALESCE($1, discount),
    main_price = COALESCE($2, main_price),
    service_fee = COALESCE($3, service_fee),
    total_fee = COALESCE($4, total_fee),
    currency = COALESCE($5, currency),
    end_date = COALESCE($6, end_date),
    guest_fee = COALESCE($7, guest_fee),
    pet_fee = COALESCE($8, pet_fee),
    clean_fee = COALESCE($9, clean_fee),
    nightly_pet_fee = COALESCE($10, nightly_pet_fee),
    nightly_guest_fee = COALESCE($11, nightly_guest_fee),
    date_booked = COALESCE($12, date_booked),
    can_instant_book = COALESCE($13, can_instant_book),
    require_request = COALESCE($14, require_request),
    request_type = COALESCE($15, request_type),
    request_approved = COALESCE($16, request_approved),
    payment_reference = COALESCE($17, payment_reference),
    is_complete = COALESCE($18, is_complete),
    cancelled = COALESCE($19, cancelled),
    updated_at = NOW()
WHERE reference = $20 AND user_id = $21
RETURNING id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
`

type UpdateChargeOptionReferenceByRefParams struct {
	Discount         pgtype.Text        `json:"discount"`
	MainPrice        pgtype.Int8        `json:"main_price"`
	ServiceFee       pgtype.Int8        `json:"service_fee"`
	TotalFee         pgtype.Int8        `json:"total_fee"`
	Currency         pgtype.Text        `json:"currency"`
	EndDate          pgtype.Date        `json:"end_date"`
	GuestFee         pgtype.Int8        `json:"guest_fee"`
	PetFee           pgtype.Int8        `json:"pet_fee"`
	CleanFee         pgtype.Int8        `json:"clean_fee"`
	NightlyPetFee    pgtype.Int8        `json:"nightly_pet_fee"`
	NightlyGuestFee  pgtype.Int8        `json:"nightly_guest_fee"`
	DateBooked       pgtype.Timestamptz `json:"date_booked"`
	CanInstantBook   pgtype.Bool        `json:"can_instant_book"`
	RequireRequest   pgtype.Bool        `json:"require_request"`
	RequestType      pgtype.Text        `json:"request_type"`
	RequestApproved  pgtype.Bool        `json:"request_approved"`
	PaymentReference pgtype.Text        `json:"payment_reference"`
	IsComplete       pgtype.Bool        `json:"is_complete"`
	Cancelled        pgtype.Bool        `json:"cancelled"`
	Reference        string             `json:"reference"`
	UserID           uuid.UUID          `json:"user_id"`
}

func (q *Queries) UpdateChargeOptionReferenceByRef(ctx context.Context, arg UpdateChargeOptionReferenceByRefParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, updateChargeOptionReferenceByRef,
		arg.Discount,
		arg.MainPrice,
		arg.ServiceFee,
		arg.TotalFee,
		arg.Currency,
		arg.EndDate,
		arg.GuestFee,
		arg.PetFee,
		arg.CleanFee,
		arg.NightlyPetFee,
		arg.NightlyGuestFee,
		arg.DateBooked,
		arg.CanInstantBook,
		arg.RequireRequest,
		arg.RequestType,
		arg.RequestApproved,
		arg.PaymentReference,
		arg.IsComplete,
		arg.Cancelled,
		arg.Reference,
		arg.UserID,
	)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChargeOptionReferenceComplete = `-- name: UpdateChargeOptionReferenceComplete :one
UPDATE charge_option_references
SET 
    is_complete = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
`

type UpdateChargeOptionReferenceCompleteParams struct {
	IsComplete bool      `json:"is_complete"`
	ID         uuid.UUID `json:"id"`
}

func (q *Queries) UpdateChargeOptionReferenceComplete(ctx context.Context, arg UpdateChargeOptionReferenceCompleteParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, updateChargeOptionReferenceComplete, arg.IsComplete, arg.ID)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChargeOptionReferenceCompleteByReference = `-- name: UpdateChargeOptionReferenceCompleteByReference :one
UPDATE charge_option_references
SET 
    is_complete = $1,
    updated_at = NOW()
WHERE reference = $2
RETURNING id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
`

type UpdateChargeOptionReferenceCompleteByReferenceParams struct {
	IsComplete bool   `json:"is_complete"`
	Reference  string `json:"reference"`
}

func (q *Queries) UpdateChargeOptionReferenceCompleteByReference(ctx context.Context, arg UpdateChargeOptionReferenceCompleteByReferenceParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, updateChargeOptionReferenceCompleteByReference, arg.IsComplete, arg.Reference)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChargeOptionReferencePriceByRef = `-- name: UpdateChargeOptionReferencePriceByRef :one
UPDATE charge_option_references
SET 
    discount = $1,
    main_price = $2,
    service_fee = $3,
    total_fee = $4,
    currency = $5,
    guest_fee = $6,
    pet_fee = $7,
    clean_fee = $8,
    nightly_pet_fee = $9,
    nightly_guest_fee = $10,
    date_price = $11,
    updated_at = NOW()
WHERE reference = $12 AND user_id = $13
RETURNING id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, created_at, updated_at
`

type UpdateChargeOptionReferencePriceByRefParams struct {
	Discount        string    `json:"discount"`
	MainPrice       int64     `json:"main_price"`
	ServiceFee      int64     `json:"service_fee"`
	TotalFee        int64     `json:"total_fee"`
	Currency        string    `json:"currency"`
	GuestFee        int64     `json:"guest_fee"`
	PetFee          int64     `json:"pet_fee"`
	CleanFee        int64     `json:"clean_fee"`
	NightlyPetFee   int64     `json:"nightly_pet_fee"`
	NightlyGuestFee int64     `json:"nightly_guest_fee"`
	DatePrice       []string  `json:"date_price"`
	Reference       string    `json:"reference"`
	UserID          uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateChargeOptionReferencePriceByRef(ctx context.Context, arg UpdateChargeOptionReferencePriceByRefParams) (ChargeOptionReference, error) {
	row := q.db.QueryRow(ctx, updateChargeOptionReferencePriceByRef,
		arg.Discount,
		arg.MainPrice,
		arg.ServiceFee,
		arg.TotalFee,
		arg.Currency,
		arg.GuestFee,
		arg.PetFee,
		arg.CleanFee,
		arg.NightlyPetFee,
		arg.NightlyGuestFee,
		arg.DatePrice,
		arg.Reference,
		arg.UserID,
	)
	var i ChargeOptionReference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
