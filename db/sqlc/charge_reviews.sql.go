// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: charge_reviews.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countChargeOptionReviewIndex = `-- name: CountChargeOptionReviewIndex :one
SELECT Count(*)
FROM charge_reviews cr
JOIN charge_option_references co ON cr.charge_id = co.id
JOIN users u ON co.user_id = u.user_id
WHERE co.option_user_id = $1 AND cr.is_published = true
`

func (q *Queries) CountChargeOptionReviewIndex(ctx context.Context, optionUserID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeOptionReviewIndex, optionUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChargeReview = `-- name: CreateChargeReview :one
INSERT INTO charge_reviews (
    charge_id,
    type,
    general,
    amenities,
    current_state,
    previous_state
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING charge_id, previous_state, current_state
`

type CreateChargeReviewParams struct {
	ChargeID      uuid.UUID `json:"charge_id"`
	Type          string    `json:"type"`
	General       int32     `json:"general"`
	Amenities     []string  `json:"amenities"`
	CurrentState  string    `json:"current_state"`
	PreviousState string    `json:"previous_state"`
}

type CreateChargeReviewRow struct {
	ChargeID      uuid.UUID `json:"charge_id"`
	PreviousState string    `json:"previous_state"`
	CurrentState  string    `json:"current_state"`
}

func (q *Queries) CreateChargeReview(ctx context.Context, arg CreateChargeReviewParams) (CreateChargeReviewRow, error) {
	row := q.db.QueryRow(ctx, createChargeReview,
		arg.ChargeID,
		arg.Type,
		arg.General,
		arg.Amenities,
		arg.CurrentState,
		arg.PreviousState,
	)
	var i CreateChargeReviewRow
	err := row.Scan(&i.ChargeID, &i.PreviousState, &i.CurrentState)
	return i, err
}

const getChargeReview = `-- name: GetChargeReview :one
SELECT charge_id, type, general, environment, accuracy, check_in, communication, is_published, location, current_state, previous_state, status, private_note, public_note, stay_clean, stay_comfort, host_review, amenities, created_at, updated_at
FROM charge_reviews
WHERE charge_id = $1
`

func (q *Queries) GetChargeReview(ctx context.Context, chargeID uuid.UUID) (ChargeReview, error) {
	row := q.db.QueryRow(ctx, getChargeReview, chargeID)
	var i ChargeReview
	err := row.Scan(
		&i.ChargeID,
		&i.Type,
		&i.General,
		&i.Environment,
		&i.Accuracy,
		&i.CheckIn,
		&i.Communication,
		&i.IsPublished,
		&i.Location,
		&i.CurrentState,
		&i.PreviousState,
		&i.Status,
		&i.PrivateNote,
		&i.PublicNote,
		&i.StayClean,
		&i.StayComfort,
		&i.HostReview,
		&i.Amenities,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargeReviewAmenities = `-- name: GetChargeReviewAmenities :one
SELECT amenities
FROM charge_reviews
WHERE charge_id = $1 AND is_published = false
`

func (q *Queries) GetChargeReviewAmenities(ctx context.Context, chargeID uuid.UUID) ([]string, error) {
	row := q.db.QueryRow(ctx, getChargeReviewAmenities, chargeID)
	var amenities []string
	err := row.Scan(&amenities)
	return amenities, err
}

const getOptionChargeReview = `-- name: GetOptionChargeReview :one
SELECT charge_id, type, general, environment, accuracy, check_in, communication, is_published, location, current_state, previous_state, status, private_note, public_note, stay_clean, stay_comfort, host_review, amenities, cr.created_at, cr.updated_at, id, user_id, option_user_id, discount, main_price, service_fee, total_fee, date_price, guests, date_booked, currency, start_date, end_date, guest_fee, pet_fee, clean_fee, nightly_pet_fee, nightly_guest_fee, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, cancelled, co.created_at, co.updated_at
FROM charge_reviews cr
JOIN charge_option_references co ON cr.charge_id = co.id
WHERE cr.charge_id = $1 AND co.user_id = $2
`

type GetOptionChargeReviewParams struct {
	ChargeID uuid.UUID `json:"charge_id"`
	UserID   uuid.UUID `json:"user_id"`
}

type GetOptionChargeReviewRow struct {
	ChargeID         uuid.UUID `json:"charge_id"`
	Type             string    `json:"type"`
	General          int32     `json:"general"`
	Environment      int32     `json:"environment"`
	Accuracy         int32     `json:"accuracy"`
	CheckIn          int32     `json:"check_in"`
	Communication    int32     `json:"communication"`
	IsPublished      bool      `json:"is_published"`
	Location         int32     `json:"location"`
	CurrentState     string    `json:"current_state"`
	PreviousState    string    `json:"previous_state"`
	Status           string    `json:"status"`
	PrivateNote      string    `json:"private_note"`
	PublicNote       string    `json:"public_note"`
	StayClean        string    `json:"stay_clean"`
	StayComfort      string    `json:"stay_comfort"`
	HostReview       string    `json:"host_review"`
	Amenities        []string  `json:"amenities"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
	ID               uuid.UUID `json:"id"`
	UserID           uuid.UUID `json:"user_id"`
	OptionUserID     uuid.UUID `json:"option_user_id"`
	Discount         string    `json:"discount"`
	MainPrice        int64     `json:"main_price"`
	ServiceFee       int64     `json:"service_fee"`
	TotalFee         int64     `json:"total_fee"`
	DatePrice        []string  `json:"date_price"`
	Guests           []string  `json:"guests"`
	DateBooked       time.Time `json:"date_booked"`
	Currency         string    `json:"currency"`
	StartDate        time.Time `json:"start_date"`
	EndDate          time.Time `json:"end_date"`
	GuestFee         int64     `json:"guest_fee"`
	PetFee           int64     `json:"pet_fee"`
	CleanFee         int64     `json:"clean_fee"`
	NightlyPetFee    int64     `json:"nightly_pet_fee"`
	NightlyGuestFee  int64     `json:"nightly_guest_fee"`
	CanInstantBook   bool      `json:"can_instant_book"`
	RequireRequest   bool      `json:"require_request"`
	RequestType      string    `json:"request_type"`
	Reference        string    `json:"reference"`
	PaymentReference string    `json:"payment_reference"`
	RequestApproved  bool      `json:"request_approved"`
	IsComplete       bool      `json:"is_complete"`
	Cancelled        bool      `json:"cancelled"`
	CreatedAt_2      time.Time `json:"created_at_2"`
	UpdatedAt_2      time.Time `json:"updated_at_2"`
}

func (q *Queries) GetOptionChargeReview(ctx context.Context, arg GetOptionChargeReviewParams) (GetOptionChargeReviewRow, error) {
	row := q.db.QueryRow(ctx, getOptionChargeReview, arg.ChargeID, arg.UserID)
	var i GetOptionChargeReviewRow
	err := row.Scan(
		&i.ChargeID,
		&i.Type,
		&i.General,
		&i.Environment,
		&i.Accuracy,
		&i.CheckIn,
		&i.Communication,
		&i.IsPublished,
		&i.Location,
		&i.CurrentState,
		&i.PreviousState,
		&i.Status,
		&i.PrivateNote,
		&i.PublicNote,
		&i.StayClean,
		&i.StayComfort,
		&i.HostReview,
		&i.Amenities,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID,
		&i.UserID,
		&i.OptionUserID,
		&i.Discount,
		&i.MainPrice,
		&i.ServiceFee,
		&i.TotalFee,
		&i.DatePrice,
		&i.Guests,
		&i.DateBooked,
		&i.Currency,
		&i.StartDate,
		&i.EndDate,
		&i.GuestFee,
		&i.PetFee,
		&i.CleanFee,
		&i.NightlyPetFee,
		&i.NightlyGuestFee,
		&i.CanInstantBook,
		&i.RequireRequest,
		&i.RequestType,
		&i.Reference,
		&i.PaymentReference,
		&i.RequestApproved,
		&i.IsComplete,
		&i.Cancelled,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const listChargeOptionReview = `-- name: ListChargeOptionReview :many
SELECT cr.general, cr.environment, cr.accuracy, cr.check_in, cr.communication, cr.location, cr.public_note, u.first_name, u.image AS host_image, u.created_at AS user_joined, co.start_date AS date_booked, co.guests
FROM charge_reviews cr
JOIN charge_option_references co ON cr.charge_id = co.id
JOIN users u ON co.user_id = u.user_id
WHERE co.option_user_id = $1 AND cr.is_published = true
ORDER BY co.start_date DESC
`

type ListChargeOptionReviewRow struct {
	General       int32     `json:"general"`
	Environment   int32     `json:"environment"`
	Accuracy      int32     `json:"accuracy"`
	CheckIn       int32     `json:"check_in"`
	Communication int32     `json:"communication"`
	Location      int32     `json:"location"`
	PublicNote    string    `json:"public_note"`
	FirstName     string    `json:"first_name"`
	HostImage     string    `json:"host_image"`
	UserJoined    time.Time `json:"user_joined"`
	DateBooked    time.Time `json:"date_booked"`
	Guests        []string  `json:"guests"`
}

func (q *Queries) ListChargeOptionReview(ctx context.Context, optionUserID uuid.UUID) ([]ListChargeOptionReviewRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReview, optionUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReviewRow{}
	for rows.Next() {
		var i ListChargeOptionReviewRow
		if err := rows.Scan(
			&i.General,
			&i.Environment,
			&i.Accuracy,
			&i.CheckIn,
			&i.Communication,
			&i.Location,
			&i.PublicNote,
			&i.FirstName,
			&i.HostImage,
			&i.UserJoined,
			&i.DateBooked,
			&i.Guests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeOptionReviewIndex = `-- name: ListChargeOptionReviewIndex :many
SELECT cr.general, cr.environment, cr.accuracy, cr.check_in, cr.communication, cr.location, cr.public_note, u.first_name, u.image AS host_image, u.created_at AS user_joined, co.start_date AS date_booked, co.guests
FROM charge_reviews cr
JOIN charge_option_references co ON cr.charge_id = co.id
JOIN users u ON co.user_id = u.user_id
WHERE co.option_user_id = $1 AND cr.is_published = true
ORDER BY co.start_date DESC
LIMIT $2
OFFSET $3
`

type ListChargeOptionReviewIndexParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

type ListChargeOptionReviewIndexRow struct {
	General       int32     `json:"general"`
	Environment   int32     `json:"environment"`
	Accuracy      int32     `json:"accuracy"`
	CheckIn       int32     `json:"check_in"`
	Communication int32     `json:"communication"`
	Location      int32     `json:"location"`
	PublicNote    string    `json:"public_note"`
	FirstName     string    `json:"first_name"`
	HostImage     string    `json:"host_image"`
	UserJoined    time.Time `json:"user_joined"`
	DateBooked    time.Time `json:"date_booked"`
	Guests        []string  `json:"guests"`
}

func (q *Queries) ListChargeOptionReviewIndex(ctx context.Context, arg ListChargeOptionReviewIndexParams) ([]ListChargeOptionReviewIndexRow, error) {
	rows, err := q.db.Query(ctx, listChargeOptionReviewIndex, arg.OptionUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeOptionReviewIndexRow{}
	for rows.Next() {
		var i ListChargeOptionReviewIndexRow
		if err := rows.Scan(
			&i.General,
			&i.Environment,
			&i.Accuracy,
			&i.CheckIn,
			&i.Communication,
			&i.Location,
			&i.PublicNote,
			&i.FirstName,
			&i.HostImage,
			&i.UserJoined,
			&i.DateBooked,
			&i.Guests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeChargeReview = `-- name: RemoveChargeReview :exec
DELETE FROM charge_reviews
WHERE charge_id = $1
`

func (q *Queries) RemoveChargeReview(ctx context.Context, chargeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeChargeReview, chargeID)
	return err
}

const removeChargeReviewTwo = `-- name: RemoveChargeReviewTwo :exec
DELETE FROM charge_reviews
WHERE charge_id = $1
`

func (q *Queries) RemoveChargeReviewTwo(ctx context.Context, chargeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeChargeReviewTwo, chargeID)
	return err
}

const updateChargeReview = `-- name: UpdateChargeReview :one
UPDATE charge_reviews
SET 
    environment = COALESCE($2, environment),
    accuracy = COALESCE($3, accuracy),
    check_in = COALESCE($4, check_in),
    communication = COALESCE($5, communication),
    location = COALESCE($6, location),
    status = COALESCE($7, status),
    private_note = COALESCE($8, private_note),
    current_state = COALESCE($9, current_state),
    previous_state = COALESCE($10, previous_state),
    public_note = COALESCE($11, public_note),
    stay_clean = COALESCE($12, stay_clean),
    stay_comfort = COALESCE($13, stay_comfort),
    host_review = COALESCE($14, host_review),
    amenities = COALESCE($15, amenities),
    is_published = COALESCE($16, is_published),
    updated_at = NOW()
WHERE charge_id = $1 AND is_published = false
RETURNING charge_id, type, general, environment, accuracy, check_in, communication, is_published, location, current_state, previous_state, status, private_note, public_note, stay_clean, stay_comfort, host_review, amenities, created_at, updated_at
`

type UpdateChargeReviewParams struct {
	ChargeID      uuid.UUID   `json:"charge_id"`
	Environment   pgtype.Int4 `json:"environment"`
	Accuracy      pgtype.Int4 `json:"accuracy"`
	CheckIn       pgtype.Int4 `json:"check_in"`
	Communication pgtype.Int4 `json:"communication"`
	Location      pgtype.Int4 `json:"location"`
	Status        pgtype.Text `json:"status"`
	PrivateNote   pgtype.Text `json:"private_note"`
	CurrentState  pgtype.Text `json:"current_state"`
	PreviousState pgtype.Text `json:"previous_state"`
	PublicNote    pgtype.Text `json:"public_note"`
	StayClean     pgtype.Text `json:"stay_clean"`
	StayComfort   pgtype.Text `json:"stay_comfort"`
	HostReview    pgtype.Text `json:"host_review"`
	Amenities     []string    `json:"amenities"`
	IsPublished   pgtype.Bool `json:"is_published"`
}

func (q *Queries) UpdateChargeReview(ctx context.Context, arg UpdateChargeReviewParams) (ChargeReview, error) {
	row := q.db.QueryRow(ctx, updateChargeReview,
		arg.ChargeID,
		arg.Environment,
		arg.Accuracy,
		arg.CheckIn,
		arg.Communication,
		arg.Location,
		arg.Status,
		arg.PrivateNote,
		arg.CurrentState,
		arg.PreviousState,
		arg.PublicNote,
		arg.StayClean,
		arg.StayComfort,
		arg.HostReview,
		arg.Amenities,
		arg.IsPublished,
	)
	var i ChargeReview
	err := row.Scan(
		&i.ChargeID,
		&i.Type,
		&i.General,
		&i.Environment,
		&i.Accuracy,
		&i.CheckIn,
		&i.Communication,
		&i.IsPublished,
		&i.Location,
		&i.CurrentState,
		&i.PreviousState,
		&i.Status,
		&i.PrivateNote,
		&i.PublicNote,
		&i.StayClean,
		&i.StayComfort,
		&i.HostReview,
		&i.Amenities,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChargeReviewAmenities = `-- name: UpdateChargeReviewAmenities :one
UPDATE charge_reviews
SET 
    amenities = $1,
    updated_at = NOW()
WHERE charge_id = $2 AND is_published = false
RETURNING charge_id, type, general, environment, accuracy, check_in, communication, is_published, location, current_state, previous_state, status, private_note, public_note, stay_clean, stay_comfort, host_review, amenities, created_at, updated_at
`

type UpdateChargeReviewAmenitiesParams struct {
	Amenities []string  `json:"amenities"`
	ChargeID  uuid.UUID `json:"charge_id"`
}

func (q *Queries) UpdateChargeReviewAmenities(ctx context.Context, arg UpdateChargeReviewAmenitiesParams) (ChargeReview, error) {
	row := q.db.QueryRow(ctx, updateChargeReviewAmenities, arg.Amenities, arg.ChargeID)
	var i ChargeReview
	err := row.Scan(
		&i.ChargeID,
		&i.Type,
		&i.General,
		&i.Environment,
		&i.Accuracy,
		&i.CheckIn,
		&i.Communication,
		&i.IsPublished,
		&i.Location,
		&i.CurrentState,
		&i.PreviousState,
		&i.Status,
		&i.PrivateNote,
		&i.PublicNote,
		&i.StayClean,
		&i.StayComfort,
		&i.HostReview,
		&i.Amenities,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChargeReviewAmenitiesTwo = `-- name: UpdateChargeReviewAmenitiesTwo :one
UPDATE charge_reviews
SET 
    amenities = $1,
    current_state = $2,
    previous_state = $3,
    updated_at = NOW()
WHERE charge_id = $4 AND is_published = false
RETURNING charge_id, type, general, environment, accuracy, check_in, communication, is_published, location, current_state, previous_state, status, private_note, public_note, stay_clean, stay_comfort, host_review, amenities, created_at, updated_at
`

type UpdateChargeReviewAmenitiesTwoParams struct {
	Amenities     []string  `json:"amenities"`
	CurrentState  string    `json:"current_state"`
	PreviousState string    `json:"previous_state"`
	ChargeID      uuid.UUID `json:"charge_id"`
}

func (q *Queries) UpdateChargeReviewAmenitiesTwo(ctx context.Context, arg UpdateChargeReviewAmenitiesTwoParams) (ChargeReview, error) {
	row := q.db.QueryRow(ctx, updateChargeReviewAmenitiesTwo,
		arg.Amenities,
		arg.CurrentState,
		arg.PreviousState,
		arg.ChargeID,
	)
	var i ChargeReview
	err := row.Scan(
		&i.ChargeID,
		&i.Type,
		&i.General,
		&i.Environment,
		&i.Accuracy,
		&i.CheckIn,
		&i.Communication,
		&i.IsPublished,
		&i.Location,
		&i.CurrentState,
		&i.PreviousState,
		&i.Status,
		&i.PrivateNote,
		&i.PublicNote,
		&i.StayClean,
		&i.StayComfort,
		&i.HostReview,
		&i.Amenities,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateChargeReviewPublished = `-- name: UpdateChargeReviewPublished :exec
UPDATE charge_reviews
SET 
    is_published = $1,
    updated_at = NOW()
WHERE is_published = false AND status <> 'started'
`

func (q *Queries) UpdateChargeReviewPublished(ctx context.Context, isPublished bool) error {
	_, err := q.db.Exec(ctx, updateChargeReviewPublished, isPublished)
	return err
}
