// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: event_date_times_two.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const listAllEventDateTimeInsight = `-- name: ListAllEventDateTimeInsight :many
SELECT
    edt.id AS event_date_time_id,
    edt.event_info_id,
    edt.start_date,
    edt.name,
    edt.publish_check_in_steps,
    edt.check_in_method,
    unnest(edt.event_dates)::VARCHAR AS event_date,
    edt.type,
    edt.is_active,
    edt.need_bands,
    edt.need_tickets,
    edt.absorb_band_charge,
    edt.status AS event_status,
    edt.note,
    edt.end_date,
    ei.sub_category_type,
    ei.event_type,
    os.status AS option_status,
    edi.time_zone,
    edi.start_time,
    edi.end_time,
    od.host_name_option,
    oi.id AS option_id,
    oi.co_host_id,
    op.main_image,
    CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.scan_code::boolean
        WHEN oi.host_id = $2 THEN true
        ELSE false -- Optional: Handle other cases if needed
    END AS scan_code,
    CASE WHEN och_subquery.reservations IS NOT NULL THEN och_subquery.scan_code::boolean
        WHEN oi.host_id = $2 THEN true
        ELSE false -- Optional: Handle other cases if needed
    END AS reservations,
    CASE WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
        WHEN oi.host_id = $2 THEN 'main_host'
        ELSE 'none' -- Optional: Handle other cases if needed
    END AS host_type
FROM
    event_date_times AS edt
JOIN event_infos AS ei ON edt.event_info_id = ei.option_id
JOIN event_date_details AS edi ON edt.id = edi.event_date_time_id
JOIN options_infos AS oi ON oi.id = ei.option_id
JOIN options_info_photos op ON op.option_id = oi.id
JOIN options_info_details AS od ON od.option_id = oi.id
JOIN options_infos_status AS os ON os.option_id = oi.id 
LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations, insights
    FROM option_co_hosts
    WHERE co_user_id = $1
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE
    (oi.host_id = $2 OR och_subquery.option_id IS NOT NULL)
    AND (oi.host_id = $2 OR och_subquery.insights = true) AND (
        (edt.type = 'recurring' AND oi.is_complete = true AND oi.is_active = true AND edt.is_active = true)
        OR
        (edt.type = 'single' AND oi.is_complete = true AND oi.is_active = true AND edt.is_active = true)
    )
    LIMIT $3
    OFFSET $4
`

type ListAllEventDateTimeInsightParams struct {
	CoUserID string    `json:"co_user_id"`
	HostID   uuid.UUID `json:"host_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListAllEventDateTimeInsightRow struct {
	EventDateTimeID     uuid.UUID `json:"event_date_time_id"`
	EventInfoID         uuid.UUID `json:"event_info_id"`
	StartDate           time.Time `json:"start_date"`
	Name                string    `json:"name"`
	PublishCheckInSteps bool      `json:"publish_check_in_steps"`
	CheckInMethod       string    `json:"check_in_method"`
	EventDate           string    `json:"event_date"`
	Type                string    `json:"type"`
	IsActive            bool      `json:"is_active"`
	NeedBands           bool      `json:"need_bands"`
	NeedTickets         bool      `json:"need_tickets"`
	AbsorbBandCharge    bool      `json:"absorb_band_charge"`
	EventStatus         string    `json:"event_status"`
	Note                string    `json:"note"`
	EndDate             time.Time `json:"end_date"`
	SubCategoryType     string    `json:"sub_category_type"`
	EventType           string    `json:"event_type"`
	OptionStatus        string    `json:"option_status"`
	TimeZone            string    `json:"time_zone"`
	StartTime           string    `json:"start_time"`
	EndTime             string    `json:"end_time"`
	HostNameOption      string    `json:"host_name_option"`
	OptionID            uuid.UUID `json:"option_id"`
	CoHostID            uuid.UUID `json:"co_host_id"`
	MainImage           string    `json:"main_image"`
	ScanCode            bool      `json:"scan_code"`
	Reservations        bool      `json:"reservations"`
	HostType            string    `json:"host_type"`
}

func (q *Queries) ListAllEventDateTimeInsight(ctx context.Context, arg ListAllEventDateTimeInsightParams) ([]ListAllEventDateTimeInsightRow, error) {
	rows, err := q.db.Query(ctx, listAllEventDateTimeInsight,
		arg.CoUserID,
		arg.HostID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllEventDateTimeInsightRow{}
	for rows.Next() {
		var i ListAllEventDateTimeInsightRow
		if err := rows.Scan(
			&i.EventDateTimeID,
			&i.EventInfoID,
			&i.StartDate,
			&i.Name,
			&i.PublishCheckInSteps,
			&i.CheckInMethod,
			&i.EventDate,
			&i.Type,
			&i.IsActive,
			&i.NeedBands,
			&i.NeedTickets,
			&i.AbsorbBandCharge,
			&i.EventStatus,
			&i.Note,
			&i.EndDate,
			&i.SubCategoryType,
			&i.EventType,
			&i.OptionStatus,
			&i.TimeZone,
			&i.StartTime,
			&i.EndTime,
			&i.HostNameOption,
			&i.OptionID,
			&i.CoHostID,
			&i.MainImage,
			&i.ScanCode,
			&i.Reservations,
			&i.HostType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTimeInsight = `-- name: ListEventDateTimeInsight :many
SELECT
    edt.id AS event_date_time_id,
    edt.event_info_id,
    edt.start_date,
    edt.name,
    edt.publish_check_in_steps,
    edt.check_in_method,
    unnest(edt.event_dates)::VARCHAR AS event_date,
    edt.type,
    edt.is_active,
    edt.need_bands,
    edt.need_tickets,
    edt.absorb_band_charge,
    edt.status AS event_status,
    edt.note,
    edt.end_date,
    ei.sub_category_type,
    ei.event_type,
    os.status AS option_status,
    edi.time_zone,
    edi.start_time,
    edi.end_time,
    od.host_name_option,
    oi.id AS option_id,
    oi.co_host_id,
    op.main_image,
    CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.scan_code::boolean
        WHEN oi.host_id = $2 THEN true
        ELSE false -- Optional: Handle other cases if needed
    END AS scan_code,
    CASE WHEN och_subquery.reservations IS NOT NULL THEN och_subquery.scan_code::boolean
        WHEN oi.host_id = $2 THEN true
        ELSE false -- Optional: Handle other cases if needed
    END AS reservations,
    CASE WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
        WHEN oi.host_id = $2 THEN 'main_host'
        ELSE 'none' -- Optional: Handle other cases if needed
    END AS host_type
FROM
    event_date_times AS edt
JOIN event_infos AS ei ON edt.event_info_id = ei.option_id
JOIN event_date_details AS edi ON edt.id = edi.event_date_time_id
JOIN options_infos AS oi ON oi.id = ei.option_id
JOIN options_info_photos op ON op.option_id = oi.id
JOIN options_info_details AS od ON od.option_id = oi.id
JOIN options_infos_status AS os ON os.option_id = oi.id 
LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations, insights
    FROM option_co_hosts
    WHERE co_user_id = $1
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE
    (oi.host_id = $2 OR och_subquery.option_id IS NOT NULL)
    AND (oi.host_id = $2 OR och_subquery.insights = true) AND oi.option_user_id = $5 AND (
        (edt.type = 'recurring' AND oi.is_complete = true AND oi.is_active = true AND edt.is_active = true)
        OR
        (edt.type = 'single' AND oi.is_complete = true AND oi.is_active = true AND edt.is_active = true)
    )
    LIMIT $3
    OFFSET $4
`

type ListEventDateTimeInsightParams struct {
	CoUserID     string    `json:"co_user_id"`
	HostID       uuid.UUID `json:"host_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
	OptionUserID uuid.UUID `json:"option_user_id"`
}

type ListEventDateTimeInsightRow struct {
	EventDateTimeID     uuid.UUID `json:"event_date_time_id"`
	EventInfoID         uuid.UUID `json:"event_info_id"`
	StartDate           time.Time `json:"start_date"`
	Name                string    `json:"name"`
	PublishCheckInSteps bool      `json:"publish_check_in_steps"`
	CheckInMethod       string    `json:"check_in_method"`
	EventDate           string    `json:"event_date"`
	Type                string    `json:"type"`
	IsActive            bool      `json:"is_active"`
	NeedBands           bool      `json:"need_bands"`
	NeedTickets         bool      `json:"need_tickets"`
	AbsorbBandCharge    bool      `json:"absorb_band_charge"`
	EventStatus         string    `json:"event_status"`
	Note                string    `json:"note"`
	EndDate             time.Time `json:"end_date"`
	SubCategoryType     string    `json:"sub_category_type"`
	EventType           string    `json:"event_type"`
	OptionStatus        string    `json:"option_status"`
	TimeZone            string    `json:"time_zone"`
	StartTime           string    `json:"start_time"`
	EndTime             string    `json:"end_time"`
	HostNameOption      string    `json:"host_name_option"`
	OptionID            uuid.UUID `json:"option_id"`
	CoHostID            uuid.UUID `json:"co_host_id"`
	MainImage           string    `json:"main_image"`
	ScanCode            bool      `json:"scan_code"`
	Reservations        bool      `json:"reservations"`
	HostType            string    `json:"host_type"`
}

func (q *Queries) ListEventDateTimeInsight(ctx context.Context, arg ListEventDateTimeInsightParams) ([]ListEventDateTimeInsightRow, error) {
	rows, err := q.db.Query(ctx, listEventDateTimeInsight,
		arg.CoUserID,
		arg.HostID,
		arg.Limit,
		arg.Offset,
		arg.OptionUserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventDateTimeInsightRow{}
	for rows.Next() {
		var i ListEventDateTimeInsightRow
		if err := rows.Scan(
			&i.EventDateTimeID,
			&i.EventInfoID,
			&i.StartDate,
			&i.Name,
			&i.PublishCheckInSteps,
			&i.CheckInMethod,
			&i.EventDate,
			&i.Type,
			&i.IsActive,
			&i.NeedBands,
			&i.NeedTickets,
			&i.AbsorbBandCharge,
			&i.EventStatus,
			&i.Note,
			&i.EndDate,
			&i.SubCategoryType,
			&i.EventType,
			&i.OptionStatus,
			&i.TimeZone,
			&i.StartTime,
			&i.EndTime,
			&i.HostNameOption,
			&i.OptionID,
			&i.CoHostID,
			&i.MainImage,
			&i.ScanCode,
			&i.Reservations,
			&i.HostType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
