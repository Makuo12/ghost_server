// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: refunds.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRefund = `-- name: CountRefund :one
SELECT
    Count(*)
FROM refunds AS re
JOIN main_payouts AS mp ON mp.charge_id = re.charge_id
LEFT JOIN charge_option_references AS co
    ON mp.Type = 'charge_option_reference'
    AND re.charge_id = co.id
LEFT JOIN charge_ticket_references AS ct
    ON mp.Type = 'charge_ticket_references'
    AND re.charge_id = ct.id
LEFT JOIN charge_date_references AS cd
    ON mp.Type = 'charge_ticket_references'
    AND ct.charge_date_id = cd.id
LEFT JOIN charge_event_references AS ce
    ON mp.Type = 'charge_ticket_references'
    AND cd.charge_event_id = ce.id
LEFT JOIN options_infos AS oi
    ON (mp.Type = 'charge_option_reference' AND co.option_user_id = oi.option_user_id)
    OR (mp.Type = 'charge_ticket_references' AND ce.option_user_id = oi.option_user_id)
LEFT JOIN options_info_details AS od ON oi.id = od.option_id
LEFT JOIN users AS u ON oi.host_id = u.id
WHERE re.is_complete = $1 AND re.user_id = $2
`

type CountRefundParams struct {
	RefundComplete bool      `json:"refund_complete"`
	UID            uuid.UUID `json:"u_id"`
}

func (q *Queries) CountRefund(ctx context.Context, arg CountRefundParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRefund, arg.RefundComplete, arg.UID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRefund = `-- name: CreateRefund :one
INSERT INTO refunds (
    charge_id,
    reference,
    send_medium,
    user_id,
    amount,
    amount_payed
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING charge_id, reference, send_medium, amount, user_id, amount_payed, time_paid, is_complete, created_at, updated_at
`

type CreateRefundParams struct {
	ChargeID    uuid.UUID `json:"charge_id"`
	Reference   string    `json:"reference"`
	SendMedium  string    `json:"send_medium"`
	UserID      uuid.UUID `json:"user_id"`
	Amount      int64     `json:"amount"`
	AmountPayed int64     `json:"amount_payed"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (Refund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.ChargeID,
		arg.Reference,
		arg.SendMedium,
		arg.UserID,
		arg.Amount,
		arg.AmountPayed,
	)
	var i Refund
	err := row.Scan(
		&i.ChargeID,
		&i.Reference,
		&i.SendMedium,
		&i.Amount,
		&i.UserID,
		&i.AmountPayed,
		&i.TimePaid,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRefund = `-- name: ListRefund :many
SELECT

    re.amount, re.time_paid, od.host_name_option, oi.main_option_type, u.first_name AS host_name, ct.grade, co.cancelled AS option_cancelled, ct.cancelled AS ticket_cancelled, co.end_date AS option_end_date, cd.end_date AS event_end_date, co.start_date AS option_start_date, cd.start_date AS event_start_date, mp.type, co.currency AS option_currency, ce.currency AS event_currency
FROM refunds AS re
JOIN main_payouts AS mp ON mp.charge_id = re.charge_id
LEFT JOIN charge_option_references AS co
    ON mp.Type = 'charge_option_reference'
    AND re.charge_id = co.id
LEFT JOIN charge_ticket_references AS ct
    ON mp.Type = 'charge_ticket_references'
    AND re.charge_id = ct.id
LEFT JOIN charge_date_references AS cd
    ON mp.Type = 'charge_ticket_references'
    AND ct.charge_date_id = cd.id
LEFT JOIN charge_event_references AS ce
    ON mp.Type = 'charge_ticket_references'
    AND cd.charge_event_id = ce.id
LEFT JOIN options_infos AS oi
    ON (mp.Type = 'charge_option_reference' AND co.option_user_id = oi.option_user_id)
    OR (mp.Type = 'charge_ticket_references' AND ce.option_user_id = oi.option_user_id)
LEFT JOIN options_info_details AS od ON oi.id = od.option_id
LEFT JOIN users AS u ON oi.host_id = u.id
WHERE re.is_complete = $3 AND re.user_id = $4
LIMIT $1
OFFSET $2
`

type ListRefundParams struct {
	Limit            int32     `json:"limit"`
	Offset           int32     `json:"offset"`
	PayoutIsComplete bool      `json:"payout_is_complete"`
	UID              uuid.UUID `json:"u_id"`
}

type ListRefundRow struct {
	Amount          int64       `json:"amount"`
	TimePaid        time.Time   `json:"time_paid"`
	HostNameOption  pgtype.Text `json:"host_name_option"`
	MainOptionType  pgtype.Text `json:"main_option_type"`
	HostName        pgtype.Text `json:"host_name"`
	Grade           pgtype.Text `json:"grade"`
	OptionCancelled pgtype.Bool `json:"option_cancelled"`
	TicketCancelled pgtype.Bool `json:"ticket_cancelled"`
	OptionEndDate   pgtype.Date `json:"option_end_date"`
	EventEndDate    pgtype.Date `json:"event_end_date"`
	OptionStartDate pgtype.Date `json:"option_start_date"`
	EventStartDate  pgtype.Date `json:"event_start_date"`
	Type            string      `json:"type"`
	OptionCurrency  pgtype.Text `json:"option_currency"`
	EventCurrency   pgtype.Text `json:"event_currency"`
}

func (q *Queries) ListRefund(ctx context.Context, arg ListRefundParams) ([]ListRefundRow, error) {
	rows, err := q.db.Query(ctx, listRefund,
		arg.Limit,
		arg.Offset,
		arg.PayoutIsComplete,
		arg.UID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRefundRow{}
	for rows.Next() {
		var i ListRefundRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.HostNameOption,
			&i.MainOptionType,
			&i.HostName,
			&i.Grade,
			&i.OptionCancelled,
			&i.TicketCancelled,
			&i.OptionEndDate,
			&i.EventEndDate,
			&i.OptionStartDate,
			&i.EventStartDate,
			&i.Type,
			&i.OptionCurrency,
			&i.EventCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRefund = `-- name: RemoveRefund :exec
DELETE FROM refunds WHERE charge_id = $1
`

func (q *Queries) RemoveRefund(ctx context.Context, chargeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeRefund, chargeID)
	return err
}

const updateRefund = `-- name: UpdateRefund :one
UPDATE refunds
SET is_complete = $1,
    time_paid = $2,
    updated_at = NOW()
WHERE reference = $3
RETURNING charge_id, reference, send_medium, amount, user_id, amount_payed, time_paid, is_complete, created_at, updated_at
`

type UpdateRefundParams struct {
	IsComplete bool      `json:"is_complete"`
	TimePaid   time.Time `json:"time_paid"`
	Reference  string    `json:"reference"`
}

func (q *Queries) UpdateRefund(ctx context.Context, arg UpdateRefundParams) (Refund, error) {
	row := q.db.QueryRow(ctx, updateRefund, arg.IsComplete, arg.TimePaid, arg.Reference)
	var i Refund
	err := row.Scan(
		&i.ChargeID,
		&i.Reference,
		&i.SendMedium,
		&i.Amount,
		&i.UserID,
		&i.AmountPayed,
		&i.TimePaid,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
