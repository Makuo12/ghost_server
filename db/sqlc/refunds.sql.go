// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: refunds.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRefund = `-- name: CountRefund :one
SELECT
    Count(*)
FROM refunds AS re
LEFT JOIN main_payouts AS mp ON mp.charge_id = re.charge_id
LEFT JOIN charge_option_references AS co
    ON mp.Type = 'charge_option_reference'
    AND re.charge_id = co.id
 LEFT JOIN charge_references AS cr
    ON mp.Type = 'charge_reference'
    AND re.charge_id = cr.id
LEFT JOIN charge_ticket_references AS ct
    ON mp.Type = 'charge_ticket_references'
    AND re.charge_id = ct.id
LEFT JOIN charge_date_references AS cd
    ON mp.Type = 'charge_ticket_references'
    AND ct.charge_date_id = cd.id
LEFT JOIN charge_event_references AS ce
    ON mp.Type = 'charge_ticket_references'
    AND cd.charge_event_id = ce.id
LEFT JOIN options_infos AS oi
    ON (mp.Type = 'charge_option_reference' AND co.option_user_id = oi.option_user_id)
    OR (mp.Type = 'charge_ticket_references' AND ce.option_user_id = oi.option_user_id)
LEFT JOIN options_info_details AS od ON oi.id = od.option_id
LEFT JOIN users AS u ON oi.host_id = u.id
WHERE re.is_complete = $1 AND re.user_id = $2
`

type CountRefundParams struct {
	RefundComplete bool      `json:"refund_complete"`
	UID            uuid.UUID `json:"u_id"`
}

func (q *Queries) CountRefund(ctx context.Context, arg CountRefundParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRefund, arg.RefundComplete, arg.UID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRefund = `-- name: CreateRefund :one
INSERT INTO refunds (
    charge_id,
    reference,
    send_medium,
    user_id,
    amount,
    amount_payed,
    refund_id
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING charge_id, reference, send_medium, amount, user_id, refund_id, amount_payed, time_paid, is_complete, created_at, updated_at
`

type CreateRefundParams struct {
	ChargeID    uuid.UUID `json:"charge_id"`
	Reference   string    `json:"reference"`
	SendMedium  string    `json:"send_medium"`
	UserID      uuid.UUID `json:"user_id"`
	Amount      int64     `json:"amount"`
	AmountPayed int64     `json:"amount_payed"`
	RefundID    string    `json:"refund_id"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (Refund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.ChargeID,
		arg.Reference,
		arg.SendMedium,
		arg.UserID,
		arg.Amount,
		arg.AmountPayed,
		arg.RefundID,
	)
	var i Refund
	err := row.Scan(
		&i.ChargeID,
		&i.Reference,
		&i.SendMedium,
		&i.Amount,
		&i.UserID,
		&i.RefundID,
		&i.AmountPayed,
		&i.TimePaid,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRefund = `-- name: ListRefund :many
SELECT
    re.amount, re.time_paid, od.host_name_option, oi.main_option_type, u.first_name AS host_name, ct.grade, co.cancelled AS option_cancelled, ct.cancelled AS ticket_cancelled, co.end_date AS option_end_date, cd.end_date AS event_end_date, co.start_date AS option_start_date, cd.start_date AS event_start_date, mp.type, co.currency AS option_currency, ce.currency AS event_currency, cr.currency AS charge_currency, cr.charge AS charge_amount, cr.created_at AS charge_created_at
FROM refunds AS re
LEFT JOIN main_payouts AS mp ON mp.charge_id = re.charge_id
LEFT JOIN charge_option_references AS co
    ON mp.Type = 'charge_option_reference'
    AND re.charge_id = co.id
LEFT JOIN charge_references AS cr
    ON mp.Type = 'charge_reference'
    AND re.charge_id = cr.id
LEFT JOIN charge_ticket_references AS ct
    ON mp.Type = 'charge_ticket_references'
    AND re.charge_id = ct.id
LEFT JOIN charge_date_references AS cd
    ON mp.Type = 'charge_ticket_references'
    AND ct.charge_date_id = cd.id
LEFT JOIN charge_event_references AS ce
    ON mp.Type = 'charge_ticket_references'
    AND cd.charge_event_id = ce.id
LEFT JOIN options_infos AS oi
    ON (mp.Type = 'charge_option_reference' AND co.option_user_id = oi.option_user_id)
    OR (mp.Type = 'charge_ticket_references' AND ce.option_user_id = oi.option_user_id)
LEFT JOIN options_info_details AS od ON oi.id = od.option_id
LEFT JOIN users AS u ON oi.host_id = u.id
WHERE re.is_complete = $3 AND re.user_id = $4
LIMIT $1
OFFSET $2
`

type ListRefundParams struct {
	Limit            int32     `json:"limit"`
	Offset           int32     `json:"offset"`
	PayoutIsComplete bool      `json:"payout_is_complete"`
	UID              uuid.UUID `json:"u_id"`
}

type ListRefundRow struct {
	Amount          int64              `json:"amount"`
	TimePaid        time.Time          `json:"time_paid"`
	HostNameOption  pgtype.Text        `json:"host_name_option"`
	MainOptionType  pgtype.Text        `json:"main_option_type"`
	HostName        pgtype.Text        `json:"host_name"`
	Grade           pgtype.Text        `json:"grade"`
	OptionCancelled pgtype.Bool        `json:"option_cancelled"`
	TicketCancelled pgtype.Bool        `json:"ticket_cancelled"`
	OptionEndDate   pgtype.Date        `json:"option_end_date"`
	EventEndDate    pgtype.Date        `json:"event_end_date"`
	OptionStartDate pgtype.Date        `json:"option_start_date"`
	EventStartDate  pgtype.Date        `json:"event_start_date"`
	Type            pgtype.Text        `json:"type"`
	OptionCurrency  pgtype.Text        `json:"option_currency"`
	EventCurrency   pgtype.Text        `json:"event_currency"`
	ChargeCurrency  pgtype.Text        `json:"charge_currency"`
	ChargeAmount    pgtype.Int8        `json:"charge_amount"`
	ChargeCreatedAt pgtype.Timestamptz `json:"charge_created_at"`
}

func (q *Queries) ListRefund(ctx context.Context, arg ListRefundParams) ([]ListRefundRow, error) {
	rows, err := q.db.Query(ctx, listRefund,
		arg.Limit,
		arg.Offset,
		arg.PayoutIsComplete,
		arg.UID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRefundRow{}
	for rows.Next() {
		var i ListRefundRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.HostNameOption,
			&i.MainOptionType,
			&i.HostName,
			&i.Grade,
			&i.OptionCancelled,
			&i.TicketCancelled,
			&i.OptionEndDate,
			&i.EventEndDate,
			&i.OptionStartDate,
			&i.EventStartDate,
			&i.Type,
			&i.OptionCurrency,
			&i.EventCurrency,
			&i.ChargeCurrency,
			&i.ChargeAmount,
			&i.ChargeCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRefund = `-- name: RemoveRefund :exec
DELETE FROM refunds WHERE charge_id = $1
`

func (q *Queries) RemoveRefund(ctx context.Context, chargeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeRefund, chargeID)
	return err
}

const updateRefund = `-- name: UpdateRefund :one
UPDATE refunds
SET 
    is_complete = COALESCE($2, is_complete),
    time_paid = COALESCE($3, time_paid),
    amount_payed = COALESCE($4, amount_payed),
    refund_id = COALESCE($5, refund_id),
    updated_at = NOW()
WHERE reference = $1
RETURNING charge_id, reference, send_medium, amount, user_id, refund_id, amount_payed, time_paid, is_complete, created_at, updated_at
`

type UpdateRefundParams struct {
	Reference   string             `json:"reference"`
	IsComplete  pgtype.Bool        `json:"is_complete"`
	TimePaid    pgtype.Timestamptz `json:"time_paid"`
	AmountPayed pgtype.Int8        `json:"amount_payed"`
	RefundID    pgtype.Text        `json:"refund_id"`
}

func (q *Queries) UpdateRefund(ctx context.Context, arg UpdateRefundParams) (Refund, error) {
	row := q.db.QueryRow(ctx, updateRefund,
		arg.Reference,
		arg.IsComplete,
		arg.TimePaid,
		arg.AmountPayed,
		arg.RefundID,
	)
	var i Refund
	err := row.Scan(
		&i.ChargeID,
		&i.Reference,
		&i.SendMedium,
		&i.Amount,
		&i.UserID,
		&i.RefundID,
		&i.AmountPayed,
		&i.TimePaid,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
