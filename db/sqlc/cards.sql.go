// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: cards.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createCard = `-- name: CreateCard :one
INSERT INTO cards (
    user_id,
    email,
    authorization_code,
    card_type,
    last4,
    exp_month,
    exp_year,
    bank,
    currency,
    country_code,
    reusable,
    channel,
    card_signature,
    account_name,
    bin
    )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
    )
RETURNING id, user_id, email, currency, authorization_code, card_type, last4, exp_month, exp_year, bank, country_code, reusable, channel, card_signature, account_name, bin, created_at, updated_at
`

type CreateCardParams struct {
	UserID            uuid.UUID `json:"user_id"`
	Email             string    `json:"email"`
	AuthorizationCode string    `json:"authorization_code"`
	CardType          string    `json:"card_type"`
	Last4             string    `json:"last4"`
	ExpMonth          string    `json:"exp_month"`
	ExpYear           string    `json:"exp_year"`
	Bank              string    `json:"bank"`
	Currency          string    `json:"currency"`
	CountryCode       string    `json:"country_code"`
	Reusable          bool      `json:"reusable"`
	Channel           string    `json:"channel"`
	CardSignature     string    `json:"card_signature"`
	AccountName       string    `json:"account_name"`
	Bin               string    `json:"bin"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (Card, error) {
	row := q.db.QueryRow(ctx, createCard,
		arg.UserID,
		arg.Email,
		arg.AuthorizationCode,
		arg.CardType,
		arg.Last4,
		arg.ExpMonth,
		arg.ExpYear,
		arg.Bank,
		arg.Currency,
		arg.CountryCode,
		arg.Reusable,
		arg.Channel,
		arg.CardSignature,
		arg.AccountName,
		arg.Bin,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.Currency,
		&i.AuthorizationCode,
		&i.CardType,
		&i.Last4,
		&i.ExpMonth,
		&i.ExpYear,
		&i.Bank,
		&i.CountryCode,
		&i.Reusable,
		&i.Channel,
		&i.CardSignature,
		&i.AccountName,
		&i.Bin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCard = `-- name: GetCard :one
SELECT id, user_id, email, currency, authorization_code, card_type, last4, exp_month, exp_year, bank, country_code, reusable, channel, card_signature, account_name, bin, created_at, updated_at
FROM cards
WHERE id = $1 AND user_id = $2
LIMIT 1
`

type GetCardParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetCard(ctx context.Context, arg GetCardParams) (Card, error) {
	row := q.db.QueryRow(ctx, getCard, arg.ID, arg.UserID)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.Currency,
		&i.AuthorizationCode,
		&i.CardType,
		&i.Last4,
		&i.ExpMonth,
		&i.ExpYear,
		&i.Bank,
		&i.CountryCode,
		&i.Reusable,
		&i.Channel,
		&i.CardSignature,
		&i.AccountName,
		&i.Bin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCardAny = `-- name: GetCardAny :one
SELECT id, user_id, email, currency, authorization_code, card_type, last4, exp_month, exp_year, bank, country_code, reusable, channel, card_signature, account_name, bin, created_at, updated_at
FROM cards
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) GetCardAny(ctx context.Context, userID uuid.UUID) (Card, error) {
	row := q.db.QueryRow(ctx, getCardAny, userID)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.Currency,
		&i.AuthorizationCode,
		&i.CardType,
		&i.Last4,
		&i.ExpMonth,
		&i.ExpYear,
		&i.Bank,
		&i.CountryCode,
		&i.Reusable,
		&i.Channel,
		&i.CardSignature,
		&i.AccountName,
		&i.Bin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCardByLast4 = `-- name: GetCardByLast4 :one
SELECT id
FROM cards
WHERE last4 = $1 AND currency = $2 AND user_id = $3
LIMIT 1
`

type GetCardByLast4Params struct {
	Last4    string    `json:"last4"`
	Currency string    `json:"currency"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) GetCardByLast4(ctx context.Context, arg GetCardByLast4Params) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getCardByLast4, arg.Last4, arg.Currency, arg.UserID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getCardCount = `-- name: GetCardCount :one
SELECT COUNT(*)
FROM cards
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) GetCardCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getCardCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listCard = `-- name: ListCard :many
SELECT id, user_id, email, currency, authorization_code, card_type, last4, exp_month, exp_year, bank, country_code, reusable, channel, card_signature, account_name, bin, created_at, updated_at FROM cards
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCard(ctx context.Context, userID uuid.UUID) ([]Card, error) {
	rows, err := q.db.Query(ctx, listCard, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Card{}
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.Currency,
			&i.AuthorizationCode,
			&i.CardType,
			&i.Last4,
			&i.ExpMonth,
			&i.ExpYear,
			&i.Bank,
			&i.CountryCode,
			&i.Reusable,
			&i.Channel,
			&i.CardSignature,
			&i.AccountName,
			&i.Bin,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCard = `-- name: RemoveCard :exec
DELETE FROM cards
WHERE user_id = $1 AND id = $2
`

type RemoveCardParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) RemoveCard(ctx context.Context, arg RemoveCardParams) error {
	_, err := q.db.Exec(ctx, removeCard, arg.UserID, arg.ID)
	return err
}
