// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: options_infos.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOptionInfo = `-- name: CountOptionInfo :one
SELECT Count(*)
FROM options_infos oi
   JOIN options_info_details od on oi.id = od.option_id
   JOIN options_infos_status ois on ois.option_id = od.option_id
   JOIN complete_option_info coi on oi.id = coi.option_id
   LEFT JOIN options_info_photos op on oi.id = op.option_id
   LEFT JOIN shortlets s on s.option_id = oi.id
   LEFT JOIN event_infos ei on ei.option_id = oi.id
   LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $1 OR och_subquery.option_id IS NOT NULL) AND oi.is_complete = $3  AND oi.is_active = $4 AND (ois.status = $5 OR ois.status = $6)
`

type CountOptionInfoParams struct {
	HostID          uuid.UUID `json:"host_id"`
	CoUserID        string    `json:"co_user_id"`
	IsComplete      bool      `json:"is_complete"`
	IsActive        bool      `json:"is_active"`
	OptionStatusOne string    `json:"option_status_one"`
	OptionStatusTwo string    `json:"option_status_two"`
}

func (q *Queries) CountOptionInfo(ctx context.Context, arg CountOptionInfoParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOptionInfo,
		arg.HostID,
		arg.CoUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.OptionStatusOne,
		arg.OptionStatusTwo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOptionInfo = `-- name: CreateOptionInfo :one
INSERT INTO options_infos (
      host_id,
      option_type,
      currency,
      option_img,
      main_option_type,
      primary_user_id,
      time_zone
   )
VALUES (
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7
   )
RETURNING id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, created_at, completed, updated_at
`

type CreateOptionInfoParams struct {
	HostID         uuid.UUID `json:"host_id"`
	OptionType     string    `json:"option_type"`
	Currency       string    `json:"currency"`
	OptionImg      string    `json:"option_img"`
	MainOptionType string    `json:"main_option_type"`
	PrimaryUserID  uuid.UUID `json:"primary_user_id"`
	TimeZone       string    `json:"time_zone"`
}

func (q *Queries) CreateOptionInfo(ctx context.Context, arg CreateOptionInfoParams) (OptionsInfo, error) {
	row := q.db.QueryRow(ctx, createOptionInfo,
		arg.HostID,
		arg.OptionType,
		arg.Currency,
		arg.OptionImg,
		arg.MainOptionType,
		arg.PrimaryUserID,
		arg.TimeZone,
	)
	var i OptionsInfo
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOptionInfo = `-- name: DeleteOptionInfo :exec
DELETE FROM options_infos
WHERE id = $1 AND host_id = $2
`

type DeleteOptionInfoParams struct {
	ID     uuid.UUID `json:"id"`
	HostID uuid.UUID `json:"host_id"`
}

func (q *Queries) DeleteOptionInfo(ctx context.Context, arg DeleteOptionInfoParams) error {
	_, err := q.db.Exec(ctx, deleteOptionInfo, arg.ID, arg.HostID)
	return err
}

const getEventCurrentOptionData = `-- name: GetEventCurrentOptionData :one
SELECT o_i.id,
   e_i.event_type,
   o_i.option_type,
   o_i.main_option_type,
   o_i.currency,
   o_i_d.host_name_option,
   o_i_p.cover_image
FROM options_infos o_i
   JOIN event_infos e_i on o_i.id = e_i.option_id
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
WHERE o_i.id = $1 AND o_i.is_complete = $2
`

type GetEventCurrentOptionDataParams struct {
	ID         uuid.UUID `json:"id"`
	IsComplete bool      `json:"is_complete"`
}

type GetEventCurrentOptionDataRow struct {
	ID             uuid.UUID `json:"id"`
	EventType      string    `json:"event_type"`
	OptionType     string    `json:"option_type"`
	MainOptionType string    `json:"main_option_type"`
	Currency       string    `json:"currency"`
	HostNameOption string    `json:"host_name_option"`
	CoverImage     string    `json:"cover_image"`
}

func (q *Queries) GetEventCurrentOptionData(ctx context.Context, arg GetEventCurrentOptionDataParams) (GetEventCurrentOptionDataRow, error) {
	row := q.db.QueryRow(ctx, getEventCurrentOptionData, arg.ID, arg.IsComplete)
	var i GetEventCurrentOptionDataRow
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.OptionType,
		&i.MainOptionType,
		&i.Currency,
		&i.HostNameOption,
		&i.CoverImage,
	)
	return i, err
}

const getEventInfoByUserID = `-- name: GetEventInfoByUserID :one
SELECT o_i.id, o_i.time_zone, c_p.type_one, c_p.type_two, o_q.organization_name, o_q.host_as_individual
FROM options_infos o_i
   JOIN cancel_policies c_p on o_i.id = c_p.option_id
   JOIN option_questions o_q on o_q.option_id = o_i.id
WHERE o_i.option_user_id=$1
`

type GetEventInfoByUserIDRow struct {
	ID               uuid.UUID `json:"id"`
	TimeZone         string    `json:"time_zone"`
	TypeOne          string    `json:"type_one"`
	TypeTwo          string    `json:"type_two"`
	OrganizationName string    `json:"organization_name"`
	HostAsIndividual bool      `json:"host_as_individual"`
}

func (q *Queries) GetEventInfoByUserID(ctx context.Context, optionUserID uuid.UUID) (GetEventInfoByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getEventInfoByUserID, optionUserID)
	var i GetEventInfoByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.TimeZone,
		&i.TypeOne,
		&i.TypeTwo,
		&i.OrganizationName,
		&i.HostAsIndividual,
	)
	return i, err
}

const getEventPublishData = `-- name: GetEventPublishData :one
SELECT o_i.id,
   e_i.event_type,
   o_i_d.host_name_option,
   o_i_d.des,
   o_i_p.cover_image
FROM options_infos o_i
   JOIN event_infos e_i on o_i.id = e_i.option_id
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
WHERE o_i.id = $1
`

type GetEventPublishDataRow struct {
	ID             uuid.UUID `json:"id"`
	EventType      string    `json:"event_type"`
	HostNameOption string    `json:"host_name_option"`
	Des            string    `json:"des"`
	CoverImage     string    `json:"cover_image"`
}

func (q *Queries) GetEventPublishData(ctx context.Context, id uuid.UUID) (GetEventPublishDataRow, error) {
	row := q.db.QueryRow(ctx, getEventPublishData, id)
	var i GetEventPublishDataRow
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.HostNameOption,
		&i.Des,
		&i.CoverImage,
	)
	return i, err
}

const getFirstOptionDate = `-- name: GetFirstOptionDate :one
SELECT created_at
FROM options_infos
WHERE host_id = $1 AND is_complete = $2 AND main_option_type = $3
ORDER BY created_at DESC
`

type GetFirstOptionDateParams struct {
	HostID         uuid.UUID `json:"host_id"`
	IsComplete     bool      `json:"is_complete"`
	MainOptionType string    `json:"main_option_type"`
}

func (q *Queries) GetFirstOptionDate(ctx context.Context, arg GetFirstOptionDateParams) (time.Time, error) {
	row := q.db.QueryRow(ctx, getFirstOptionDate, arg.HostID, arg.IsComplete, arg.MainOptionType)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const getHostOptionInfo = `-- name: GetHostOptionInfo :one
SELECT id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, created_at, completed, updated_at
FROM options_infos
WHERE host_id = $1 AND is_complete = $2
`

type GetHostOptionInfoParams struct {
	HostID     uuid.UUID `json:"host_id"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) GetHostOptionInfo(ctx context.Context, arg GetHostOptionInfoParams) (OptionsInfo, error) {
	row := q.db.QueryRow(ctx, getHostOptionInfo, arg.HostID, arg.IsComplete)
	var i OptionsInfo
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionAndUser = `-- name: GetOptionAndUser :one
SELECT u.first_name, od.host_name_option, oi.co_host_id, oi.main_option_type, op.cover_image
FROM options_infos oi
   JOIN users u on u.id = oi.host_id
   JOIN options_info_details od on od.option_id = oi.id
   JOIN options_info_photos op on oi.id = op.option_id
WHERE oi.id = $1
`

type GetOptionAndUserRow struct {
	FirstName      string    `json:"first_name"`
	HostNameOption string    `json:"host_name_option"`
	CoHostID       uuid.UUID `json:"co_host_id"`
	MainOptionType string    `json:"main_option_type"`
	CoverImage     string    `json:"cover_image"`
}

func (q *Queries) GetOptionAndUser(ctx context.Context, id uuid.UUID) (GetOptionAndUserRow, error) {
	row := q.db.QueryRow(ctx, getOptionAndUser, id)
	var i GetOptionAndUserRow
	err := row.Scan(
		&i.FirstName,
		&i.HostNameOption,
		&i.CoHostID,
		&i.MainOptionType,
		&i.CoverImage,
	)
	return i, err
}

const getOptionEventUHMData = `-- name: GetOptionEventUHMData :one
SELECT o_i.id, o_i.currency, o_i.main_option_type, o_i_d.host_name_option, o_i_p.photo, o_i_p.cover_image, o_i.option_user_id, e_i.event_type, e_i.sub_category_type, o_i_s.status AS option_status, o_i.category, o_i.category_two, o_i.category_three, o_i.category_four
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_infos_status o_i_s on o_i_s.option_id = o_i.id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN event_infos e_i on o_i.id = e_i.option_id
WHERE o_i.id = $1
`

type GetOptionEventUHMDataRow struct {
	ID              uuid.UUID `json:"id"`
	Currency        string    `json:"currency"`
	MainOptionType  string    `json:"main_option_type"`
	HostNameOption  string    `json:"host_name_option"`
	Photo           []string  `json:"photo"`
	CoverImage      string    `json:"cover_image"`
	OptionUserID    uuid.UUID `json:"option_user_id"`
	EventType       string    `json:"event_type"`
	SubCategoryType string    `json:"sub_category_type"`
	OptionStatus    string    `json:"option_status"`
	Category        string    `json:"category"`
	CategoryTwo     string    `json:"category_two"`
	CategoryThree   string    `json:"category_three"`
	CategoryFour    string    `json:"category_four"`
}

func (q *Queries) GetOptionEventUHMData(ctx context.Context, id uuid.UUID) (GetOptionEventUHMDataRow, error) {
	row := q.db.QueryRow(ctx, getOptionEventUHMData, id)
	var i GetOptionEventUHMDataRow
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.MainOptionType,
		&i.HostNameOption,
		&i.Photo,
		&i.CoverImage,
		&i.OptionUserID,
		&i.EventType,
		&i.SubCategoryType,
		&i.OptionStatus,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
	)
	return i, err
}

const getOptionForWishlist = `-- name: GetOptionForWishlist :one
SELECT o_i.option_user_id
FROM options_infos o_i
   JOIN users u on o_i.host_id = u.id
WHERE o_i.option_user_id=$1 AND u.is_active = $2 AND o_i.is_complete = $3 AND o_i.is_active = $4
`

type GetOptionForWishlistParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	IsActive     bool      `json:"is_active"`
	IsComplete   bool      `json:"is_complete"`
	IsActive_2   bool      `json:"is_active_2"`
}

func (q *Queries) GetOptionForWishlist(ctx context.Context, arg GetOptionForWishlistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getOptionForWishlist,
		arg.OptionUserID,
		arg.IsActive,
		arg.IsComplete,
		arg.IsActive_2,
	)
	var option_user_id uuid.UUID
	err := row.Scan(&option_user_id)
	return option_user_id, err
}

const getOptionHost = `-- name: GetOptionHost :one
SELECT id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, o_i.created_at, completed, o_i.updated_at, user_id, work, languages, bio, u_p.created_at, u_p.updated_at
FROM options_infos o_i
   --JOIN users u on o_i.host_id = u.user_id
   JOIN users_profiles u_p on o_i.host_id = u_p.user_id
WHERE o_i.id = $1
`

type GetOptionHostRow struct {
	ID             uuid.UUID `json:"id"`
	CoHostID       uuid.UUID `json:"co_host_id"`
	OptionUserID   uuid.UUID `json:"option_user_id"`
	HostID         uuid.UUID `json:"host_id"`
	DeepLinkID     uuid.UUID `json:"deep_link_id"`
	PrimaryUserID  uuid.UUID `json:"primary_user_id"`
	IsActive       bool      `json:"is_active"`
	IsComplete     bool      `json:"is_complete"`
	IsVerified     bool      `json:"is_verified"`
	Category       string    `json:"category"`
	CategoryTwo    string    `json:"category_two"`
	CategoryThree  string    `json:"category_three"`
	CategoryFour   string    `json:"category_four"`
	IsTopSeller    bool      `json:"is_top_seller"`
	TimeZone       string    `json:"time_zone"`
	Currency       string    `json:"currency"`
	OptionImg      string    `json:"option_img"`
	OptionType     string    `json:"option_type"`
	MainOptionType string    `json:"main_option_type"`
	CreatedAt      time.Time `json:"created_at"`
	Completed      time.Time `json:"completed"`
	UpdatedAt      time.Time `json:"updated_at"`
	UserID         uuid.UUID `json:"user_id"`
	Work           string    `json:"work"`
	Languages      []string  `json:"languages"`
	Bio            string    `json:"bio"`
	CreatedAt_2    time.Time `json:"created_at_2"`
	UpdatedAt_2    time.Time `json:"updated_at_2"`
}

func (q *Queries) GetOptionHost(ctx context.Context, id uuid.UUID) (GetOptionHostRow, error) {
	row := q.db.QueryRow(ctx, getOptionHost, id)
	var i GetOptionHostRow
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
		&i.UserID,
		&i.Work,
		&i.Languages,
		&i.Bio,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getOptionInfo = `-- name: GetOptionInfo :one
SELECT id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, created_at, completed, updated_at
FROM options_infos
WHERE id = $1 AND host_id = $2 AND is_complete = $3
`

type GetOptionInfoParams struct {
	ID         uuid.UUID `json:"id"`
	HostID     uuid.UUID `json:"host_id"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) GetOptionInfo(ctx context.Context, arg GetOptionInfoParams) (OptionsInfo, error) {
	row := q.db.QueryRow(ctx, getOptionInfo, arg.ID, arg.HostID, arg.IsComplete)
	var i OptionsInfo
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionInfoAllCount = `-- name: GetOptionInfoAllCount :one
SELECT COUNT(CASE WHEN oi.is_complete = true THEN 1 END) AS complete, COUNT(CASE WHEN oi.is_complete = false THEN 1 END) AS in_complete
FROM options_infos oi
   LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $1 OR och_subquery.option_id IS NOT NULL)
`

type GetOptionInfoAllCountParams struct {
	HostID   uuid.UUID `json:"host_id"`
	CoUserID string    `json:"co_user_id"`
}

type GetOptionInfoAllCountRow struct {
	Complete   int64 `json:"complete"`
	InComplete int64 `json:"in_complete"`
}

func (q *Queries) GetOptionInfoAllCount(ctx context.Context, arg GetOptionInfoAllCountParams) (GetOptionInfoAllCountRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoAllCount, arg.HostID, arg.CoUserID)
	var i GetOptionInfoAllCountRow
	err := row.Scan(&i.Complete, &i.InComplete)
	return i, err
}

const getOptionInfoByOptionUserID = `-- name: GetOptionInfoByOptionUserID :one
SELECT id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, created_at, completed, updated_at
FROM options_infos o_i
WHERE o_i.option_user_id=$1
`

func (q *Queries) GetOptionInfoByOptionUserID(ctx context.Context, optionUserID uuid.UUID) (OptionsInfo, error) {
	row := q.db.QueryRow(ctx, getOptionInfoByOptionUserID, optionUserID)
	var i OptionsInfo
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionInfoByOptionWithPriceUserID = `-- name: GetOptionInfoByOptionWithPriceUserID :one
SELECT id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, o_i.created_at, completed, o_i.updated_at, option_id, price, weekend_price, op.created_at, op.updated_at
FROM options_infos o_i
   JOIN options_prices op on op.option_id = o_i.id
WHERE o_i.option_user_id=$1
`

type GetOptionInfoByOptionWithPriceUserIDRow struct {
	ID             uuid.UUID `json:"id"`
	CoHostID       uuid.UUID `json:"co_host_id"`
	OptionUserID   uuid.UUID `json:"option_user_id"`
	HostID         uuid.UUID `json:"host_id"`
	DeepLinkID     uuid.UUID `json:"deep_link_id"`
	PrimaryUserID  uuid.UUID `json:"primary_user_id"`
	IsActive       bool      `json:"is_active"`
	IsComplete     bool      `json:"is_complete"`
	IsVerified     bool      `json:"is_verified"`
	Category       string    `json:"category"`
	CategoryTwo    string    `json:"category_two"`
	CategoryThree  string    `json:"category_three"`
	CategoryFour   string    `json:"category_four"`
	IsTopSeller    bool      `json:"is_top_seller"`
	TimeZone       string    `json:"time_zone"`
	Currency       string    `json:"currency"`
	OptionImg      string    `json:"option_img"`
	OptionType     string    `json:"option_type"`
	MainOptionType string    `json:"main_option_type"`
	CreatedAt      time.Time `json:"created_at"`
	Completed      time.Time `json:"completed"`
	UpdatedAt      time.Time `json:"updated_at"`
	OptionID       uuid.UUID `json:"option_id"`
	Price          int64     `json:"price"`
	WeekendPrice   int64     `json:"weekend_price"`
	CreatedAt_2    time.Time `json:"created_at_2"`
	UpdatedAt_2    time.Time `json:"updated_at_2"`
}

func (q *Queries) GetOptionInfoByOptionWithPriceUserID(ctx context.Context, optionUserID uuid.UUID) (GetOptionInfoByOptionWithPriceUserIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoByOptionWithPriceUserID, optionUserID)
	var i GetOptionInfoByOptionWithPriceUserIDRow
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
		&i.OptionID,
		&i.Price,
		&i.WeekendPrice,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getOptionInfoByUserID = `-- name: GetOptionInfoByUserID :one
SELECT o_i.id, o_i_d.pets_allowed, o_i.time_zone, c_i_d.arrive_before, c_i_d.arrive_after, c_i_d.leave_before, c_p.type_one, c_p.type_two, o_q.organization_name, o_q.host_as_individual
FROM options_infos o_i
   JOIN cancel_policies c_p on o_i.id = c_p.option_id
   JOIN check_in_out_details c_i_d on c_i_d.option_id = o_i.id
   JOIN options_info_details o_i_d on o_i_d.option_id = o_i.id
   JOIN option_questions o_q on o_q.option_id = o_i.id
WHERE o_i.option_user_id=$1
`

type GetOptionInfoByUserIDRow struct {
	ID               uuid.UUID `json:"id"`
	PetsAllowed      bool      `json:"pets_allowed"`
	TimeZone         string    `json:"time_zone"`
	ArriveBefore     string    `json:"arrive_before"`
	ArriveAfter      string    `json:"arrive_after"`
	LeaveBefore      string    `json:"leave_before"`
	TypeOne          string    `json:"type_one"`
	TypeTwo          string    `json:"type_two"`
	OrganizationName string    `json:"organization_name"`
	HostAsIndividual bool      `json:"host_as_individual"`
}

func (q *Queries) GetOptionInfoByUserID(ctx context.Context, optionUserID uuid.UUID) (GetOptionInfoByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoByUserID, optionUserID)
	var i GetOptionInfoByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.PetsAllowed,
		&i.TimeZone,
		&i.ArriveBefore,
		&i.ArriveAfter,
		&i.LeaveBefore,
		&i.TypeOne,
		&i.TypeTwo,
		&i.OrganizationName,
		&i.HostAsIndividual,
	)
	return i, err
}

const getOptionInfoCustomer = `-- name: GetOptionInfoCustomer :one
SELECT o_i.id, co_host_id, option_user_id, host_id, o_i.deep_link_id, primary_user_id, o_i.is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, o_i.currency, option_img, option_type, main_option_type, o_i.created_at, completed, o_i.updated_at, u.id, user_id, firebase_id, public_id, hashed_password, u.deep_link_id, firebase_password, u.email, u.phone_number, first_name, username, last_name, date_of_birth, dial_code, dial_country, current_option_id, u.currency, default_card, default_payout_card, default_account_id, u.is_active, is_deleted, photo, public_photo, password_changed_at, u.created_at, u.updated_at, o_i_d.option_id, des, space_des, guest_access_des, interact_with_guests_des, pets_allowed, other_des, neighborhood_des, get_around_des, host_name_option, option_highlight, o_i_d.created_at, o_i_d.updated_at, o_i_s.option_id, status, status_reason, snooze_start_date, snooze_end_date, unlist_reason, unlist_des, o_i_s.created_at, o_i_s.updated_at, s.option_id, space_type, any_space_shared, guest_welcomed, publish_check_in_steps, year_built, check_in_method, check_in_method_des, property_size, shared_spaces_with, property_size_unit, type_of_shortlet, s.created_at, s.updated_at, c_o_i.option_id, current_state, previous_state, c_o_i.created_at, c_o_i.updated_at, o_p.option_id, price, weekend_price, o_p.created_at, o_p.updated_at, o_a_s.option_id, advance_notice, auto_block_dates, advance_notice_condition, preparation_time, availability_window, o_a_s.created_at, o_a_s.updated_at, o_t_l.option_id, min_stay_day, max_stay_night, manual_approve_request_pass_max, allow_reservation_request, o_t_l.created_at, o_t_l.updated_at, o_b_m.option_id, instant_book, identity_verified, good_track_record, pre_book_msg, o_b_m.created_at, o_b_m.updated_at, b_m.option_id, b_m.email, b_m.phone_number, rules, payment_info, profile_photo, b_m.created_at, b_m.updated_at
FROM options_infos o_i
   JOIN users u on o_i.host_id = u.id
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_infos_status o_i_s on o_i_s.option_id = o_i.id
   JOIN shortlets s on o_i.id = s.option_id
   JOIN complete_option_info c_o_i on o_i.id = c_o_i.option_id
   JOIN options_prices o_p on o_i.id = o_p.option_id
   JOIN option_availability_settings o_a_s on o_i.id = o_a_s.option_id
   JOIN option_trip_lengths o_t_l on o_i.id = o_t_l.option_id
   JOIN option_book_methods o_b_m on o_i.id = o_b_m.option_id
   JOIN book_requirements b_m on o_i.id = b_m.option_id
WHERE o_i.option_user_id = $1 AND o_i.is_complete = $2 AND o_i.is_active = $3 AND (o_i_s.status = $5 OR o_i_s.status = $6) AND u.is_active = $4
`

type GetOptionInfoCustomerParams struct {
	OptionUserID    uuid.UUID `json:"option_user_id"`
	IsComplete      bool      `json:"is_complete"`
	IsActive        bool      `json:"is_active"`
	IsActive_2      bool      `json:"is_active_2"`
	OptionStatusOne string    `json:"option_status_one"`
	OptionStatusTwo string    `json:"option_status_two"`
}

type GetOptionInfoCustomerRow struct {
	ID                          uuid.UUID `json:"id"`
	CoHostID                    uuid.UUID `json:"co_host_id"`
	OptionUserID                uuid.UUID `json:"option_user_id"`
	HostID                      uuid.UUID `json:"host_id"`
	DeepLinkID                  uuid.UUID `json:"deep_link_id"`
	PrimaryUserID               uuid.UUID `json:"primary_user_id"`
	IsActive                    bool      `json:"is_active"`
	IsComplete                  bool      `json:"is_complete"`
	IsVerified                  bool      `json:"is_verified"`
	Category                    string    `json:"category"`
	CategoryTwo                 string    `json:"category_two"`
	CategoryThree               string    `json:"category_three"`
	CategoryFour                string    `json:"category_four"`
	IsTopSeller                 bool      `json:"is_top_seller"`
	TimeZone                    string    `json:"time_zone"`
	Currency                    string    `json:"currency"`
	OptionImg                   string    `json:"option_img"`
	OptionType                  string    `json:"option_type"`
	MainOptionType              string    `json:"main_option_type"`
	CreatedAt                   time.Time `json:"created_at"`
	Completed                   time.Time `json:"completed"`
	UpdatedAt                   time.Time `json:"updated_at"`
	ID_2                        uuid.UUID `json:"id_2"`
	UserID                      uuid.UUID `json:"user_id"`
	FirebaseID                  uuid.UUID `json:"firebase_id"`
	PublicID                    uuid.UUID `json:"public_id"`
	HashedPassword              string    `json:"hashed_password"`
	DeepLinkID_2                uuid.UUID `json:"deep_link_id_2"`
	FirebasePassword            string    `json:"firebase_password"`
	Email                       string    `json:"email"`
	PhoneNumber                 string    `json:"phone_number"`
	FirstName                   string    `json:"first_name"`
	Username                    string    `json:"username"`
	LastName                    string    `json:"last_name"`
	DateOfBirth                 time.Time `json:"date_of_birth"`
	DialCode                    string    `json:"dial_code"`
	DialCountry                 string    `json:"dial_country"`
	CurrentOptionID             string    `json:"current_option_id"`
	Currency_2                  string    `json:"currency_2"`
	DefaultCard                 string    `json:"default_card"`
	DefaultPayoutCard           string    `json:"default_payout_card"`
	DefaultAccountID            string    `json:"default_account_id"`
	IsActive_2                  bool      `json:"is_active_2"`
	IsDeleted                   bool      `json:"is_deleted"`
	Photo                       string    `json:"photo"`
	PublicPhoto                 string    `json:"public_photo"`
	PasswordChangedAt           time.Time `json:"password_changed_at"`
	CreatedAt_2                 time.Time `json:"created_at_2"`
	UpdatedAt_2                 time.Time `json:"updated_at_2"`
	OptionID                    uuid.UUID `json:"option_id"`
	Des                         string    `json:"des"`
	SpaceDes                    string    `json:"space_des"`
	GuestAccessDes              string    `json:"guest_access_des"`
	InteractWithGuestsDes       string    `json:"interact_with_guests_des"`
	PetsAllowed                 bool      `json:"pets_allowed"`
	OtherDes                    string    `json:"other_des"`
	NeighborhoodDes             string    `json:"neighborhood_des"`
	GetAroundDes                string    `json:"get_around_des"`
	HostNameOption              string    `json:"host_name_option"`
	OptionHighlight             []string  `json:"option_highlight"`
	CreatedAt_3                 time.Time `json:"created_at_3"`
	UpdatedAt_3                 time.Time `json:"updated_at_3"`
	OptionID_2                  uuid.UUID `json:"option_id_2"`
	Status                      string    `json:"status"`
	StatusReason                string    `json:"status_reason"`
	SnoozeStartDate             time.Time `json:"snooze_start_date"`
	SnoozeEndDate               time.Time `json:"snooze_end_date"`
	UnlistReason                string    `json:"unlist_reason"`
	UnlistDes                   string    `json:"unlist_des"`
	CreatedAt_4                 time.Time `json:"created_at_4"`
	UpdatedAt_4                 time.Time `json:"updated_at_4"`
	OptionID_3                  uuid.UUID `json:"option_id_3"`
	SpaceType                   string    `json:"space_type"`
	AnySpaceShared              bool      `json:"any_space_shared"`
	GuestWelcomed               int32     `json:"guest_welcomed"`
	PublishCheckInSteps         bool      `json:"publish_check_in_steps"`
	YearBuilt                   int32     `json:"year_built"`
	CheckInMethod               string    `json:"check_in_method"`
	CheckInMethodDes            string    `json:"check_in_method_des"`
	PropertySize                int32     `json:"property_size"`
	SharedSpacesWith            []string  `json:"shared_spaces_with"`
	PropertySizeUnit            string    `json:"property_size_unit"`
	TypeOfShortlet              string    `json:"type_of_shortlet"`
	CreatedAt_5                 time.Time `json:"created_at_5"`
	UpdatedAt_5                 time.Time `json:"updated_at_5"`
	OptionID_4                  uuid.UUID `json:"option_id_4"`
	CurrentState                string    `json:"current_state"`
	PreviousState               string    `json:"previous_state"`
	CreatedAt_6                 time.Time `json:"created_at_6"`
	UpdatedAt_6                 time.Time `json:"updated_at_6"`
	OptionID_5                  uuid.UUID `json:"option_id_5"`
	Price                       int64     `json:"price"`
	WeekendPrice                int64     `json:"weekend_price"`
	CreatedAt_7                 time.Time `json:"created_at_7"`
	UpdatedAt_7                 time.Time `json:"updated_at_7"`
	OptionID_6                  uuid.UUID `json:"option_id_6"`
	AdvanceNotice               string    `json:"advance_notice"`
	AutoBlockDates              bool      `json:"auto_block_dates"`
	AdvanceNoticeCondition      string    `json:"advance_notice_condition"`
	PreparationTime             string    `json:"preparation_time"`
	AvailabilityWindow          string    `json:"availability_window"`
	CreatedAt_8                 time.Time `json:"created_at_8"`
	UpdatedAt_8                 time.Time `json:"updated_at_8"`
	OptionID_7                  uuid.UUID `json:"option_id_7"`
	MinStayDay                  int32     `json:"min_stay_day"`
	MaxStayNight                int32     `json:"max_stay_night"`
	ManualApproveRequestPassMax bool      `json:"manual_approve_request_pass_max"`
	AllowReservationRequest     bool      `json:"allow_reservation_request"`
	CreatedAt_9                 time.Time `json:"created_at_9"`
	UpdatedAt_9                 time.Time `json:"updated_at_9"`
	OptionID_8                  uuid.UUID `json:"option_id_8"`
	InstantBook                 bool      `json:"instant_book"`
	IdentityVerified            bool      `json:"identity_verified"`
	GoodTrackRecord             bool      `json:"good_track_record"`
	PreBookMsg                  string    `json:"pre_book_msg"`
	CreatedAt_10                time.Time `json:"created_at_10"`
	UpdatedAt_10                time.Time `json:"updated_at_10"`
	OptionID_9                  uuid.UUID `json:"option_id_9"`
	Email_2                     bool      `json:"email_2"`
	PhoneNumber_2               bool      `json:"phone_number_2"`
	Rules                       bool      `json:"rules"`
	PaymentInfo                 bool      `json:"payment_info"`
	ProfilePhoto                bool      `json:"profile_photo"`
	CreatedAt_11                time.Time `json:"created_at_11"`
	UpdatedAt_11                time.Time `json:"updated_at_11"`
}

func (q *Queries) GetOptionInfoCustomer(ctx context.Context, arg GetOptionInfoCustomerParams) (GetOptionInfoCustomerRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoCustomer,
		arg.OptionUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.IsActive_2,
		arg.OptionStatusOne,
		arg.OptionStatusTwo,
	)
	var i GetOptionInfoCustomerRow
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
		&i.ID_2,
		&i.UserID,
		&i.FirebaseID,
		&i.PublicID,
		&i.HashedPassword,
		&i.DeepLinkID_2,
		&i.FirebasePassword,
		&i.Email,
		&i.PhoneNumber,
		&i.FirstName,
		&i.Username,
		&i.LastName,
		&i.DateOfBirth,
		&i.DialCode,
		&i.DialCountry,
		&i.CurrentOptionID,
		&i.Currency_2,
		&i.DefaultCard,
		&i.DefaultPayoutCard,
		&i.DefaultAccountID,
		&i.IsActive_2,
		&i.IsDeleted,
		&i.Photo,
		&i.PublicPhoto,
		&i.PasswordChangedAt,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.OptionID,
		&i.Des,
		&i.SpaceDes,
		&i.GuestAccessDes,
		&i.InteractWithGuestsDes,
		&i.PetsAllowed,
		&i.OtherDes,
		&i.NeighborhoodDes,
		&i.GetAroundDes,
		&i.HostNameOption,
		&i.OptionHighlight,
		&i.CreatedAt_3,
		&i.UpdatedAt_3,
		&i.OptionID_2,
		&i.Status,
		&i.StatusReason,
		&i.SnoozeStartDate,
		&i.SnoozeEndDate,
		&i.UnlistReason,
		&i.UnlistDes,
		&i.CreatedAt_4,
		&i.UpdatedAt_4,
		&i.OptionID_3,
		&i.SpaceType,
		&i.AnySpaceShared,
		&i.GuestWelcomed,
		&i.PublishCheckInSteps,
		&i.YearBuilt,
		&i.CheckInMethod,
		&i.CheckInMethodDes,
		&i.PropertySize,
		&i.SharedSpacesWith,
		&i.PropertySizeUnit,
		&i.TypeOfShortlet,
		&i.CreatedAt_5,
		&i.UpdatedAt_5,
		&i.OptionID_4,
		&i.CurrentState,
		&i.PreviousState,
		&i.CreatedAt_6,
		&i.UpdatedAt_6,
		&i.OptionID_5,
		&i.Price,
		&i.WeekendPrice,
		&i.CreatedAt_7,
		&i.UpdatedAt_7,
		&i.OptionID_6,
		&i.AdvanceNotice,
		&i.AutoBlockDates,
		&i.AdvanceNoticeCondition,
		&i.PreparationTime,
		&i.AvailabilityWindow,
		&i.CreatedAt_8,
		&i.UpdatedAt_8,
		&i.OptionID_7,
		&i.MinStayDay,
		&i.MaxStayNight,
		&i.ManualApproveRequestPassMax,
		&i.AllowReservationRequest,
		&i.CreatedAt_9,
		&i.UpdatedAt_9,
		&i.OptionID_8,
		&i.InstantBook,
		&i.IdentityVerified,
		&i.GoodTrackRecord,
		&i.PreBookMsg,
		&i.CreatedAt_10,
		&i.UpdatedAt_10,
		&i.OptionID_9,
		&i.Email_2,
		&i.PhoneNumber_2,
		&i.Rules,
		&i.PaymentInfo,
		&i.ProfilePhoto,
		&i.CreatedAt_11,
		&i.UpdatedAt_11,
	)
	return i, err
}

const getOptionInfoData = `-- name: GetOptionInfoData :one
SELECT o_i.id, o_i.is_complete, o_i.currency, o_i.main_option_type, o_i.created_at, o_i.option_type, o_i_d.host_name_option, c_o_i.current_state, c_o_i.previous_state, o_i.is_active
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN complete_option_info c_o_i on o_i.id = c_o_i.option_id
WHERE o_i.host_id = $1 AND o_i.is_complete = $2 AND o_i.is_active = $3 AND o_i.id = $4
`

type GetOptionInfoDataParams struct {
	HostID     uuid.UUID `json:"host_id"`
	IsComplete bool      `json:"is_complete"`
	IsActive   bool      `json:"is_active"`
	ID         uuid.UUID `json:"id"`
}

type GetOptionInfoDataRow struct {
	ID             uuid.UUID `json:"id"`
	IsComplete     bool      `json:"is_complete"`
	Currency       string    `json:"currency"`
	MainOptionType string    `json:"main_option_type"`
	CreatedAt      time.Time `json:"created_at"`
	OptionType     string    `json:"option_type"`
	HostNameOption string    `json:"host_name_option"`
	CurrentState   string    `json:"current_state"`
	PreviousState  string    `json:"previous_state"`
	IsActive       bool      `json:"is_active"`
}

func (q *Queries) GetOptionInfoData(ctx context.Context, arg GetOptionInfoDataParams) (GetOptionInfoDataRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoData,
		arg.HostID,
		arg.IsComplete,
		arg.IsActive,
		arg.ID,
	)
	var i GetOptionInfoDataRow
	err := row.Scan(
		&i.ID,
		&i.IsComplete,
		&i.Currency,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.OptionType,
		&i.HostNameOption,
		&i.CurrentState,
		&i.PreviousState,
		&i.IsActive,
	)
	return i, err
}

const getOptionInfoID = `-- name: GetOptionInfoID :one
SELECT id
FROM options_infos
WHERE id = $1 AND host_id = $2 
LIMIT 1
`

type GetOptionInfoIDParams struct {
	ID     uuid.UUID `json:"id"`
	HostID uuid.UUID `json:"host_id"`
}

func (q *Queries) GetOptionInfoID(ctx context.Context, arg GetOptionInfoIDParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getOptionInfoID, arg.ID, arg.HostID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getOptionInfoItemCount = `-- name: GetOptionInfoItemCount :one
SELECT COUNT(*)
FROM options_infos
WHERE id = $1
`

func (q *Queries) GetOptionInfoItemCount(ctx context.Context, id uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getOptionInfoItemCount, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOptionInfoMainCount = `-- name: GetOptionInfoMainCount :one
SELECT COUNT(*)
FROM options_infos
`

func (q *Queries) GetOptionInfoMainCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getOptionInfoMainCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOptionInfoPhotoByOptionUserID = `-- name: GetOptionInfoPhotoByOptionUserID :one
SELECT o_i.id, o_i_p.cover_image, o_i_p.photo
FROM options_infos o_i
   JOIN options_info_photos o_i_p on o_i_p.option_id = o_i.id
WHERE o_i.option_user_id = $1
`

type GetOptionInfoPhotoByOptionUserIDRow struct {
	ID         uuid.UUID `json:"id"`
	CoverImage string    `json:"cover_image"`
	Photo      []string  `json:"photo"`
}

func (q *Queries) GetOptionInfoPhotoByOptionUserID(ctx context.Context, optionUserID uuid.UUID) (GetOptionInfoPhotoByOptionUserIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoPhotoByOptionUserID, optionUserID)
	var i GetOptionInfoPhotoByOptionUserIDRow
	err := row.Scan(&i.ID, &i.CoverImage, &i.Photo)
	return i, err
}

const getOptionInfoUserByUserID = `-- name: GetOptionInfoUserByUserID :one
SELECT o_i.id, co_host_id, option_user_id, host_id, o_i.deep_link_id, primary_user_id, o_i.is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, o_i.currency, option_img, option_type, main_option_type, o_i.created_at, completed, o_i.updated_at, u.id, user_id, firebase_id, public_id, hashed_password, u.deep_link_id, firebase_password, email, phone_number, first_name, username, last_name, date_of_birth, dial_code, dial_country, current_option_id, u.currency, default_card, default_payout_card, default_account_id, u.is_active, is_deleted, photo, public_photo, password_changed_at, u.created_at, u.updated_at
FROM options_infos o_i
   JOIN users u on o_i.host_id = u.id
WHERE o_i.option_user_id=$1
`

type GetOptionInfoUserByUserIDRow struct {
	ID                uuid.UUID `json:"id"`
	CoHostID          uuid.UUID `json:"co_host_id"`
	OptionUserID      uuid.UUID `json:"option_user_id"`
	HostID            uuid.UUID `json:"host_id"`
	DeepLinkID        uuid.UUID `json:"deep_link_id"`
	PrimaryUserID     uuid.UUID `json:"primary_user_id"`
	IsActive          bool      `json:"is_active"`
	IsComplete        bool      `json:"is_complete"`
	IsVerified        bool      `json:"is_verified"`
	Category          string    `json:"category"`
	CategoryTwo       string    `json:"category_two"`
	CategoryThree     string    `json:"category_three"`
	CategoryFour      string    `json:"category_four"`
	IsTopSeller       bool      `json:"is_top_seller"`
	TimeZone          string    `json:"time_zone"`
	Currency          string    `json:"currency"`
	OptionImg         string    `json:"option_img"`
	OptionType        string    `json:"option_type"`
	MainOptionType    string    `json:"main_option_type"`
	CreatedAt         time.Time `json:"created_at"`
	Completed         time.Time `json:"completed"`
	UpdatedAt         time.Time `json:"updated_at"`
	ID_2              uuid.UUID `json:"id_2"`
	UserID            uuid.UUID `json:"user_id"`
	FirebaseID        uuid.UUID `json:"firebase_id"`
	PublicID          uuid.UUID `json:"public_id"`
	HashedPassword    string    `json:"hashed_password"`
	DeepLinkID_2      uuid.UUID `json:"deep_link_id_2"`
	FirebasePassword  string    `json:"firebase_password"`
	Email             string    `json:"email"`
	PhoneNumber       string    `json:"phone_number"`
	FirstName         string    `json:"first_name"`
	Username          string    `json:"username"`
	LastName          string    `json:"last_name"`
	DateOfBirth       time.Time `json:"date_of_birth"`
	DialCode          string    `json:"dial_code"`
	DialCountry       string    `json:"dial_country"`
	CurrentOptionID   string    `json:"current_option_id"`
	Currency_2        string    `json:"currency_2"`
	DefaultCard       string    `json:"default_card"`
	DefaultPayoutCard string    `json:"default_payout_card"`
	DefaultAccountID  string    `json:"default_account_id"`
	IsActive_2        bool      `json:"is_active_2"`
	IsDeleted         bool      `json:"is_deleted"`
	Photo             string    `json:"photo"`
	PublicPhoto       string    `json:"public_photo"`
	PasswordChangedAt time.Time `json:"password_changed_at"`
	CreatedAt_2       time.Time `json:"created_at_2"`
	UpdatedAt_2       time.Time `json:"updated_at_2"`
}

func (q *Queries) GetOptionInfoUserByUserID(ctx context.Context, optionUserID uuid.UUID) (GetOptionInfoUserByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoUserByUserID, optionUserID)
	var i GetOptionInfoUserByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
		&i.ID_2,
		&i.UserID,
		&i.FirebaseID,
		&i.PublicID,
		&i.HashedPassword,
		&i.DeepLinkID_2,
		&i.FirebasePassword,
		&i.Email,
		&i.PhoneNumber,
		&i.FirstName,
		&i.Username,
		&i.LastName,
		&i.DateOfBirth,
		&i.DialCode,
		&i.DialCountry,
		&i.CurrentOptionID,
		&i.Currency_2,
		&i.DefaultCard,
		&i.DefaultPayoutCard,
		&i.DefaultAccountID,
		&i.IsActive_2,
		&i.IsDeleted,
		&i.Photo,
		&i.PublicPhoto,
		&i.PasswordChangedAt,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getOptionInfoUserIDByUserID = `-- name: GetOptionInfoUserIDByUserID :one
SELECT o_i.id, co_host_id, option_user_id, host_id, o_i.deep_link_id, primary_user_id, o_i.is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, o_i.currency, option_img, option_type, main_option_type, o_i.created_at, completed, o_i.updated_at, u.id, user_id, firebase_id, public_id, hashed_password, u.deep_link_id, firebase_password, email, phone_number, first_name, username, last_name, date_of_birth, dial_code, dial_country, current_option_id, u.currency, default_card, default_payout_card, default_account_id, u.is_active, is_deleted, photo, public_photo, password_changed_at, u.created_at, u.updated_at, option_id, des, space_des, guest_access_des, interact_with_guests_des, pets_allowed, other_des, neighborhood_des, get_around_des, host_name_option, option_highlight, o_i_d.created_at, o_i_d.updated_at
FROM options_infos o_i
   JOIN users u on o_i.host_id = u.id
   JOIN options_info_details o_i_d on o_i_d.option_id = o_i.id
WHERE o_i.option_user_id=$1
`

type GetOptionInfoUserIDByUserIDRow struct {
	ID                    uuid.UUID `json:"id"`
	CoHostID              uuid.UUID `json:"co_host_id"`
	OptionUserID          uuid.UUID `json:"option_user_id"`
	HostID                uuid.UUID `json:"host_id"`
	DeepLinkID            uuid.UUID `json:"deep_link_id"`
	PrimaryUserID         uuid.UUID `json:"primary_user_id"`
	IsActive              bool      `json:"is_active"`
	IsComplete            bool      `json:"is_complete"`
	IsVerified            bool      `json:"is_verified"`
	Category              string    `json:"category"`
	CategoryTwo           string    `json:"category_two"`
	CategoryThree         string    `json:"category_three"`
	CategoryFour          string    `json:"category_four"`
	IsTopSeller           bool      `json:"is_top_seller"`
	TimeZone              string    `json:"time_zone"`
	Currency              string    `json:"currency"`
	OptionImg             string    `json:"option_img"`
	OptionType            string    `json:"option_type"`
	MainOptionType        string    `json:"main_option_type"`
	CreatedAt             time.Time `json:"created_at"`
	Completed             time.Time `json:"completed"`
	UpdatedAt             time.Time `json:"updated_at"`
	ID_2                  uuid.UUID `json:"id_2"`
	UserID                uuid.UUID `json:"user_id"`
	FirebaseID            uuid.UUID `json:"firebase_id"`
	PublicID              uuid.UUID `json:"public_id"`
	HashedPassword        string    `json:"hashed_password"`
	DeepLinkID_2          uuid.UUID `json:"deep_link_id_2"`
	FirebasePassword      string    `json:"firebase_password"`
	Email                 string    `json:"email"`
	PhoneNumber           string    `json:"phone_number"`
	FirstName             string    `json:"first_name"`
	Username              string    `json:"username"`
	LastName              string    `json:"last_name"`
	DateOfBirth           time.Time `json:"date_of_birth"`
	DialCode              string    `json:"dial_code"`
	DialCountry           string    `json:"dial_country"`
	CurrentOptionID       string    `json:"current_option_id"`
	Currency_2            string    `json:"currency_2"`
	DefaultCard           string    `json:"default_card"`
	DefaultPayoutCard     string    `json:"default_payout_card"`
	DefaultAccountID      string    `json:"default_account_id"`
	IsActive_2            bool      `json:"is_active_2"`
	IsDeleted             bool      `json:"is_deleted"`
	Photo                 string    `json:"photo"`
	PublicPhoto           string    `json:"public_photo"`
	PasswordChangedAt     time.Time `json:"password_changed_at"`
	CreatedAt_2           time.Time `json:"created_at_2"`
	UpdatedAt_2           time.Time `json:"updated_at_2"`
	OptionID              uuid.UUID `json:"option_id"`
	Des                   string    `json:"des"`
	SpaceDes              string    `json:"space_des"`
	GuestAccessDes        string    `json:"guest_access_des"`
	InteractWithGuestsDes string    `json:"interact_with_guests_des"`
	PetsAllowed           bool      `json:"pets_allowed"`
	OtherDes              string    `json:"other_des"`
	NeighborhoodDes       string    `json:"neighborhood_des"`
	GetAroundDes          string    `json:"get_around_des"`
	HostNameOption        string    `json:"host_name_option"`
	OptionHighlight       []string  `json:"option_highlight"`
	CreatedAt_3           time.Time `json:"created_at_3"`
	UpdatedAt_3           time.Time `json:"updated_at_3"`
}

func (q *Queries) GetOptionInfoUserIDByUserID(ctx context.Context, optionUserID uuid.UUID) (GetOptionInfoUserIDByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionInfoUserIDByUserID, optionUserID)
	var i GetOptionInfoUserIDByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
		&i.ID_2,
		&i.UserID,
		&i.FirebaseID,
		&i.PublicID,
		&i.HashedPassword,
		&i.DeepLinkID_2,
		&i.FirebasePassword,
		&i.Email,
		&i.PhoneNumber,
		&i.FirstName,
		&i.Username,
		&i.LastName,
		&i.DateOfBirth,
		&i.DialCode,
		&i.DialCountry,
		&i.CurrentOptionID,
		&i.Currency_2,
		&i.DefaultCard,
		&i.DefaultPayoutCard,
		&i.DefaultAccountID,
		&i.IsActive_2,
		&i.IsDeleted,
		&i.Photo,
		&i.PublicPhoto,
		&i.PasswordChangedAt,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.OptionID,
		&i.Des,
		&i.SpaceDes,
		&i.GuestAccessDes,
		&i.InteractWithGuestsDes,
		&i.PetsAllowed,
		&i.OtherDes,
		&i.NeighborhoodDes,
		&i.GetAroundDes,
		&i.HostNameOption,
		&i.OptionHighlight,
		&i.CreatedAt_3,
		&i.UpdatedAt_3,
	)
	return i, err
}

const getOptionShortletUHMData = `-- name: GetOptionShortletUHMData :one
SELECT o_i.id, o_i.currency, o_i.main_option_type, o_i_d.host_name_option, s.type_of_shortlet, s.check_in_method, o_i_p.photo, o_i_p.cover_image, s.space_type, s.guest_welcomed, o_p.price, o_i.option_user_id, l.state, l.city, l.street, l.country, l.postcode, o_i_s.status AS option_status, o_i.category, o_i.category_two, o_i.category_three, o_i.category_four
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_infos_status o_i_s on o_i_s.option_id = o_i.id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN options_prices o_p on o_i.id = o_p.option_id 
   JOIN locations l on o_i.id = l.option_id
   JOIN shortlets s on o_i.id = s.option_id
WHERE o_i.id = $1
`

type GetOptionShortletUHMDataRow struct {
	ID             uuid.UUID `json:"id"`
	Currency       string    `json:"currency"`
	MainOptionType string    `json:"main_option_type"`
	HostNameOption string    `json:"host_name_option"`
	TypeOfShortlet string    `json:"type_of_shortlet"`
	CheckInMethod  string    `json:"check_in_method"`
	Photo          []string  `json:"photo"`
	CoverImage     string    `json:"cover_image"`
	SpaceType      string    `json:"space_type"`
	GuestWelcomed  int32     `json:"guest_welcomed"`
	Price          int64     `json:"price"`
	OptionUserID   uuid.UUID `json:"option_user_id"`
	State          string    `json:"state"`
	City           string    `json:"city"`
	Street         string    `json:"street"`
	Country        string    `json:"country"`
	Postcode       string    `json:"postcode"`
	OptionStatus   string    `json:"option_status"`
	Category       string    `json:"category"`
	CategoryTwo    string    `json:"category_two"`
	CategoryThree  string    `json:"category_three"`
	CategoryFour   string    `json:"category_four"`
}

func (q *Queries) GetOptionShortletUHMData(ctx context.Context, id uuid.UUID) (GetOptionShortletUHMDataRow, error) {
	row := q.db.QueryRow(ctx, getOptionShortletUHMData, id)
	var i GetOptionShortletUHMDataRow
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.MainOptionType,
		&i.HostNameOption,
		&i.TypeOfShortlet,
		&i.CheckInMethod,
		&i.Photo,
		&i.CoverImage,
		&i.SpaceType,
		&i.GuestWelcomed,
		&i.Price,
		&i.OptionUserID,
		&i.State,
		&i.City,
		&i.Street,
		&i.Country,
		&i.Postcode,
		&i.OptionStatus,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
	)
	return i, err
}

const getShortletCurrentOptionData = `-- name: GetShortletCurrentOptionData :one
SELECT o_i.id,
   l.state,
   l.country,
   o_i.main_option_type,
   o_i.currency,
   o_i.option_type,
   s.type_of_shortlet,
   o_i_d.host_name_option,
   o_i_p.cover_image
FROM options_infos o_i
   JOIN locations l on o_i.id = l.option_id
   JOIN shortlets s on o_i.id = s.option_id
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
WHERE o_i.id = $1 AND o_i.is_complete = $2
`

type GetShortletCurrentOptionDataParams struct {
	ID         uuid.UUID `json:"id"`
	IsComplete bool      `json:"is_complete"`
}

type GetShortletCurrentOptionDataRow struct {
	ID             uuid.UUID `json:"id"`
	State          string    `json:"state"`
	Country        string    `json:"country"`
	MainOptionType string    `json:"main_option_type"`
	Currency       string    `json:"currency"`
	OptionType     string    `json:"option_type"`
	TypeOfShortlet string    `json:"type_of_shortlet"`
	HostNameOption string    `json:"host_name_option"`
	CoverImage     string    `json:"cover_image"`
}

func (q *Queries) GetShortletCurrentOptionData(ctx context.Context, arg GetShortletCurrentOptionDataParams) (GetShortletCurrentOptionDataRow, error) {
	row := q.db.QueryRow(ctx, getShortletCurrentOptionData, arg.ID, arg.IsComplete)
	var i GetShortletCurrentOptionDataRow
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.Country,
		&i.MainOptionType,
		&i.Currency,
		&i.OptionType,
		&i.TypeOfShortlet,
		&i.HostNameOption,
		&i.CoverImage,
	)
	return i, err
}

const getShortletPublishData = `-- name: GetShortletPublishData :one
SELECT o_i.id,
   l.state,
   l.city,
   l.street,
   l.country,
   l.postcode,
   l.show_specific_location,
   s.guest_welcomed,
   s.type_of_shortlet,
   o_i_d.host_name_option,
   o_i_d.des,
   o_i_p.cover_image
FROM options_infos o_i
   JOIN locations l on o_i.id = l.option_id
   JOIN shortlets s on o_i.id = s.option_id
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
WHERE o_i.id = $1
`

type GetShortletPublishDataRow struct {
	ID                   uuid.UUID `json:"id"`
	State                string    `json:"state"`
	City                 string    `json:"city"`
	Street               string    `json:"street"`
	Country              string    `json:"country"`
	Postcode             string    `json:"postcode"`
	ShowSpecificLocation bool      `json:"show_specific_location"`
	GuestWelcomed        int32     `json:"guest_welcomed"`
	TypeOfShortlet       string    `json:"type_of_shortlet"`
	HostNameOption       string    `json:"host_name_option"`
	Des                  string    `json:"des"`
	CoverImage           string    `json:"cover_image"`
}

func (q *Queries) GetShortletPublishData(ctx context.Context, id uuid.UUID) (GetShortletPublishDataRow, error) {
	row := q.db.QueryRow(ctx, getShortletPublishData, id)
	var i GetShortletPublishDataRow
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.City,
		&i.Street,
		&i.Country,
		&i.Postcode,
		&i.ShowSpecificLocation,
		&i.GuestWelcomed,
		&i.TypeOfShortlet,
		&i.HostNameOption,
		&i.Des,
		&i.CoverImage,
	)
	return i, err
}

const getUserOptionInfo = `-- name: GetUserOptionInfo :one
SELECT id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, created_at, completed, updated_at
FROM options_infos
WHERE host_id = $1
`

func (q *Queries) GetUserOptionInfo(ctx context.Context, hostID uuid.UUID) (OptionsInfo, error) {
	row := q.db.QueryRow(ctx, getUserOptionInfo, hostID)
	var i OptionsInfo
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
	)
	return i, err
}

const listOptionInfo = `-- name: ListOptionInfo :many
SELECT oi.id AS option_id, oi.co_host_id, oi.option_user_id, oi.is_complete, oi.currency, oi.main_option_type, oi.created_at, oi.option_type, od.host_name_option, coi.current_state, coi.previous_state, op.cover_image, ois.status AS option_status, s.type_of_shortlet, ei.event_type, s.space_type, 
CASE
   WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
   WHEN oi.host_id = $1 THEN 'main_host'
   ELSE 'none' -- Optional: Handle other cases if needed
END AS host_type
FROM options_infos oi
   JOIN options_info_details od on oi.id = od.option_id
   JOIN options_infos_status ois on ois.option_id = od.option_id
   JOIN complete_option_info coi on oi.id = coi.option_id
   LEFT JOIN options_info_photos op on oi.id = op.option_id
   LEFT JOIN shortlets s on s.option_id = oi.id
   LEFT JOIN event_infos ei on ei.option_id = oi.id
   LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $1 OR och_subquery.option_id IS NOT NULL) AND oi.is_complete = $3  AND oi.is_active = $4 AND (ois.status = $7 OR ois.status = $8)
ORDER BY oi.created_at DESC
LIMIT $5
OFFSET $6
`

type ListOptionInfoParams struct {
	HostID          uuid.UUID `json:"host_id"`
	CoUserID        string    `json:"co_user_id"`
	IsComplete      bool      `json:"is_complete"`
	IsActive        bool      `json:"is_active"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
	OptionStatusOne string    `json:"option_status_one"`
	OptionStatusTwo string    `json:"option_status_two"`
}

type ListOptionInfoRow struct {
	OptionID       uuid.UUID   `json:"option_id"`
	CoHostID       uuid.UUID   `json:"co_host_id"`
	OptionUserID   uuid.UUID   `json:"option_user_id"`
	IsComplete     bool        `json:"is_complete"`
	Currency       string      `json:"currency"`
	MainOptionType string      `json:"main_option_type"`
	CreatedAt      time.Time   `json:"created_at"`
	OptionType     string      `json:"option_type"`
	HostNameOption string      `json:"host_name_option"`
	CurrentState   string      `json:"current_state"`
	PreviousState  string      `json:"previous_state"`
	CoverImage     pgtype.Text `json:"cover_image"`
	OptionStatus   string      `json:"option_status"`
	TypeOfShortlet pgtype.Text `json:"type_of_shortlet"`
	EventType      pgtype.Text `json:"event_type"`
	SpaceType      pgtype.Text `json:"space_type"`
	HostType       string      `json:"host_type"`
}

func (q *Queries) ListOptionInfo(ctx context.Context, arg ListOptionInfoParams) ([]ListOptionInfoRow, error) {
	rows, err := q.db.Query(ctx, listOptionInfo,
		arg.HostID,
		arg.CoUserID,
		arg.IsComplete,
		arg.IsActive,
		arg.Limit,
		arg.Offset,
		arg.OptionStatusOne,
		arg.OptionStatusTwo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionInfoRow{}
	for rows.Next() {
		var i ListOptionInfoRow
		if err := rows.Scan(
			&i.OptionID,
			&i.CoHostID,
			&i.OptionUserID,
			&i.IsComplete,
			&i.Currency,
			&i.MainOptionType,
			&i.CreatedAt,
			&i.OptionType,
			&i.HostNameOption,
			&i.CurrentState,
			&i.PreviousState,
			&i.CoverImage,
			&i.OptionStatus,
			&i.TypeOfShortlet,
			&i.EventType,
			&i.SpaceType,
			&i.HostType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionInfoEvent = `-- name: ListOptionInfoEvent :many
SELECT o_i.id, o_i.is_complete, o_i.currency, o_i.main_option_type, o_i.created_at, o_i.option_type, o_i_d.host_name_option, c_o_i.current_state, c_o_i.previous_state, o_i_s.status AS option_status, o_i_p.cover_image, e_i.event_type, e_i.sub_category_type
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN options_infos_status o_i_s on o_i_s.option_id = o_i_d.option_id
   JOIN complete_option_info c_o_i on o_i.id = c_o_i.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN event_infos e_i on o_i.id = e_i.option_id
WHERE o_i.host_id = $1 AND o_i.is_complete = $2 AND o_i.is_active = $3 AND (o_i_s.status = $6 OR o_i_s.status = $7)
ORDER BY o_i.created_at DESC
LIMIT $4
OFFSET $5
`

type ListOptionInfoEventParams struct {
	HostID          uuid.UUID `json:"host_id"`
	IsComplete      bool      `json:"is_complete"`
	IsActive        bool      `json:"is_active"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
	OptionStatusOne string    `json:"option_status_one"`
	OptionStatusTwo string    `json:"option_status_two"`
}

type ListOptionInfoEventRow struct {
	ID              uuid.UUID `json:"id"`
	IsComplete      bool      `json:"is_complete"`
	Currency        string    `json:"currency"`
	MainOptionType  string    `json:"main_option_type"`
	CreatedAt       time.Time `json:"created_at"`
	OptionType      string    `json:"option_type"`
	HostNameOption  string    `json:"host_name_option"`
	CurrentState    string    `json:"current_state"`
	PreviousState   string    `json:"previous_state"`
	OptionStatus    string    `json:"option_status"`
	CoverImage      string    `json:"cover_image"`
	EventType       string    `json:"event_type"`
	SubCategoryType string    `json:"sub_category_type"`
}

func (q *Queries) ListOptionInfoEvent(ctx context.Context, arg ListOptionInfoEventParams) ([]ListOptionInfoEventRow, error) {
	rows, err := q.db.Query(ctx, listOptionInfoEvent,
		arg.HostID,
		arg.IsComplete,
		arg.IsActive,
		arg.Limit,
		arg.Offset,
		arg.OptionStatusOne,
		arg.OptionStatusTwo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionInfoEventRow{}
	for rows.Next() {
		var i ListOptionInfoEventRow
		if err := rows.Scan(
			&i.ID,
			&i.IsComplete,
			&i.Currency,
			&i.MainOptionType,
			&i.CreatedAt,
			&i.OptionType,
			&i.HostNameOption,
			&i.CurrentState,
			&i.PreviousState,
			&i.OptionStatus,
			&i.CoverImage,
			&i.EventType,
			&i.SubCategoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionInfoShortlet = `-- name: ListOptionInfoShortlet :many
SELECT o_i.id, o_i.is_complete, o_i.currency, o_i.main_option_type, o_i.created_at, o_i.option_type, o_i_d.host_name_option, c_o_i.current_state, c_o_i.previous_state, o_i_p.cover_image, s.space_type, s.type_of_shortlet, o_i_s.status AS option_status
FROM options_infos o_i
   JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
   JOIN complete_option_info c_o_i on o_i.id = c_o_i.option_id
   JOIN options_infos_status o_i_s on o_i_s.option_id = o_i_d.option_id
   JOIN options_info_photos o_i_p on o_i.id = o_i_p.option_id
   JOIN shortlets s on o_i.id = s.option_id
WHERE o_i.host_id = $1 AND o_i.is_complete = $2 AND o_i.is_active = $3 AND (o_i_s.status = $6 OR o_i_s.status = $7) 
ORDER BY o_i.created_at DESC
LIMIT $4
OFFSET $5
`

type ListOptionInfoShortletParams struct {
	HostID          uuid.UUID `json:"host_id"`
	IsComplete      bool      `json:"is_complete"`
	IsActive        bool      `json:"is_active"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
	OptionStatusOne string    `json:"option_status_one"`
	OptionStatusTwo string    `json:"option_status_two"`
}

type ListOptionInfoShortletRow struct {
	ID             uuid.UUID `json:"id"`
	IsComplete     bool      `json:"is_complete"`
	Currency       string    `json:"currency"`
	MainOptionType string    `json:"main_option_type"`
	CreatedAt      time.Time `json:"created_at"`
	OptionType     string    `json:"option_type"`
	HostNameOption string    `json:"host_name_option"`
	CurrentState   string    `json:"current_state"`
	PreviousState  string    `json:"previous_state"`
	CoverImage     string    `json:"cover_image"`
	SpaceType      string    `json:"space_type"`
	TypeOfShortlet string    `json:"type_of_shortlet"`
	OptionStatus   string    `json:"option_status"`
}

func (q *Queries) ListOptionInfoShortlet(ctx context.Context, arg ListOptionInfoShortletParams) ([]ListOptionInfoShortletRow, error) {
	rows, err := q.db.Query(ctx, listOptionInfoShortlet,
		arg.HostID,
		arg.IsComplete,
		arg.IsActive,
		arg.Limit,
		arg.Offset,
		arg.OptionStatusOne,
		arg.OptionStatusTwo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionInfoShortletRow{}
	for rows.Next() {
		var i ListOptionInfoShortletRow
		if err := rows.Scan(
			&i.ID,
			&i.IsComplete,
			&i.Currency,
			&i.MainOptionType,
			&i.CreatedAt,
			&i.OptionType,
			&i.HostNameOption,
			&i.CurrentState,
			&i.PreviousState,
			&i.CoverImage,
			&i.SpaceType,
			&i.TypeOfShortlet,
			&i.OptionStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOptionInfo = `-- name: RemoveOptionInfo :exec
DELETE FROM options_infos
WHERE id = $1 AND host_id = $2
`

type RemoveOptionInfoParams struct {
	ID     uuid.UUID `json:"id"`
	HostID uuid.UUID `json:"host_id"`
}

func (q *Queries) RemoveOptionInfo(ctx context.Context, arg RemoveOptionInfoParams) error {
	_, err := q.db.Exec(ctx, removeOptionInfo, arg.ID, arg.HostID)
	return err
}

const updateOptionInfo = `-- name: UpdateOptionInfo :one
UPDATE options_infos
SET 
   is_active = COALESCE($1, is_active),
   is_complete = COALESCE($2, is_complete),
   is_verified = COALESCE($3, is_verified),
   category = COALESCE($4, category),
   category_two = COALESCE($5, category_two),
   category_three = COALESCE($6, category_three),
   category_four = COALESCE($7, category_four),
   updated_at = NOW()
WHERE id = $8 
RETURNING id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, created_at, completed, updated_at
`

type UpdateOptionInfoParams struct {
	IsActive      pgtype.Bool `json:"is_active"`
	IsComplete    pgtype.Bool `json:"is_complete"`
	IsVerified    pgtype.Bool `json:"is_verified"`
	Category      pgtype.Text `json:"category"`
	CategoryTwo   pgtype.Text `json:"category_two"`
	CategoryThree pgtype.Text `json:"category_three"`
	CategoryFour  pgtype.Text `json:"category_four"`
	ID            uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateOptionInfo(ctx context.Context, arg UpdateOptionInfoParams) (OptionsInfo, error) {
	row := q.db.QueryRow(ctx, updateOptionInfo,
		arg.IsActive,
		arg.IsComplete,
		arg.IsVerified,
		arg.Category,
		arg.CategoryTwo,
		arg.CategoryThree,
		arg.CategoryFour,
		arg.ID,
	)
	var i OptionsInfo
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOptionInfoComplete = `-- name: UpdateOptionInfoComplete :one
UPDATE options_infos
SET is_complete = $2,
   updated_at = NOW(),
   completed = NOW()
WHERE id = $1
RETURNING id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, created_at, completed, updated_at
`

type UpdateOptionInfoCompleteParams struct {
	ID         uuid.UUID `json:"id"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) UpdateOptionInfoComplete(ctx context.Context, arg UpdateOptionInfoCompleteParams) (OptionsInfo, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoComplete, arg.ID, arg.IsComplete)
	var i OptionsInfo
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOptionInfoCurrency = `-- name: UpdateOptionInfoCurrency :one
UPDATE options_infos
SET currency = $2,
   updated_at = NOW()
WHERE id = $1
RETURNING currency
`

type UpdateOptionInfoCurrencyParams struct {
	ID       uuid.UUID `json:"id"`
	Currency string    `json:"currency"`
}

func (q *Queries) UpdateOptionInfoCurrency(ctx context.Context, arg UpdateOptionInfoCurrencyParams) (string, error) {
	row := q.db.QueryRow(ctx, updateOptionInfoCurrency, arg.ID, arg.Currency)
	var currency string
	err := row.Scan(&currency)
	return currency, err
}
