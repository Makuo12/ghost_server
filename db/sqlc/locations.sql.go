// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: locations.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (
   option_id,
   street,
   city,
   state,
   country,
   postcode,
   geolocation,
   show_specific_location
) VALUES (
   $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING option_id, street, city, state, country, postcode, geolocation, show_specific_location, created_at, updated_at
`

type CreateLocationParams struct {
	OptionID             uuid.UUID    `json:"option_id"`
	Street               string       `json:"street"`
	City                 string       `json:"city"`
	State                string       `json:"state"`
	Country              string       `json:"country"`
	Postcode             string       `json:"postcode"`
	Geolocation          pgtype.Point `json:"geolocation"`
	ShowSpecificLocation bool         `json:"show_specific_location"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRow(ctx, createLocation,
		arg.OptionID,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.Postcode,
		arg.Geolocation,
		arg.ShowSpecificLocation,
	)
	var i Location
	err := row.Scan(
		&i.OptionID,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Geolocation,
		&i.ShowSpecificLocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLocation = `-- name: DeleteLocation :exec
DELETE FROM locations 
WHERE option_id = $1
`

func (q *Queries) DeleteLocation(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLocation, optionID)
	return err
}

const getLocation = `-- name: GetLocation :one
SELECT option_id, street, city, state, country, postcode, geolocation, show_specific_location, created_at, updated_at FROM locations
WHERE option_id = $1
LIMIT 1
`

func (q *Queries) GetLocation(ctx context.Context, optionID uuid.UUID) (Location, error) {
	row := q.db.QueryRow(ctx, getLocation, optionID)
	var i Location
	err := row.Scan(
		&i.OptionID,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Geolocation,
		&i.ShowSpecificLocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeLocation = `-- name: RemoveLocation :exec
DELETE FROM locations 
WHERE option_id = $1
`

func (q *Queries) RemoveLocation(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeLocation, optionID)
	return err
}

const updateLocation = `-- name: UpdateLocation :one
UPDATE locations
SET 
   street = COALESCE($1, street),
   city = COALESCE($2, city),
   state = COALESCE($3, state),
   country = COALESCE($4, country),
   postcode = COALESCE($5, postcode),
   geolocation = COALESCE($6, geolocation),
   show_specific_location = COALESCE($7, show_specific_location),
   updated_at = NOW()
WHERE option_id = $8 
RETURNING option_id, street, city, state, country, postcode, geolocation, show_specific_location, created_at, updated_at
`

type UpdateLocationParams struct {
	Street               pgtype.Text  `json:"street"`
	City                 pgtype.Text  `json:"city"`
	State                pgtype.Text  `json:"state"`
	Country              pgtype.Text  `json:"country"`
	Postcode             pgtype.Text  `json:"postcode"`
	Geolocation          pgtype.Point `json:"geolocation"`
	ShowSpecificLocation pgtype.Bool  `json:"show_specific_location"`
	OptionID             uuid.UUID    `json:"option_id"`
}

func (q *Queries) UpdateLocation(ctx context.Context, arg UpdateLocationParams) (Location, error) {
	row := q.db.QueryRow(ctx, updateLocation,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.Postcode,
		arg.Geolocation,
		arg.ShowSpecificLocation,
		arg.OptionID,
	)
	var i Location
	err := row.Scan(
		&i.OptionID,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Geolocation,
		&i.ShowSpecificLocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLocationTwo = `-- name: UpdateLocationTwo :one
UPDATE locations
SET 
   street = $1,
   city = $2,
   state = $3,
   country = $4,
   postcode = $5,
   geolocation = $6,
   updated_at = NOW()
WHERE option_id = $7
RETURNING option_id, street, city, state, country, postcode, geolocation, show_specific_location, created_at, updated_at
`

type UpdateLocationTwoParams struct {
	Street      string       `json:"street"`
	City        string       `json:"city"`
	State       string       `json:"state"`
	Country     string       `json:"country"`
	Postcode    string       `json:"postcode"`
	Geolocation pgtype.Point `json:"geolocation"`
	OptionID    uuid.UUID    `json:"option_id"`
}

func (q *Queries) UpdateLocationTwo(ctx context.Context, arg UpdateLocationTwoParams) (Location, error) {
	row := q.db.QueryRow(ctx, updateLocationTwo,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.Postcode,
		arg.Geolocation,
		arg.OptionID,
	)
	var i Location
	err := row.Scan(
		&i.OptionID,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Geolocation,
		&i.ShowSpecificLocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSpecificLocation = `-- name: UpdateSpecificLocation :one
UPDATE locations
SET 
   show_specific_location = $1,
   updated_at = NOW()
WHERE option_id = $2 
RETURNING option_id, street, city, state, country, postcode, geolocation, show_specific_location, created_at, updated_at
`

type UpdateSpecificLocationParams struct {
	ShowSpecificLocation bool      `json:"show_specific_location"`
	OptionID             uuid.UUID `json:"option_id"`
}

func (q *Queries) UpdateSpecificLocation(ctx context.Context, arg UpdateSpecificLocationParams) (Location, error) {
	row := q.db.QueryRow(ctx, updateSpecificLocation, arg.ShowSpecificLocation, arg.OptionID)
	var i Location
	err := row.Scan(
		&i.OptionID,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Geolocation,
		&i.ShowSpecificLocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
