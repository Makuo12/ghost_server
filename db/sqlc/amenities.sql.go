// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: amenities.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAmenity = `-- name: CreateAmenity :one
INSERT INTO amenities (
        option_id,
        tag,
        am_type,
        list_options,
        has_am

    )
VALUES (
        $1, $2, $3, $4, $5
    )
RETURNING id, option_id, tag, am_type, has_am, time_set, location_option, size_option, privacy_option, time_option, start_time, end_time, availability_option, start_month, end_month, type_option, price_option, brand_option, list_options, created_at, updated_at
`

type CreateAmenityParams struct {
	OptionID    uuid.UUID `json:"option_id"`
	Tag         string    `json:"tag"`
	AmType      string    `json:"am_type"`
	ListOptions []string  `json:"list_options"`
	HasAm       bool      `json:"has_am"`
}

func (q *Queries) CreateAmenity(ctx context.Context, arg CreateAmenityParams) (Amenity, error) {
	row := q.db.QueryRow(ctx, createAmenity,
		arg.OptionID,
		arg.Tag,
		arg.AmType,
		arg.ListOptions,
		arg.HasAm,
	)
	var i Amenity
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.Tag,
		&i.AmType,
		&i.HasAm,
		&i.TimeSet,
		&i.LocationOption,
		&i.SizeOption,
		&i.PrivacyOption,
		&i.TimeOption,
		&i.StartTime,
		&i.EndTime,
		&i.AvailabilityOption,
		&i.StartMonth,
		&i.EndMonth,
		&i.TypeOption,
		&i.PriceOption,
		&i.BrandOption,
		&i.ListOptions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAmenity = `-- name: GetAmenity :one
SELECT id, option_id, tag, am_type, has_am, time_set, location_option, size_option, privacy_option, time_option, start_time, end_time, availability_option, start_month, end_month, type_option, price_option, brand_option, list_options, created_at, updated_at
FROM amenities
WHERE id = $1
`

func (q *Queries) GetAmenity(ctx context.Context, id uuid.UUID) (Amenity, error) {
	row := q.db.QueryRow(ctx, getAmenity, id)
	var i Amenity
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.Tag,
		&i.AmType,
		&i.HasAm,
		&i.TimeSet,
		&i.LocationOption,
		&i.SizeOption,
		&i.PrivacyOption,
		&i.TimeOption,
		&i.StartTime,
		&i.EndTime,
		&i.AvailabilityOption,
		&i.StartMonth,
		&i.EndMonth,
		&i.TypeOption,
		&i.PriceOption,
		&i.BrandOption,
		&i.ListOptions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAmenityByType = `-- name: GetAmenityByType :one
SELECT id, option_id, tag, am_type, has_am, time_set, location_option, size_option, privacy_option, time_option, start_time, end_time, availability_option, start_month, end_month, type_option, price_option, brand_option, list_options, created_at, updated_at
FROM amenities
WHERE option_id = $1 AND am_type = $2 AND tag = $3
`

type GetAmenityByTypeParams struct {
	OptionID uuid.UUID `json:"option_id"`
	AmType   string    `json:"am_type"`
	Tag      string    `json:"tag"`
}

func (q *Queries) GetAmenityByType(ctx context.Context, arg GetAmenityByTypeParams) (Amenity, error) {
	row := q.db.QueryRow(ctx, getAmenityByType, arg.OptionID, arg.AmType, arg.Tag)
	var i Amenity
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.Tag,
		&i.AmType,
		&i.HasAm,
		&i.TimeSet,
		&i.LocationOption,
		&i.SizeOption,
		&i.PrivacyOption,
		&i.TimeOption,
		&i.StartTime,
		&i.EndTime,
		&i.AvailabilityOption,
		&i.StartMonth,
		&i.EndMonth,
		&i.TypeOption,
		&i.PriceOption,
		&i.BrandOption,
		&i.ListOptions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAmenityDetail = `-- name: GetAmenityDetail :one
SELECT id, tag, location_option, size_option, privacy_option, time_set, time_option, start_time, end_time, availability_option, start_month, end_month, type_option, price_option, brand_option, list_options
FROM amenities
WHERE option_id = $1 AND am_type = $2 AND tag = $3
`

type GetAmenityDetailParams struct {
	OptionID uuid.UUID `json:"option_id"`
	AmType   string    `json:"am_type"`
	Tag      string    `json:"tag"`
}

type GetAmenityDetailRow struct {
	ID                 uuid.UUID `json:"id"`
	Tag                string    `json:"tag"`
	LocationOption     string    `json:"location_option"`
	SizeOption         int32     `json:"size_option"`
	PrivacyOption      string    `json:"privacy_option"`
	TimeSet            bool      `json:"time_set"`
	TimeOption         string    `json:"time_option"`
	StartTime          time.Time `json:"start_time"`
	EndTime            time.Time `json:"end_time"`
	AvailabilityOption string    `json:"availability_option"`
	StartMonth         string    `json:"start_month"`
	EndMonth           string    `json:"end_month"`
	TypeOption         string    `json:"type_option"`
	PriceOption        string    `json:"price_option"`
	BrandOption        string    `json:"brand_option"`
	ListOptions        []string  `json:"list_options"`
}

func (q *Queries) GetAmenityDetail(ctx context.Context, arg GetAmenityDetailParams) (GetAmenityDetailRow, error) {
	row := q.db.QueryRow(ctx, getAmenityDetail, arg.OptionID, arg.AmType, arg.Tag)
	var i GetAmenityDetailRow
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.LocationOption,
		&i.SizeOption,
		&i.PrivacyOption,
		&i.TimeSet,
		&i.TimeOption,
		&i.StartTime,
		&i.EndTime,
		&i.AvailabilityOption,
		&i.StartMonth,
		&i.EndMonth,
		&i.TypeOption,
		&i.PriceOption,
		&i.BrandOption,
		&i.ListOptions,
	)
	return i, err
}

const getAmenityDetailByOptionUserID = `-- name: GetAmenityDetailByOptionUserID :one
SELECT a.id, a.tag, a.location_option, a.size_option, a.privacy_option, a.time_set, a.time_option, a.start_time, a.end_time, a.availability_option, a.start_month, a.end_month, a.type_option, a.price_option, a.brand_option, a.list_options
FROM amenities a
    JOIN options_infos o_i on a.option_id = o_i.id
WHERE o_i.option_user_id = $1 AND a.tag = $2
`

type GetAmenityDetailByOptionUserIDParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	Tag          string    `json:"tag"`
}

type GetAmenityDetailByOptionUserIDRow struct {
	ID                 uuid.UUID `json:"id"`
	Tag                string    `json:"tag"`
	LocationOption     string    `json:"location_option"`
	SizeOption         int32     `json:"size_option"`
	PrivacyOption      string    `json:"privacy_option"`
	TimeSet            bool      `json:"time_set"`
	TimeOption         string    `json:"time_option"`
	StartTime          time.Time `json:"start_time"`
	EndTime            time.Time `json:"end_time"`
	AvailabilityOption string    `json:"availability_option"`
	StartMonth         string    `json:"start_month"`
	EndMonth           string    `json:"end_month"`
	TypeOption         string    `json:"type_option"`
	PriceOption        string    `json:"price_option"`
	BrandOption        string    `json:"brand_option"`
	ListOptions        []string  `json:"list_options"`
}

func (q *Queries) GetAmenityDetailByOptionUserID(ctx context.Context, arg GetAmenityDetailByOptionUserIDParams) (GetAmenityDetailByOptionUserIDRow, error) {
	row := q.db.QueryRow(ctx, getAmenityDetailByOptionUserID, arg.OptionUserID, arg.Tag)
	var i GetAmenityDetailByOptionUserIDRow
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.LocationOption,
		&i.SizeOption,
		&i.PrivacyOption,
		&i.TimeSet,
		&i.TimeOption,
		&i.StartTime,
		&i.EndTime,
		&i.AvailabilityOption,
		&i.StartMonth,
		&i.EndMonth,
		&i.TypeOption,
		&i.PriceOption,
		&i.BrandOption,
		&i.ListOptions,
	)
	return i, err
}

const listAmenities = `-- name: ListAmenities :many
SELECT id, option_id, tag, am_type, has_am, time_set, location_option, size_option, privacy_option, time_option, start_time, end_time, availability_option, start_month, end_month, type_option, price_option, brand_option, list_options, created_at, updated_at
FROM amenities
WHERE option_id = $1 AND has_am = $2
`

type ListAmenitiesParams struct {
	OptionID uuid.UUID `json:"option_id"`
	HasAm    bool      `json:"has_am"`
}

func (q *Queries) ListAmenities(ctx context.Context, arg ListAmenitiesParams) ([]Amenity, error) {
	rows, err := q.db.Query(ctx, listAmenities, arg.OptionID, arg.HasAm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Amenity{}
	for rows.Next() {
		var i Amenity
		if err := rows.Scan(
			&i.ID,
			&i.OptionID,
			&i.Tag,
			&i.AmType,
			&i.HasAm,
			&i.TimeSet,
			&i.LocationOption,
			&i.SizeOption,
			&i.PrivacyOption,
			&i.TimeOption,
			&i.StartTime,
			&i.EndTime,
			&i.AvailabilityOption,
			&i.StartMonth,
			&i.EndMonth,
			&i.TypeOption,
			&i.PriceOption,
			&i.BrandOption,
			&i.ListOptions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAmenitiesOne = `-- name: ListAmenitiesOne :many
SELECT tag, am_type, has_am, id
FROM amenities
WHERE option_id = $1
`

type ListAmenitiesOneRow struct {
	Tag    string    `json:"tag"`
	AmType string    `json:"am_type"`
	HasAm  bool      `json:"has_am"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) ListAmenitiesOne(ctx context.Context, optionID uuid.UUID) ([]ListAmenitiesOneRow, error) {
	rows, err := q.db.Query(ctx, listAmenitiesOne, optionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAmenitiesOneRow{}
	for rows.Next() {
		var i ListAmenitiesOneRow
		if err := rows.Scan(
			&i.Tag,
			&i.AmType,
			&i.HasAm,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAmenitiesTag = `-- name: ListAmenitiesTag :many
SELECT tag
FROM amenities
WHERE option_id = $1 AND has_am = $2
`

type ListAmenitiesTagParams struct {
	OptionID uuid.UUID `json:"option_id"`
	HasAm    bool      `json:"has_am"`
}

func (q *Queries) ListAmenitiesTag(ctx context.Context, arg ListAmenitiesTagParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listAmenitiesTag, arg.OptionID, arg.HasAm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllAmenity = `-- name: RemoveAllAmenity :exec
DELETE FROM amenities
WHERE option_id = $1
`

func (q *Queries) RemoveAllAmenity(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAllAmenity, optionID)
	return err
}

const removeAmenity = `-- name: RemoveAmenity :exec
DELETE FROM amenities
WHERE id = $1
`

func (q *Queries) RemoveAmenity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAmenity, id)
	return err
}

const updateAmenity = `-- name: UpdateAmenity :one
UPDATE amenities
    SET has_am = $1, 
    updated_at = NOW()
WHERE id = $2
RETURNING tag, am_type, has_am, id
`

type UpdateAmenityParams struct {
	HasAm bool      `json:"has_am"`
	ID    uuid.UUID `json:"id"`
}

type UpdateAmenityRow struct {
	Tag    string    `json:"tag"`
	AmType string    `json:"am_type"`
	HasAm  bool      `json:"has_am"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateAmenity(ctx context.Context, arg UpdateAmenityParams) (UpdateAmenityRow, error) {
	row := q.db.QueryRow(ctx, updateAmenity, arg.HasAm, arg.ID)
	var i UpdateAmenityRow
	err := row.Scan(
		&i.Tag,
		&i.AmType,
		&i.HasAm,
		&i.ID,
	)
	return i, err
}

const updateAmenityDetail = `-- name: UpdateAmenityDetail :one
UPDATE amenities
    SET location_option = $1,
    size_option = $2,
    privacy_option = $3,
    time_option = $4,
    start_time = $5,
    end_time = $6,
    availability_option = $7,
    start_month = $8,
    end_month = $9,
    type_option = $10,
    price_option = $11,
    brand_option = $12,
    list_options = $13,
    time_set = $14,
    updated_at = NOW()
WHERE id = $15 AND option_id = $16
RETURNING id, tag, location_option, size_option, privacy_option, time_set, time_option, start_time, end_time, availability_option, start_month, end_month, type_option, price_option, brand_option, list_options
`

type UpdateAmenityDetailParams struct {
	LocationOption     string    `json:"location_option"`
	SizeOption         int32     `json:"size_option"`
	PrivacyOption      string    `json:"privacy_option"`
	TimeOption         string    `json:"time_option"`
	StartTime          time.Time `json:"start_time"`
	EndTime            time.Time `json:"end_time"`
	AvailabilityOption string    `json:"availability_option"`
	StartMonth         string    `json:"start_month"`
	EndMonth           string    `json:"end_month"`
	TypeOption         string    `json:"type_option"`
	PriceOption        string    `json:"price_option"`
	BrandOption        string    `json:"brand_option"`
	ListOptions        []string  `json:"list_options"`
	TimeSet            bool      `json:"time_set"`
	ID                 uuid.UUID `json:"id"`
	OptionID           uuid.UUID `json:"option_id"`
}

type UpdateAmenityDetailRow struct {
	ID                 uuid.UUID `json:"id"`
	Tag                string    `json:"tag"`
	LocationOption     string    `json:"location_option"`
	SizeOption         int32     `json:"size_option"`
	PrivacyOption      string    `json:"privacy_option"`
	TimeSet            bool      `json:"time_set"`
	TimeOption         string    `json:"time_option"`
	StartTime          time.Time `json:"start_time"`
	EndTime            time.Time `json:"end_time"`
	AvailabilityOption string    `json:"availability_option"`
	StartMonth         string    `json:"start_month"`
	EndMonth           string    `json:"end_month"`
	TypeOption         string    `json:"type_option"`
	PriceOption        string    `json:"price_option"`
	BrandOption        string    `json:"brand_option"`
	ListOptions        []string  `json:"list_options"`
}

func (q *Queries) UpdateAmenityDetail(ctx context.Context, arg UpdateAmenityDetailParams) (UpdateAmenityDetailRow, error) {
	row := q.db.QueryRow(ctx, updateAmenityDetail,
		arg.LocationOption,
		arg.SizeOption,
		arg.PrivacyOption,
		arg.TimeOption,
		arg.StartTime,
		arg.EndTime,
		arg.AvailabilityOption,
		arg.StartMonth,
		arg.EndMonth,
		arg.TypeOption,
		arg.PriceOption,
		arg.BrandOption,
		arg.ListOptions,
		arg.TimeSet,
		arg.ID,
		arg.OptionID,
	)
	var i UpdateAmenityDetailRow
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.LocationOption,
		&i.SizeOption,
		&i.PrivacyOption,
		&i.TimeSet,
		&i.TimeOption,
		&i.StartTime,
		&i.EndTime,
		&i.AvailabilityOption,
		&i.StartMonth,
		&i.EndMonth,
		&i.TypeOption,
		&i.PriceOption,
		&i.BrandOption,
		&i.ListOptions,
	)
	return i, err
}
