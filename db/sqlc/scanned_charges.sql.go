// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: scanned_charges.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createScannedCharge = `-- name: CreateScannedCharge :one
INSERT INTO scanned_charges (
    charge_id,
    scanned,
    scanned_by,
    charge_type,
    scanned_time
) VALUES ($1, $2, $3, $4, $5)
RETURNING charge_id, scanned, scanned_by, scanned_time, charge_type, created_at, updated_at
`

type CreateScannedChargeParams struct {
	ChargeID    uuid.UUID `json:"charge_id"`
	Scanned     bool      `json:"scanned"`
	ScannedBy   uuid.UUID `json:"scanned_by"`
	ChargeType  string    `json:"charge_type"`
	ScannedTime time.Time `json:"scanned_time"`
}

func (q *Queries) CreateScannedCharge(ctx context.Context, arg CreateScannedChargeParams) (ScannedCharge, error) {
	row := q.db.QueryRow(ctx, createScannedCharge,
		arg.ChargeID,
		arg.Scanned,
		arg.ScannedBy,
		arg.ChargeType,
		arg.ScannedTime,
	)
	var i ScannedCharge
	err := row.Scan(
		&i.ChargeID,
		&i.Scanned,
		&i.ScannedBy,
		&i.ScannedTime,
		&i.ChargeType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScannedChargeOption = `-- name: GetScannedChargeOption :one
SELECT sc.scanned, co.option_user_id, co.id AS charge_id, sc.scanned_by, sc.scanned_time, u.first_name AS scanned_by_name, u.photo AS scanned_by_profile_photo  
FROM charge_option_references co
    LEFT JOIN scanned_charges sc ON sc.charge_id = co.id
    LEFT JOIN users u ON u.user_id = sc.scanned_by
WHERE co.id = $1 AND co.user_id = $2 AND co.is_complete = $3 AND co.cancelled = $4
`

type GetScannedChargeOptionParams struct {
	ChargeID         uuid.UUID `json:"charge_id"`
	UserID           uuid.UUID `json:"user_id"`
	PaymentCompleted bool      `json:"payment_completed"`
	Cancelled        bool      `json:"cancelled"`
}

type GetScannedChargeOptionRow struct {
	Scanned               pgtype.Bool        `json:"scanned"`
	OptionUserID          uuid.UUID          `json:"option_user_id"`
	ChargeID              uuid.UUID          `json:"charge_id"`
	ScannedBy             pgtype.UUID        `json:"scanned_by"`
	ScannedTime           pgtype.Timestamptz `json:"scanned_time"`
	ScannedByName         pgtype.Text        `json:"scanned_by_name"`
	ScannedByProfilePhoto pgtype.Text        `json:"scanned_by_profile_photo"`
}

func (q *Queries) GetScannedChargeOption(ctx context.Context, arg GetScannedChargeOptionParams) (GetScannedChargeOptionRow, error) {
	row := q.db.QueryRow(ctx, getScannedChargeOption,
		arg.ChargeID,
		arg.UserID,
		arg.PaymentCompleted,
		arg.Cancelled,
	)
	var i GetScannedChargeOptionRow
	err := row.Scan(
		&i.Scanned,
		&i.OptionUserID,
		&i.ChargeID,
		&i.ScannedBy,
		&i.ScannedTime,
		&i.ScannedByName,
		&i.ScannedByProfilePhoto,
	)
	return i, err
}

const getScannedChargeOptionByHost = `-- name: GetScannedChargeOptionByHost :one
SELECT oi.id,
oi.co_host_id,
oi.option_user_id,
oi.host_id,
oi.primary_user_id,
oi.is_active,
oi.is_complete,
oi.is_verified,
od.host_name_option,
oi.category,
oi.category_two,
oi.category_three,
oi.category_four,
oi.is_top_seller,
oi.time_zone,
oi.currency,
oi.option_img,
oi.option_type,
oi.main_option_type,
oi.created_at,
oi.completed,
oi.updated_at,
u.id AS u_id,
u.user_id,
u.firebase_id,
u.hashed_password,
u.firebase_password,
u.email,
u.phone_number,
u.first_name,
u.username,
u.last_name,
u.date_of_birth,
u.dial_code,
u.dial_country,
u.current_option_id,
u.currency,
u.default_card,
u.default_payout_card,
u.default_account_id,
u.is_active AS u_is_active,
u.photo,
u.password_changed_at AS u_password_changed_at,
u.created_at AS u_created_at,
u.updated_at AS u_updated_at,
us.first_name AS guest_first_name,
us.id AS guest_id,
co.start_date,
co.end_date,
CASE WHEN sc.scanned IS NOT NULL THEN sc.scanned::boolean
	ELSE false
END AS stay_scanned,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.calender::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS calender,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_co_hosts::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_co_hosts,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_option_info::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_option_info,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_event_dates_times::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_event_dates_times,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.post::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS post,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.scan_code::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS scan_code,
CASE WHEN och_subquery.reservations IS NOT NULL THEN och_subquery.scan_code::boolean
    WHEN oi.host_id = $1 THEN true
    ELSE false -- Optional: Handle other cases if needed
END AS reservations,
CASE WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
     WHEN oi.host_id = $1 THEN 'main_host'
     ELSE 'none' -- Optional: Handle other cases if needed
END AS host_type
FROM charge_option_references co 
LEFT JOIN scanned_charges sc ON sc.charge_id = co.id
JOIN options_infos oi ON oi.option_user_id = co.option_user_id
JOIN options_info_details od ON od.option_id = oi.id
JOIN users u ON u.id = oi.host_id
JOIN users us ON us.user_id = co.user_id
LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, edit_option_info, edit_event_dates_times
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE ((oi.id = $3 AND oi.host_id = $1) OR (oi.co_host_id = $4 AND och_subquery.option_id IS NOT NULL)) 
AND oi.is_complete = true AND co.id = $5 AND co.is_complete = true AND co.cancelled = false AND co.user_id = $6
`

type GetScannedChargeOptionByHostParams struct {
	MainHostID     uuid.UUID `json:"main_host_id"`
	CoUserID       string    `json:"co_user_id"`
	OptionID       uuid.UUID `json:"option_id"`
	OptionCoHostID uuid.UUID `json:"option_co_host_id"`
	ChargeOptionID uuid.UUID `json:"charge_option_id"`
	GuestUserID    uuid.UUID `json:"guest_user_id"`
}

type GetScannedChargeOptionByHostRow struct {
	ID                  uuid.UUID `json:"id"`
	CoHostID            uuid.UUID `json:"co_host_id"`
	OptionUserID        uuid.UUID `json:"option_user_id"`
	HostID              uuid.UUID `json:"host_id"`
	PrimaryUserID       uuid.UUID `json:"primary_user_id"`
	IsActive            bool      `json:"is_active"`
	IsComplete          bool      `json:"is_complete"`
	IsVerified          bool      `json:"is_verified"`
	HostNameOption      string    `json:"host_name_option"`
	Category            string    `json:"category"`
	CategoryTwo         string    `json:"category_two"`
	CategoryThree       string    `json:"category_three"`
	CategoryFour        string    `json:"category_four"`
	IsTopSeller         bool      `json:"is_top_seller"`
	TimeZone            string    `json:"time_zone"`
	Currency            string    `json:"currency"`
	OptionImg           string    `json:"option_img"`
	OptionType          string    `json:"option_type"`
	MainOptionType      string    `json:"main_option_type"`
	CreatedAt           time.Time `json:"created_at"`
	Completed           time.Time `json:"completed"`
	UpdatedAt           time.Time `json:"updated_at"`
	UID                 uuid.UUID `json:"u_id"`
	UserID              uuid.UUID `json:"user_id"`
	FirebaseID          uuid.UUID `json:"firebase_id"`
	HashedPassword      string    `json:"hashed_password"`
	FirebasePassword    string    `json:"firebase_password"`
	Email               string    `json:"email"`
	PhoneNumber         string    `json:"phone_number"`
	FirstName           string    `json:"first_name"`
	Username            string    `json:"username"`
	LastName            string    `json:"last_name"`
	DateOfBirth         time.Time `json:"date_of_birth"`
	DialCode            string    `json:"dial_code"`
	DialCountry         string    `json:"dial_country"`
	CurrentOptionID     string    `json:"current_option_id"`
	Currency_2          string    `json:"currency_2"`
	DefaultCard         string    `json:"default_card"`
	DefaultPayoutCard   string    `json:"default_payout_card"`
	DefaultAccountID    string    `json:"default_account_id"`
	UIsActive           bool      `json:"u_is_active"`
	Photo               string    `json:"photo"`
	UPasswordChangedAt  time.Time `json:"u_password_changed_at"`
	UCreatedAt          time.Time `json:"u_created_at"`
	UUpdatedAt          time.Time `json:"u_updated_at"`
	GuestFirstName      string    `json:"guest_first_name"`
	GuestID             uuid.UUID `json:"guest_id"`
	StartDate           time.Time `json:"start_date"`
	EndDate             time.Time `json:"end_date"`
	StayScanned         bool      `json:"stay_scanned"`
	Calender            bool      `json:"calender"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Reservations        bool      `json:"reservations"`
	HostType            string    `json:"host_type"`
}

func (q *Queries) GetScannedChargeOptionByHost(ctx context.Context, arg GetScannedChargeOptionByHostParams) (GetScannedChargeOptionByHostRow, error) {
	row := q.db.QueryRow(ctx, getScannedChargeOptionByHost,
		arg.MainHostID,
		arg.CoUserID,
		arg.OptionID,
		arg.OptionCoHostID,
		arg.ChargeOptionID,
		arg.GuestUserID,
	)
	var i GetScannedChargeOptionByHostRow
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.HostNameOption,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
		&i.UID,
		&i.UserID,
		&i.FirebaseID,
		&i.HashedPassword,
		&i.FirebasePassword,
		&i.Email,
		&i.PhoneNumber,
		&i.FirstName,
		&i.Username,
		&i.LastName,
		&i.DateOfBirth,
		&i.DialCode,
		&i.DialCountry,
		&i.CurrentOptionID,
		&i.Currency_2,
		&i.DefaultCard,
		&i.DefaultPayoutCard,
		&i.DefaultAccountID,
		&i.UIsActive,
		&i.Photo,
		&i.UPasswordChangedAt,
		&i.UCreatedAt,
		&i.UUpdatedAt,
		&i.GuestFirstName,
		&i.GuestID,
		&i.StartDate,
		&i.EndDate,
		&i.StayScanned,
		&i.Calender,
		&i.EditCoHosts,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.Post,
		&i.ScanCode,
		&i.Reservations,
		&i.HostType,
	)
	return i, err
}

const getScannedChargeTicket = `-- name: GetScannedChargeTicket :one
SELECT sc.scanned, ce.option_user_id, ct.id AS charge_id, sc.scanned_by, sc.scanned_time, ct.grade, u.first_name AS scanned_by_name, u.photo AS scanned_by_profile_photo, ct.ticket_type 
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    LEFT JOIN scanned_charges sc ON sc.charge_id = ct.id
    LEFT JOIN users u ON u.user_id = sc.scanned_by
WHERE ct.id = $1 AND ce.user_id = $2 AND ce.is_complete = $3 AND ct.cancelled = $4
`

type GetScannedChargeTicketParams struct {
	ChargeID         uuid.UUID `json:"charge_id"`
	UserID           uuid.UUID `json:"user_id"`
	PaymentCompleted bool      `json:"payment_completed"`
	Cancelled        bool      `json:"cancelled"`
}

type GetScannedChargeTicketRow struct {
	Scanned               pgtype.Bool        `json:"scanned"`
	OptionUserID          uuid.UUID          `json:"option_user_id"`
	ChargeID              uuid.UUID          `json:"charge_id"`
	ScannedBy             pgtype.UUID        `json:"scanned_by"`
	ScannedTime           pgtype.Timestamptz `json:"scanned_time"`
	Grade                 string             `json:"grade"`
	ScannedByName         pgtype.Text        `json:"scanned_by_name"`
	ScannedByProfilePhoto pgtype.Text        `json:"scanned_by_profile_photo"`
	TicketType            string             `json:"ticket_type"`
}

func (q *Queries) GetScannedChargeTicket(ctx context.Context, arg GetScannedChargeTicketParams) (GetScannedChargeTicketRow, error) {
	row := q.db.QueryRow(ctx, getScannedChargeTicket,
		arg.ChargeID,
		arg.UserID,
		arg.PaymentCompleted,
		arg.Cancelled,
	)
	var i GetScannedChargeTicketRow
	err := row.Scan(
		&i.Scanned,
		&i.OptionUserID,
		&i.ChargeID,
		&i.ScannedBy,
		&i.ScannedTime,
		&i.Grade,
		&i.ScannedByName,
		&i.ScannedByProfilePhoto,
		&i.TicketType,
	)
	return i, err
}

const getScannedChargeTicketByHost = `-- name: GetScannedChargeTicketByHost :one
SELECT oi.id,
oi.co_host_id,
oi.option_user_id,
oi.host_id,
oi.primary_user_id,
oi.is_active,
oi.is_complete,
oi.is_verified,
od.host_name_option,
oi.category,
oi.category_two,
oi.category_three,
oi.category_four,
oi.is_top_seller,
oi.time_zone,
oi.currency,
oi.option_img,
oi.option_type,
oi.main_option_type,
oi.created_at,
oi.completed,
oi.updated_at,
u.id AS u_id,
u.user_id,
u.firebase_id,
u.hashed_password,
u.firebase_password,
u.email,
u.phone_number,
u.first_name,
u.username,
u.last_name,
u.date_of_birth,
u.dial_code,
u.dial_country,
u.current_option_id,
u.currency,
u.default_card,
u.default_payout_card,
u.default_account_id,
u.is_active AS u_is_active,
u.photo,
u.password_changed_at AS u_password_changed_at,
u.created_at AS u_created_at,
u.updated_at AS u_updated_at,
us.first_name AS guest_first_name,
us.id AS guest_id,
ct.ticket_type AS ticket_type,
ct.grade AS ticket_grade,
cd.start_date AS event_start_date,
cd.end_date AS event_end_date,
CASE WHEN sc.scanned IS NOT NULL THEN sc.scanned::boolean
	ELSE false
END AS ticket_scanned,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.calender::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS calender,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_co_hosts::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_co_hosts,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_option_info::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_option_info,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.edit_event_dates_times::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS edit_event_dates_times,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.post::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS post,
CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.scan_code::boolean
     WHEN oi.host_id = $1 THEN true
	ELSE false -- Optional: Handle other cases if needed
END AS scan_code,
CASE WHEN och_subquery.reservations IS NOT NULL THEN och_subquery.scan_code::boolean
    WHEN oi.host_id = $1 THEN true
    ELSE false -- Optional: Handle other cases if needed
END AS reservations,
CASE WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
     WHEN oi.host_id = $1 THEN 'main_host'
     ELSE 'none' -- Optional: Handle other cases if needed
END AS host_type
FROM charge_ticket_references ct
LEFT JOIN scanned_charges sc ON sc.charge_id = ct.id
JOIN charge_date_references cd ON cd.id = ct.charge_date_id
JOIN charge_event_references ce ON ce.id = cd.charge_event_id
JOIN options_infos oi ON oi.option_user_id = ce.option_user_id
JOIN options_info_details od ON od.option_id = oi.id
JOIN users u ON u.id = oi.host_id
JOIN users us ON us.user_id = ce.user_id
LEFT JOIN (
   SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, edit_option_info, edit_event_dates_times
   FROM option_co_hosts AS och
   WHERE och.co_user_id = $2 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE ((oi.id = $3 AND oi.host_id = $1) OR (oi.co_host_id = $4 AND och_subquery.option_id IS NOT NULL)) 
AND oi.is_complete = true AND ct.id = $5 AND ce.is_complete = true AND ct.cancelled = false AND DATE(cd.start_date) = DATE($6) AND cd.event_date_id = $7 AND ce.user_id = $8
`

type GetScannedChargeTicketByHostParams struct {
	MainHostID        uuid.UUID   `json:"main_host_id"`
	CoUserID          string      `json:"co_user_id"`
	OptionID          uuid.UUID   `json:"option_id"`
	OptionCoHostID    uuid.UUID   `json:"option_co_host_id"`
	ChargeTicketID    uuid.UUID   `json:"charge_ticket_id"`
	ChargeStartDate   interface{} `json:"charge_start_date"`
	ChargeEventDateID uuid.UUID   `json:"charge_event_date_id"`
	GuestUserID       uuid.UUID   `json:"guest_user_id"`
}

type GetScannedChargeTicketByHostRow struct {
	ID                  uuid.UUID `json:"id"`
	CoHostID            uuid.UUID `json:"co_host_id"`
	OptionUserID        uuid.UUID `json:"option_user_id"`
	HostID              uuid.UUID `json:"host_id"`
	PrimaryUserID       uuid.UUID `json:"primary_user_id"`
	IsActive            bool      `json:"is_active"`
	IsComplete          bool      `json:"is_complete"`
	IsVerified          bool      `json:"is_verified"`
	HostNameOption      string    `json:"host_name_option"`
	Category            string    `json:"category"`
	CategoryTwo         string    `json:"category_two"`
	CategoryThree       string    `json:"category_three"`
	CategoryFour        string    `json:"category_four"`
	IsTopSeller         bool      `json:"is_top_seller"`
	TimeZone            string    `json:"time_zone"`
	Currency            string    `json:"currency"`
	OptionImg           string    `json:"option_img"`
	OptionType          string    `json:"option_type"`
	MainOptionType      string    `json:"main_option_type"`
	CreatedAt           time.Time `json:"created_at"`
	Completed           time.Time `json:"completed"`
	UpdatedAt           time.Time `json:"updated_at"`
	UID                 uuid.UUID `json:"u_id"`
	UserID              uuid.UUID `json:"user_id"`
	FirebaseID          uuid.UUID `json:"firebase_id"`
	HashedPassword      string    `json:"hashed_password"`
	FirebasePassword    string    `json:"firebase_password"`
	Email               string    `json:"email"`
	PhoneNumber         string    `json:"phone_number"`
	FirstName           string    `json:"first_name"`
	Username            string    `json:"username"`
	LastName            string    `json:"last_name"`
	DateOfBirth         time.Time `json:"date_of_birth"`
	DialCode            string    `json:"dial_code"`
	DialCountry         string    `json:"dial_country"`
	CurrentOptionID     string    `json:"current_option_id"`
	Currency_2          string    `json:"currency_2"`
	DefaultCard         string    `json:"default_card"`
	DefaultPayoutCard   string    `json:"default_payout_card"`
	DefaultAccountID    string    `json:"default_account_id"`
	UIsActive           bool      `json:"u_is_active"`
	Photo               string    `json:"photo"`
	UPasswordChangedAt  time.Time `json:"u_password_changed_at"`
	UCreatedAt          time.Time `json:"u_created_at"`
	UUpdatedAt          time.Time `json:"u_updated_at"`
	GuestFirstName      string    `json:"guest_first_name"`
	GuestID             uuid.UUID `json:"guest_id"`
	TicketType          string    `json:"ticket_type"`
	TicketGrade         string    `json:"ticket_grade"`
	EventStartDate      time.Time `json:"event_start_date"`
	EventEndDate        time.Time `json:"event_end_date"`
	TicketScanned       bool      `json:"ticket_scanned"`
	Calender            bool      `json:"calender"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Reservations        bool      `json:"reservations"`
	HostType            string    `json:"host_type"`
}

func (q *Queries) GetScannedChargeTicketByHost(ctx context.Context, arg GetScannedChargeTicketByHostParams) (GetScannedChargeTicketByHostRow, error) {
	row := q.db.QueryRow(ctx, getScannedChargeTicketByHost,
		arg.MainHostID,
		arg.CoUserID,
		arg.OptionID,
		arg.OptionCoHostID,
		arg.ChargeTicketID,
		arg.ChargeStartDate,
		arg.ChargeEventDateID,
		arg.GuestUserID,
	)
	var i GetScannedChargeTicketByHostRow
	err := row.Scan(
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.HostNameOption,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt,
		&i.Completed,
		&i.UpdatedAt,
		&i.UID,
		&i.UserID,
		&i.FirebaseID,
		&i.HashedPassword,
		&i.FirebasePassword,
		&i.Email,
		&i.PhoneNumber,
		&i.FirstName,
		&i.Username,
		&i.LastName,
		&i.DateOfBirth,
		&i.DialCode,
		&i.DialCountry,
		&i.CurrentOptionID,
		&i.Currency_2,
		&i.DefaultCard,
		&i.DefaultPayoutCard,
		&i.DefaultAccountID,
		&i.UIsActive,
		&i.Photo,
		&i.UPasswordChangedAt,
		&i.UCreatedAt,
		&i.UUpdatedAt,
		&i.GuestFirstName,
		&i.GuestID,
		&i.TicketType,
		&i.TicketGrade,
		&i.EventStartDate,
		&i.EventEndDate,
		&i.TicketScanned,
		&i.Calender,
		&i.EditCoHosts,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.Post,
		&i.ScanCode,
		&i.Reservations,
		&i.HostType,
	)
	return i, err
}

const getScannedChargeTicketByID = `-- name: GetScannedChargeTicketByID :one
SELECT sc.scanned, ce.option_user_id, sc.charge_id, sc.scanned_by, sc.scanned_time, ct.grade, od.host_name_option, cd.start_date, cd.end_date, su.first_name AS scanned_by_name, mu.first_name AS user_name, mu.user_id AS user_id 
FROM scanned_charges sc
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_ticket_references ct ON sc.charge_id = ct.id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_info_details od ON od.option_id = oi.id
    JOIN users su ON su.user_id = sc.scanned_by
    JOIN users mu ON mu.user_id = ce.user_id
WHERE sc.charge_id = $1 AND ce.is_complete = $2 AND ct.cancelled = $3 AND sc.scanned = $4 AND charge_type = 'charge_ticket_references'
`

type GetScannedChargeTicketByIDParams struct {
	ChargeID         uuid.UUID `json:"charge_id"`
	PaymentCompleted bool      `json:"payment_completed"`
	Cancelled        bool      `json:"cancelled"`
	ChargeScanned    bool      `json:"charge_scanned"`
}

type GetScannedChargeTicketByIDRow struct {
	Scanned        bool      `json:"scanned"`
	OptionUserID   uuid.UUID `json:"option_user_id"`
	ChargeID       uuid.UUID `json:"charge_id"`
	ScannedBy      uuid.UUID `json:"scanned_by"`
	ScannedTime    time.Time `json:"scanned_time"`
	Grade          string    `json:"grade"`
	HostNameOption string    `json:"host_name_option"`
	StartDate      time.Time `json:"start_date"`
	EndDate        time.Time `json:"end_date"`
	ScannedByName  string    `json:"scanned_by_name"`
	UserName       string    `json:"user_name"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) GetScannedChargeTicketByID(ctx context.Context, arg GetScannedChargeTicketByIDParams) (GetScannedChargeTicketByIDRow, error) {
	row := q.db.QueryRow(ctx, getScannedChargeTicketByID,
		arg.ChargeID,
		arg.PaymentCompleted,
		arg.Cancelled,
		arg.ChargeScanned,
	)
	var i GetScannedChargeTicketByIDRow
	err := row.Scan(
		&i.Scanned,
		&i.OptionUserID,
		&i.ChargeID,
		&i.ScannedBy,
		&i.ScannedTime,
		&i.Grade,
		&i.HostNameOption,
		&i.StartDate,
		&i.EndDate,
		&i.ScannedByName,
		&i.UserName,
		&i.UserID,
	)
	return i, err
}
