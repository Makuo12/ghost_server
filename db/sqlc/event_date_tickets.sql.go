// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: event_date_tickets.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEventDateTicket = `-- name: CreateEventDateTicket :one
INSERT INTO event_date_tickets (
        event_date_time_id,
        start_date,
        end_date,
        start_time,
        end_time,
        name,
        capacity,
        price,
        absorb_fees,
        description,
        type,
        level,
        ticket_type,
        num_of_seats,
        free_refreshment

    )
VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
    )
RETURNING id, event_date_time_id, start_date, end_date, start_time, end_time, deep_link_id, name, is_active, price, absorb_fees, description, capacity, capacity_sold, type, level, ticket_type, num_of_seats, free_refreshment, created_at, updated_at
`

type CreateEventDateTicketParams struct {
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	StartTime       time.Time `json:"start_time"`
	EndTime         time.Time `json:"end_time"`
	Name            string    `json:"name"`
	Capacity        int32     `json:"capacity"`
	Price           int64     `json:"price"`
	AbsorbFees      bool      `json:"absorb_fees"`
	Description     string    `json:"description"`
	Type            string    `json:"type"`
	Level           string    `json:"level"`
	TicketType      string    `json:"ticket_type"`
	NumOfSeats      int32     `json:"num_of_seats"`
	FreeRefreshment bool      `json:"free_refreshment"`
}

func (q *Queries) CreateEventDateTicket(ctx context.Context, arg CreateEventDateTicketParams) (EventDateTicket, error) {
	row := q.db.QueryRow(ctx, createEventDateTicket,
		arg.EventDateTimeID,
		arg.StartDate,
		arg.EndDate,
		arg.StartTime,
		arg.EndTime,
		arg.Name,
		arg.Capacity,
		arg.Price,
		arg.AbsorbFees,
		arg.Description,
		arg.Type,
		arg.Level,
		arg.TicketType,
		arg.NumOfSeats,
		arg.FreeRefreshment,
	)
	var i EventDateTicket
	err := row.Scan(
		&i.ID,
		&i.EventDateTimeID,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.DeepLinkID,
		&i.Name,
		&i.IsActive,
		&i.Price,
		&i.AbsorbFees,
		&i.Description,
		&i.Capacity,
		&i.CapacitySold,
		&i.Type,
		&i.Level,
		&i.TicketType,
		&i.NumOfSeats,
		&i.FreeRefreshment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventDateTicket = `-- name: GetEventDateTicket :one
SELECT id, event_date_time_id, start_date, end_date, start_time, end_time, deep_link_id, name, is_active, price, absorb_fees, description, capacity, capacity_sold, type, level, ticket_type, num_of_seats, free_refreshment, created_at, updated_at
FROM event_date_tickets
WHERE id = $1 AND event_date_time_id = $2 AND is_active = true
`

type GetEventDateTicketParams struct {
	ID              uuid.UUID `json:"id"`
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
}

func (q *Queries) GetEventDateTicket(ctx context.Context, arg GetEventDateTicketParams) (EventDateTicket, error) {
	row := q.db.QueryRow(ctx, getEventDateTicket, arg.ID, arg.EventDateTimeID)
	var i EventDateTicket
	err := row.Scan(
		&i.ID,
		&i.EventDateTimeID,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.DeepLinkID,
		&i.Name,
		&i.IsActive,
		&i.Price,
		&i.AbsorbFees,
		&i.Description,
		&i.Capacity,
		&i.CapacitySold,
		&i.Type,
		&i.Level,
		&i.TicketType,
		&i.NumOfSeats,
		&i.FreeRefreshment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventDateTicketByGrade = `-- name: GetEventDateTicketByGrade :one
SELECT id
FROM event_date_tickets
WHERE event_date_time_id = $1 AND level = $2 AND is_active = true
`

type GetEventDateTicketByGradeParams struct {
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
	Level           string    `json:"level"`
}

func (q *Queries) GetEventDateTicketByGrade(ctx context.Context, arg GetEventDateTicketByGradeParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getEventDateTicketByGrade, arg.EventDateTimeID, arg.Level)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getEventDateTicketCount = `-- name: GetEventDateTicketCount :one
SELECT COUNT(*)
FROM event_date_tickets
WHERE event_date_time_id = $1 AND is_active = true
`

func (q *Queries) GetEventDateTicketCount(ctx context.Context, eventDateTimeID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getEventDateTicketCount, eventDateTimeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTicketByIDAndOptionID = `-- name: GetTicketByIDAndOptionID :one
SELECT e_d_t.id AS ticket_id, e_d_t.level, e_d_t.price, e_d_t.ticket_type, e_d_t.name AS ticket_name, e_d.id AS event_date_id, o_i.currency, e_d_d.start_time, e_d_d.end_time, e_d_d.time_zone, e_d_t.type AS pay_type, o_i.option_user_id AS option_user_id, e_d_t.absorb_fees
FROM event_date_tickets e_d_t
    JOIN event_date_times e_d on e_d.id = e_d_t.event_date_time_id
    JOIN event_date_details e_d_d on e_d_d.event_date_time_id = e_d_t.event_date_time_id
    JOIN options_infos o_i on o_i.id = e_d.event_info_id
    JOIN options_infos_status o_i_s on o_i_s.option_id = o_i.id
    JOIN users u on o_i.host_id = u.id
WHERE o_i.option_user_id = $1 AND e_d_t.id = $2 AND e_d.id = $3 AND CAST(CONCAT(e_d_t.start_date, ' ', e_d_t.start_time) AS timestamp) < NOW() AND CAST(CONCAT(e_d_t.end_date, ' ', e_d_t.end_time) AS timestamp) > NOW() AND e_d.status = 'on_sale' AND o_i.is_complete = true AND o_i.is_active = true AND u.is_active = true AND u.is_deleted = false AND (o_i_s.status = 'list' OR o_i_s.status = 'staged') AND  e_d.is_active = true AND e_d_t.is_active = true
`

type GetTicketByIDAndOptionIDParams struct {
	OptionUserID uuid.UUID `json:"option_user_id"`
	TicketID     uuid.UUID `json:"ticket_id"`
	EventDateID  uuid.UUID `json:"event_date_id"`
}

type GetTicketByIDAndOptionIDRow struct {
	TicketID     uuid.UUID `json:"ticket_id"`
	Level        string    `json:"level"`
	Price        int64     `json:"price"`
	TicketType   string    `json:"ticket_type"`
	TicketName   string    `json:"ticket_name"`
	EventDateID  uuid.UUID `json:"event_date_id"`
	Currency     string    `json:"currency"`
	StartTime    string    `json:"start_time"`
	EndTime      string    `json:"end_time"`
	TimeZone     string    `json:"time_zone"`
	PayType      string    `json:"pay_type"`
	OptionUserID uuid.UUID `json:"option_user_id"`
	AbsorbFees   bool      `json:"absorb_fees"`
}

func (q *Queries) GetTicketByIDAndOptionID(ctx context.Context, arg GetTicketByIDAndOptionIDParams) (GetTicketByIDAndOptionIDRow, error) {
	row := q.db.QueryRow(ctx, getTicketByIDAndOptionID, arg.OptionUserID, arg.TicketID, arg.EventDateID)
	var i GetTicketByIDAndOptionIDRow
	err := row.Scan(
		&i.TicketID,
		&i.Level,
		&i.Price,
		&i.TicketType,
		&i.TicketName,
		&i.EventDateID,
		&i.Currency,
		&i.StartTime,
		&i.EndTime,
		&i.TimeZone,
		&i.PayType,
		&i.OptionUserID,
		&i.AbsorbFees,
	)
	return i, err
}

const listEventDateTicket = `-- name: ListEventDateTicket :many
SELECT id, event_date_time_id, start_date, end_date, start_time, end_time, deep_link_id, name, is_active, price, absorb_fees, description, capacity, capacity_sold, type, level, ticket_type, num_of_seats, free_refreshment, created_at, updated_at
FROM event_date_tickets
WHERE event_date_time_id = $1 AND is_active = true
`

func (q *Queries) ListEventDateTicket(ctx context.Context, eventDateTimeID uuid.UUID) ([]EventDateTicket, error) {
	rows, err := q.db.Query(ctx, listEventDateTicket, eventDateTimeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventDateTicket{}
	for rows.Next() {
		var i EventDateTicket
		if err := rows.Scan(
			&i.ID,
			&i.EventDateTimeID,
			&i.StartDate,
			&i.EndDate,
			&i.StartTime,
			&i.EndTime,
			&i.DeepLinkID,
			&i.Name,
			&i.IsActive,
			&i.Price,
			&i.AbsorbFees,
			&i.Description,
			&i.Capacity,
			&i.CapacitySold,
			&i.Type,
			&i.Level,
			&i.TicketType,
			&i.NumOfSeats,
			&i.FreeRefreshment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTicketOffset = `-- name: ListEventDateTicketOffset :many
SELECT id, event_date_time_id, start_date, end_date, start_time, end_time, deep_link_id, name, is_active, price, absorb_fees, description, capacity, capacity_sold, type, level, ticket_type, num_of_seats, free_refreshment, created_at, updated_at
FROM event_date_tickets
WHERE event_date_time_id = $1 AND is_active = true
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type ListEventDateTicketOffsetParams struct {
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
}

func (q *Queries) ListEventDateTicketOffset(ctx context.Context, arg ListEventDateTicketOffsetParams) ([]EventDateTicket, error) {
	rows, err := q.db.Query(ctx, listEventDateTicketOffset, arg.EventDateTimeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventDateTicket{}
	for rows.Next() {
		var i EventDateTicket
		if err := rows.Scan(
			&i.ID,
			&i.EventDateTimeID,
			&i.StartDate,
			&i.EndDate,
			&i.StartTime,
			&i.EndTime,
			&i.DeepLinkID,
			&i.Name,
			&i.IsActive,
			&i.Price,
			&i.AbsorbFees,
			&i.Description,
			&i.Capacity,
			&i.CapacitySold,
			&i.Type,
			&i.Level,
			&i.TicketType,
			&i.NumOfSeats,
			&i.FreeRefreshment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTicketUser = `-- name: ListEventDateTicketUser :many
SELECT id, event_date_time_id, start_date, end_date, start_time, end_time, deep_link_id, name, is_active, price, absorb_fees, description, capacity, capacity_sold, type, level, ticket_type, num_of_seats, free_refreshment, created_at, updated_at
FROM event_date_tickets
WHERE event_date_time_id = $1 AND CAST(CONCAT(start_date, ' ', start_time) AS timestamp) < NOW() AND CAST(CONCAT(end_date, ' ', end_time) AS timestamp) > NOW() AND is_active = true
`

func (q *Queries) ListEventDateTicketUser(ctx context.Context, eventDateTimeID uuid.UUID) ([]EventDateTicket, error) {
	rows, err := q.db.Query(ctx, listEventDateTicketUser, eventDateTimeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventDateTicket{}
	for rows.Next() {
		var i EventDateTicket
		if err := rows.Scan(
			&i.ID,
			&i.EventDateTimeID,
			&i.StartDate,
			&i.EndDate,
			&i.StartTime,
			&i.EndTime,
			&i.DeepLinkID,
			&i.Name,
			&i.IsActive,
			&i.Price,
			&i.AbsorbFees,
			&i.Description,
			&i.Capacity,
			&i.CapacitySold,
			&i.Type,
			&i.Level,
			&i.TicketType,
			&i.NumOfSeats,
			&i.FreeRefreshment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketForRange = `-- name: ListTicketForRange :many
SELECT e_d_t.id AS ticket_id, e_d_t.level, e_d_t.price, e_d_t.ticket_type, e_d_t.name AS ticket_name, e_d.id AS event_date_id, o_i.currency, e_d_d.start_time, e_d_d.end_time, e_d_d.time_zone, e_d_t.type AS pay_type, o_i.option_user_id AS option_user_id, e_d_t.absorb_fees
FROM event_date_tickets e_d_t
    JOIN event_date_times e_d on e_d.id = e_d_t.event_date_time_id
    JOIN event_date_details e_d_d on e_d_d.event_date_time_id = e_d_t.event_date_time_id
    JOIN options_infos o_i on o_i.id = e_d.event_info_id
    JOIN options_infos_status o_i_s on o_i_s.option_id = o_i.id
    JOIN users u on o_i.host_id = u.id
WHERE CAST(CONCAT(e_d_t.start_date, ' ', e_d_t.start_time) AS timestamp) < NOW() AND CAST(CONCAT(e_d_t.end_date, ' ', e_d_t.end_time) AS timestamp) > NOW() AND e_d.status = 'on_sale' AND o_i.is_complete = true AND o_i.is_active = true AND u.is_active = true AND u.is_deleted = false AND (o_i_s.status = 'list' OR o_i_s.status = 'staged') AND  e_d.is_active = true AND e_d_t.is_active = true
ORDER BY e_d_t.price ASC
`

type ListTicketForRangeRow struct {
	TicketID     uuid.UUID `json:"ticket_id"`
	Level        string    `json:"level"`
	Price        int64     `json:"price"`
	TicketType   string    `json:"ticket_type"`
	TicketName   string    `json:"ticket_name"`
	EventDateID  uuid.UUID `json:"event_date_id"`
	Currency     string    `json:"currency"`
	StartTime    string    `json:"start_time"`
	EndTime      string    `json:"end_time"`
	TimeZone     string    `json:"time_zone"`
	PayType      string    `json:"pay_type"`
	OptionUserID uuid.UUID `json:"option_user_id"`
	AbsorbFees   bool      `json:"absorb_fees"`
}

func (q *Queries) ListTicketForRange(ctx context.Context) ([]ListTicketForRangeRow, error) {
	rows, err := q.db.Query(ctx, listTicketForRange)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTicketForRangeRow{}
	for rows.Next() {
		var i ListTicketForRangeRow
		if err := rows.Scan(
			&i.TicketID,
			&i.Level,
			&i.Price,
			&i.TicketType,
			&i.TicketName,
			&i.EventDateID,
			&i.Currency,
			&i.StartTime,
			&i.EndTime,
			&i.TimeZone,
			&i.PayType,
			&i.OptionUserID,
			&i.AbsorbFees,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllEventDateTicket = `-- name: RemoveAllEventDateTicket :exec
DELETE FROM event_date_tickets
WHERE event_date_time_id = $1 AND is_active = true
`

func (q *Queries) RemoveAllEventDateTicket(ctx context.Context, eventDateTimeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAllEventDateTicket, eventDateTimeID)
	return err
}

const removeEventDateTicket = `-- name: RemoveEventDateTicket :exec
DELETE FROM event_date_tickets
WHERE id = $1 AND event_date_time_id = $2 AND is_active = true
`

type RemoveEventDateTicketParams struct {
	ID              uuid.UUID `json:"id"`
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
}

func (q *Queries) RemoveEventDateTicket(ctx context.Context, arg RemoveEventDateTicketParams) error {
	_, err := q.db.Exec(ctx, removeEventDateTicket, arg.ID, arg.EventDateTimeID)
	return err
}

const updateEventDateTicket = `-- name: UpdateEventDateTicket :one
UPDATE event_date_tickets
SET 
    name = COALESCE($1, name),
    start_date = COALESCE($2, start_date),
    end_date = COALESCE($3, end_date),
    start_time = COALESCE($4, start_time),
    capacity = COALESCE($5, capacity),
    type = COALESCE($6, type),
    level = COALESCE($7, level),
    ticket_type = COALESCE($8, ticket_type),
    num_of_seats = COALESCE($9, num_of_seats),
    price = COALESCE($10, price),
    is_active = COALESCE($11, is_active),
    free_refreshment = COALESCE($12, free_refreshment),
    description = COALESCE($13, description),
    absorb_fees = COALESCE($14, absorb_fees),
    updated_at = NOW()
WHERE id = $15 AND event_date_time_id = $16 AND is_active = true
RETURNING id, event_date_time_id, start_date, end_date, start_time, end_time, deep_link_id, name, is_active, price, absorb_fees, description, capacity, capacity_sold, type, level, ticket_type, num_of_seats, free_refreshment, created_at, updated_at
`

type UpdateEventDateTicketParams struct {
	Name            pgtype.Text `json:"name"`
	StartDate       pgtype.Date `json:"start_date"`
	EndDate         pgtype.Date `json:"end_date"`
	StartTime       pgtype.Time `json:"start_time"`
	Capacity        pgtype.Int4 `json:"capacity"`
	Type            pgtype.Text `json:"type"`
	Level           pgtype.Text `json:"level"`
	TicketType      pgtype.Text `json:"ticket_type"`
	NumOfSeats      pgtype.Int4 `json:"num_of_seats"`
	Price           pgtype.Int8 `json:"price"`
	IsActive        pgtype.Bool `json:"is_active"`
	FreeRefreshment pgtype.Bool `json:"free_refreshment"`
	Description     pgtype.Text `json:"description"`
	AbsorbFees      pgtype.Bool `json:"absorb_fees"`
	ID              uuid.UUID   `json:"id"`
	EventDateTimeID uuid.UUID   `json:"event_date_time_id"`
}

func (q *Queries) UpdateEventDateTicket(ctx context.Context, arg UpdateEventDateTicketParams) (EventDateTicket, error) {
	row := q.db.QueryRow(ctx, updateEventDateTicket,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.StartTime,
		arg.Capacity,
		arg.Type,
		arg.Level,
		arg.TicketType,
		arg.NumOfSeats,
		arg.Price,
		arg.IsActive,
		arg.FreeRefreshment,
		arg.Description,
		arg.AbsorbFees,
		arg.ID,
		arg.EventDateTimeID,
	)
	var i EventDateTicket
	err := row.Scan(
		&i.ID,
		&i.EventDateTimeID,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.DeepLinkID,
		&i.Name,
		&i.IsActive,
		&i.Price,
		&i.AbsorbFees,
		&i.Description,
		&i.Capacity,
		&i.CapacitySold,
		&i.Type,
		&i.Level,
		&i.TicketType,
		&i.NumOfSeats,
		&i.FreeRefreshment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEventDateTicketTwo = `-- name: UpdateEventDateTicketTwo :one
UPDATE event_date_tickets
SET 
    name = $1,
    start_date = $2,
    end_date = $3,
    start_time = $4,
    capacity = $5,
    type = $6,
    level = $7,
    ticket_type = $8,
    num_of_seats = $9,
    free_refreshment = $10,
    price = $11,
    end_time = $12,
    absorb_fees = $13,
    description = $14,
    updated_at = NOW()
WHERE id = $15 AND event_date_time_id = $16 AND is_active = true
RETURNING id, event_date_time_id, start_date, end_date, start_time, end_time, deep_link_id, name, is_active, price, absorb_fees, description, capacity, capacity_sold, type, level, ticket_type, num_of_seats, free_refreshment, created_at, updated_at
`

type UpdateEventDateTicketTwoParams struct {
	Name            string    `json:"name"`
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	StartTime       time.Time `json:"start_time"`
	Capacity        int32     `json:"capacity"`
	Type            string    `json:"type"`
	Level           string    `json:"level"`
	TicketType      string    `json:"ticket_type"`
	NumOfSeats      int32     `json:"num_of_seats"`
	FreeRefreshment bool      `json:"free_refreshment"`
	Price           int64     `json:"price"`
	EndTime         time.Time `json:"end_time"`
	AbsorbFees      bool      `json:"absorb_fees"`
	Description     string    `json:"description"`
	ID              uuid.UUID `json:"id"`
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
}

func (q *Queries) UpdateEventDateTicketTwo(ctx context.Context, arg UpdateEventDateTicketTwoParams) (EventDateTicket, error) {
	row := q.db.QueryRow(ctx, updateEventDateTicketTwo,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.StartTime,
		arg.Capacity,
		arg.Type,
		arg.Level,
		arg.TicketType,
		arg.NumOfSeats,
		arg.FreeRefreshment,
		arg.Price,
		arg.EndTime,
		arg.AbsorbFees,
		arg.Description,
		arg.ID,
		arg.EventDateTimeID,
	)
	var i EventDateTicket
	err := row.Scan(
		&i.ID,
		&i.EventDateTimeID,
		&i.StartDate,
		&i.EndDate,
		&i.StartTime,
		&i.EndTime,
		&i.DeepLinkID,
		&i.Name,
		&i.IsActive,
		&i.Price,
		&i.AbsorbFees,
		&i.Description,
		&i.Capacity,
		&i.CapacitySold,
		&i.Type,
		&i.Level,
		&i.TicketType,
		&i.NumOfSeats,
		&i.FreeRefreshment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
