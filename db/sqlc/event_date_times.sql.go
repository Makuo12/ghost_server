// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: event_date_times.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEventDateTime = `-- name: CreateEventDateTime :one
INSERT INTO event_date_times (
        event_info_id,
        start_date,
        end_date,
        type,
        event_dates
    )
VALUES (
        $1, $2, $3, $4, $5
    )
RETURNING id, event_info_id, start_date, name, publish_check_in_steps, check_in_method, event_dates, deep_link_id, type, is_active, need_bands, need_tickets, absorb_band_charge, status, note, end_date, created_at, updated_at
`

type CreateEventDateTimeParams struct {
	EventInfoID uuid.UUID `json:"event_info_id"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	Type        string    `json:"type"`
	EventDates  []string  `json:"event_dates"`
}

func (q *Queries) CreateEventDateTime(ctx context.Context, arg CreateEventDateTimeParams) (EventDateTime, error) {
	row := q.db.QueryRow(ctx, createEventDateTime,
		arg.EventInfoID,
		arg.StartDate,
		arg.EndDate,
		arg.Type,
		arg.EventDates,
	)
	var i EventDateTime
	err := row.Scan(
		&i.ID,
		&i.EventInfoID,
		&i.StartDate,
		&i.Name,
		&i.PublishCheckInSteps,
		&i.CheckInMethod,
		&i.EventDates,
		&i.DeepLinkID,
		&i.Type,
		&i.IsActive,
		&i.NeedBands,
		&i.NeedTickets,
		&i.AbsorbBandCharge,
		&i.Status,
		&i.Note,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventDateOptionInfo = `-- name: GetEventDateOptionInfo :one
SELECT oi.currency
FROM event_date_times ed
    JOIN options_infos oi on oi.id = ed.event_info_id
WHERE ed.id = $1 AND ed.is_active = true
`

func (q *Queries) GetEventDateOptionInfo(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getEventDateOptionInfo, id)
	var currency string
	err := row.Scan(&currency)
	return currency, err
}

const getEventDateTime = `-- name: GetEventDateTime :one
SELECT id, event_info_id, start_date, name, publish_check_in_steps, check_in_method, event_dates, deep_link_id, type, is_active, need_bands, need_tickets, absorb_band_charge, status, note, end_date, created_at, updated_at
FROM event_date_times
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetEventDateTime(ctx context.Context, id uuid.UUID) (EventDateTime, error) {
	row := q.db.QueryRow(ctx, getEventDateTime, id)
	var i EventDateTime
	err := row.Scan(
		&i.ID,
		&i.EventInfoID,
		&i.StartDate,
		&i.Name,
		&i.PublishCheckInSteps,
		&i.CheckInMethod,
		&i.EventDates,
		&i.DeepLinkID,
		&i.Type,
		&i.IsActive,
		&i.NeedBands,
		&i.NeedTickets,
		&i.AbsorbBandCharge,
		&i.Status,
		&i.Note,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventDateTimeByOption = `-- name: GetEventDateTimeByOption :one
SELECT oi.currency, ed.Name, ed.Status, ed.publish_check_in_steps
FROM event_date_times ed
    JOIN options_infos oi on oi.id = ed.event_info_id
    JOIN users u on u.id = oi.host_id
WHERE ed.id = $1 AND u.id = $2 AND oi.id = $3 AND oi.is_complete = $4 AND ed.is_active = true
`

type GetEventDateTimeByOptionParams struct {
	ID         uuid.UUID `json:"id"`
	ID_2       uuid.UUID `json:"id_2"`
	ID_3       uuid.UUID `json:"id_3"`
	IsComplete bool      `json:"is_complete"`
}

type GetEventDateTimeByOptionRow struct {
	Currency            string `json:"currency"`
	Name                string `json:"name"`
	Status              string `json:"status"`
	PublishCheckInSteps bool   `json:"publish_check_in_steps"`
}

func (q *Queries) GetEventDateTimeByOption(ctx context.Context, arg GetEventDateTimeByOptionParams) (GetEventDateTimeByOptionRow, error) {
	row := q.db.QueryRow(ctx, getEventDateTimeByOption,
		arg.ID,
		arg.ID_2,
		arg.ID_3,
		arg.IsComplete,
	)
	var i GetEventDateTimeByOptionRow
	err := row.Scan(
		&i.Currency,
		&i.Name,
		&i.Status,
		&i.PublishCheckInSteps,
	)
	return i, err
}

const getEventDateTimeByUID = `-- name: GetEventDateTimeByUID :one
SELECT ed.id AS event_date_time_id, ed.type, ed.start_date, ed.end_date, ed.event_dates, ed.is_active
FROM event_date_times ed 
    JOIN options_infos oi on oi.id = ed.event_info_id
    JOIN users u on u.id = oi.host_id
WHERE ed.id = $1 AND oi.id = $2 AND u.id = $3  AND ed.is_active = true
`

type GetEventDateTimeByUIDParams struct {
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
	EventInfoID     uuid.UUID `json:"event_info_id"`
	UID             uuid.UUID `json:"u_id"`
}

type GetEventDateTimeByUIDRow struct {
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
	Type            string    `json:"type"`
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	EventDates      []string  `json:"event_dates"`
	IsActive        bool      `json:"is_active"`
}

func (q *Queries) GetEventDateTimeByUID(ctx context.Context, arg GetEventDateTimeByUIDParams) (GetEventDateTimeByUIDRow, error) {
	row := q.db.QueryRow(ctx, getEventDateTimeByUID, arg.EventDateTimeID, arg.EventInfoID, arg.UID)
	var i GetEventDateTimeByUIDRow
	err := row.Scan(
		&i.EventDateTimeID,
		&i.Type,
		&i.StartDate,
		&i.EndDate,
		&i.EventDates,
		&i.IsActive,
	)
	return i, err
}

const getEventDateTimeByUIDMap = `-- name: GetEventDateTimeByUIDMap :one
SELECT ed.id AS event_date_time_id, ed.type, ed.start_date, ed.end_date, ed.event_dates, ed.is_active, oi.category
FROM event_date_times ed 
    JOIN event_date_locations e_d_l on e_d_l.event_date_time_id = ed.id
    JOIN options_infos_status o_i_s on oi.id = o_i_s.option_id
    JOIN options_infos oi on oi.id = ed.event_info_id
    JOIN users u on u.id = oi.host_id
WHERE ed.id = $1 AND u.is_active = $2 AND ed.is_active = true AND status = 'on_sale' AND (o_i_s.status = 'list' OR o_i_s.status = 'staged')
`

type GetEventDateTimeByUIDMapParams struct {
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
	IsActive        bool      `json:"is_active"`
}

type GetEventDateTimeByUIDMapRow struct {
	EventDateTimeID uuid.UUID `json:"event_date_time_id"`
	Type            string    `json:"type"`
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	EventDates      []string  `json:"event_dates"`
	IsActive        bool      `json:"is_active"`
	Category        string    `json:"category"`
}

func (q *Queries) GetEventDateTimeByUIDMap(ctx context.Context, arg GetEventDateTimeByUIDMapParams) (GetEventDateTimeByUIDMapRow, error) {
	row := q.db.QueryRow(ctx, getEventDateTimeByUIDMap, arg.EventDateTimeID, arg.IsActive)
	var i GetEventDateTimeByUIDMapRow
	err := row.Scan(
		&i.EventDateTimeID,
		&i.Type,
		&i.StartDate,
		&i.EndDate,
		&i.EventDates,
		&i.IsActive,
		&i.Category,
	)
	return i, err
}

const getEventDateTimeCount = `-- name: GetEventDateTimeCount :one
SELECT COUNT(*)
FROM event_date_times
WHERE event_info_id = $1 AND is_active = true
`

func (q *Queries) GetEventDateTimeCount(ctx context.Context, eventInfoID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getEventDateTimeCount, eventInfoID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEventDateTimeDates = `-- name: GetEventDateTimeDates :one
SELECT event_dates
FROM event_date_times
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetEventDateTimeDates(ctx context.Context, id uuid.UUID) ([]string, error) {
	row := q.db.QueryRow(ctx, getEventDateTimeDates, id)
	var event_dates []string
	err := row.Scan(&event_dates)
	return event_dates, err
}

const listEDTSearchByName = `-- name: ListEDTSearchByName :many
SELECT  ed.id, ed.name, ed.status, ed.note, ed.start_date, ed.end_date, ed.need_bands, ed.need_tickets, ed.absorb_band_charge
FROM event_date_times ed
    JOIN options_infos oi on ed.event_info_id = oi.id
    JOIN users u on u.id = oi.host_id 
WHERE LOWER(ed.name) LIKE $1 AND u.id=$2 AND ed.event_info_id=$3 AND ed.status = 'on_sale' AND ed.is_active = true
`

type ListEDTSearchByNameParams struct {
	Name        string    `json:"name"`
	ID          uuid.UUID `json:"id"`
	EventInfoID uuid.UUID `json:"event_info_id"`
}

type ListEDTSearchByNameRow struct {
	ID               uuid.UUID `json:"id"`
	Name             string    `json:"name"`
	Status           string    `json:"status"`
	Note             string    `json:"note"`
	StartDate        time.Time `json:"start_date"`
	EndDate          time.Time `json:"end_date"`
	NeedBands        bool      `json:"need_bands"`
	NeedTickets      bool      `json:"need_tickets"`
	AbsorbBandCharge bool      `json:"absorb_band_charge"`
}

func (q *Queries) ListEDTSearchByName(ctx context.Context, arg ListEDTSearchByNameParams) ([]ListEDTSearchByNameRow, error) {
	rows, err := q.db.Query(ctx, listEDTSearchByName, arg.Name, arg.ID, arg.EventInfoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEDTSearchByNameRow{}
	for rows.Next() {
		var i ListEDTSearchByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Note,
			&i.StartDate,
			&i.EndDate,
			&i.NeedBands,
			&i.NeedTickets,
			&i.AbsorbBandCharge,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTime = `-- name: ListEventDateTime :many
SELECT id, event_info_id, start_date, name, publish_check_in_steps, check_in_method, event_dates, deep_link_id, type, is_active, need_bands, need_tickets, absorb_band_charge, status, note, end_date, created_at, updated_at
FROM event_date_times
WHERE event_info_id = $1 AND is_active = true
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type ListEventDateTimeParams struct {
	EventInfoID uuid.UUID `json:"event_info_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListEventDateTime(ctx context.Context, arg ListEventDateTimeParams) ([]EventDateTime, error) {
	rows, err := q.db.Query(ctx, listEventDateTime, arg.EventInfoID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventDateTime{}
	for rows.Next() {
		var i EventDateTime
		if err := rows.Scan(
			&i.ID,
			&i.EventInfoID,
			&i.StartDate,
			&i.Name,
			&i.PublishCheckInSteps,
			&i.CheckInMethod,
			&i.EventDates,
			&i.DeepLinkID,
			&i.Type,
			&i.IsActive,
			&i.NeedBands,
			&i.NeedTickets,
			&i.AbsorbBandCharge,
			&i.Status,
			&i.Note,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTimeByOption = `-- name: ListEventDateTimeByOption :many
SELECT ed.id, ed.event_info_id, od.host_name_option, ed.start_date, ed.name, ed.publish_check_in_steps, ed.check_in_method, ed.event_dates, ed.type, ed.need_bands, ed.status, ed.note, ed.end_date, edd.start_time, edd.end_time, edd.time_zone
FROM event_date_times ed
    JOIN event_date_details edd on edd.event_date_time_id = ed.id
    JOIN options_infos oi on oi.id = ed.event_info_id
    JOIN options_info_details od on od.option_id = oi.id
WHERE oi.id=$1 AND oi.main_option_type=$2 AND oi.is_complete=$3 AND ed.is_active = true
`

type ListEventDateTimeByOptionParams struct {
	ID             uuid.UUID `json:"id"`
	MainOptionType string    `json:"main_option_type"`
	IsComplete     bool      `json:"is_complete"`
}

type ListEventDateTimeByOptionRow struct {
	ID                  uuid.UUID `json:"id"`
	EventInfoID         uuid.UUID `json:"event_info_id"`
	HostNameOption      string    `json:"host_name_option"`
	StartDate           time.Time `json:"start_date"`
	Name                string    `json:"name"`
	PublishCheckInSteps bool      `json:"publish_check_in_steps"`
	CheckInMethod       string    `json:"check_in_method"`
	EventDates          []string  `json:"event_dates"`
	Type                string    `json:"type"`
	NeedBands           bool      `json:"need_bands"`
	Status              string    `json:"status"`
	Note                string    `json:"note"`
	EndDate             time.Time `json:"end_date"`
	StartTime           string    `json:"start_time"`
	EndTime             string    `json:"end_time"`
	TimeZone            string    `json:"time_zone"`
}

func (q *Queries) ListEventDateTimeByOption(ctx context.Context, arg ListEventDateTimeByOptionParams) ([]ListEventDateTimeByOptionRow, error) {
	rows, err := q.db.Query(ctx, listEventDateTimeByOption, arg.ID, arg.MainOptionType, arg.IsComplete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventDateTimeByOptionRow{}
	for rows.Next() {
		var i ListEventDateTimeByOptionRow
		if err := rows.Scan(
			&i.ID,
			&i.EventInfoID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Name,
			&i.PublishCheckInSteps,
			&i.CheckInMethod,
			&i.EventDates,
			&i.Type,
			&i.NeedBands,
			&i.Status,
			&i.Note,
			&i.EndDate,
			&i.StartTime,
			&i.EndTime,
			&i.TimeZone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTimeByUser = `-- name: ListEventDateTimeByUser :many
SELECT ed.id, ed.event_info_id, od.host_name_option, ed.start_date, ed.name, ed.publish_check_in_steps, ed.check_in_method, ed.event_dates, ed.type, ed.need_bands, ed.status, ed.note, ed.end_date, edd.start_time, edd.end_time, edd.time_zone
FROM event_date_times ed
    JOIN event_date_details edd on edd.event_date_time_id = ed.id
    JOIN options_infos oi on oi.id = ed.event_info_id
    JOIN options_info_details od on od.option_id = oi.id
    JOIN users u on u.id = oi.host_id
WHERE u.id = $1 AND oi.main_option_type = $2 AND oi.is_complete = $3 AND ed.is_active = true
ORDER BY ed.created_at DESC
LIMIT $4
OFFSET $5
`

type ListEventDateTimeByUserParams struct {
	ID             uuid.UUID `json:"id"`
	MainOptionType string    `json:"main_option_type"`
	IsComplete     bool      `json:"is_complete"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type ListEventDateTimeByUserRow struct {
	ID                  uuid.UUID `json:"id"`
	EventInfoID         uuid.UUID `json:"event_info_id"`
	HostNameOption      string    `json:"host_name_option"`
	StartDate           time.Time `json:"start_date"`
	Name                string    `json:"name"`
	PublishCheckInSteps bool      `json:"publish_check_in_steps"`
	CheckInMethod       string    `json:"check_in_method"`
	EventDates          []string  `json:"event_dates"`
	Type                string    `json:"type"`
	NeedBands           bool      `json:"need_bands"`
	Status              string    `json:"status"`
	Note                string    `json:"note"`
	EndDate             time.Time `json:"end_date"`
	StartTime           string    `json:"start_time"`
	EndTime             string    `json:"end_time"`
	TimeZone            string    `json:"time_zone"`
}

func (q *Queries) ListEventDateTimeByUser(ctx context.Context, arg ListEventDateTimeByUserParams) ([]ListEventDateTimeByUserRow, error) {
	rows, err := q.db.Query(ctx, listEventDateTimeByUser,
		arg.ID,
		arg.MainOptionType,
		arg.IsComplete,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventDateTimeByUserRow{}
	for rows.Next() {
		var i ListEventDateTimeByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.EventInfoID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Name,
			&i.PublishCheckInSteps,
			&i.CheckInMethod,
			&i.EventDates,
			&i.Type,
			&i.NeedBands,
			&i.Status,
			&i.Note,
			&i.EndDate,
			&i.StartTime,
			&i.EndTime,
			&i.TimeZone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTimeHost = `-- name: ListEventDateTimeHost :many
SELECT
    edt.id AS event_date_time_id,
    edt.event_info_id,
    edt.start_date,
    edt.name,
    edt.publish_check_in_steps,
    edt.check_in_method,
    unnest(edt.event_dates)::VARCHAR AS event_date,
    edt.type,
    edt.is_active,
    edt.need_bands,
    edt.need_tickets,
    edt.absorb_band_charge,
    edt.status AS event_status,
    edt.note,
    edt.end_date,
    ei.sub_category_type,
    ei.event_type,
    os.status AS option_status,
    edi.time_zone,
    edi.start_time,
    edi.end_time,
    od.host_name_option,
    op.cover_image,
    CASE WHEN och_subquery.option_id IS NOT NULL THEN oi.co_host_id::uuid
        WHEN oi.host_id = $2 THEN oi.id::uuid
        ELSE oi.id::uuid -- Optional: Handle other cases if needed
    END AS option_id,
    CASE WHEN och_subquery.scan_code IS NOT NULL THEN och_subquery.scan_code::boolean
        WHEN oi.host_id = $2 THEN true
        ELSE false -- Optional: Handle other cases if needed
    END AS scan_code,
    CASE WHEN och_subquery.reservations IS NOT NULL THEN och_subquery.scan_code::boolean
        WHEN oi.host_id = $2 THEN true
        ELSE false -- Optional: Handle other cases if needed
    END AS reservations,
    CASE WHEN och_subquery.option_id IS NOT NULL THEN 'co_host'
        WHEN oi.host_id = $2 THEN 'main_host'
        ELSE 'none' -- Optional: Handle other cases if needed
    END AS host_type
FROM
    event_date_times AS edt
JOIN event_infos AS ei ON edt.event_info_id = ei.option_id
JOIN event_date_details AS edi ON edt.id = edi.event_date_time_id
JOIN options_infos AS oi ON oi.id = ei.option_id
JOIN options_info_photos op ON op.option_id = oi.id
JOIN options_info_details AS od ON od.option_id = oi.id
JOIN options_infos_status AS os ON os.option_id = oi.id 
LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations
    FROM option_co_hosts
    WHERE co_user_id = $1
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE
    (oi.host_id = $2 OR och_subquery.option_id IS NOT NULL)
    AND (
        (edt.type = 'recurring' AND oi.is_complete = true AND oi.is_active = true AND edt.is_active = true)
        OR
        (edt.type = 'single' AND oi.is_complete = true AND oi.is_active = true AND edt.is_active = true)
    )
`

type ListEventDateTimeHostParams struct {
	CoUserID string    `json:"co_user_id"`
	HostID   uuid.UUID `json:"host_id"`
}

type ListEventDateTimeHostRow struct {
	EventDateTimeID     uuid.UUID `json:"event_date_time_id"`
	EventInfoID         uuid.UUID `json:"event_info_id"`
	StartDate           time.Time `json:"start_date"`
	Name                string    `json:"name"`
	PublishCheckInSteps bool      `json:"publish_check_in_steps"`
	CheckInMethod       string    `json:"check_in_method"`
	EventDate           string    `json:"event_date"`
	Type                string    `json:"type"`
	IsActive            bool      `json:"is_active"`
	NeedBands           bool      `json:"need_bands"`
	NeedTickets         bool      `json:"need_tickets"`
	AbsorbBandCharge    bool      `json:"absorb_band_charge"`
	EventStatus         string    `json:"event_status"`
	Note                string    `json:"note"`
	EndDate             time.Time `json:"end_date"`
	SubCategoryType     string    `json:"sub_category_type"`
	EventType           string    `json:"event_type"`
	OptionStatus        string    `json:"option_status"`
	TimeZone            string    `json:"time_zone"`
	StartTime           string    `json:"start_time"`
	EndTime             string    `json:"end_time"`
	HostNameOption      string    `json:"host_name_option"`
	CoverImage          string    `json:"cover_image"`
	OptionID            uuid.UUID `json:"option_id"`
	ScanCode            bool      `json:"scan_code"`
	Reservations        bool      `json:"reservations"`
	HostType            string    `json:"host_type"`
}

func (q *Queries) ListEventDateTimeHost(ctx context.Context, arg ListEventDateTimeHostParams) ([]ListEventDateTimeHostRow, error) {
	rows, err := q.db.Query(ctx, listEventDateTimeHost, arg.CoUserID, arg.HostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventDateTimeHostRow{}
	for rows.Next() {
		var i ListEventDateTimeHostRow
		if err := rows.Scan(
			&i.EventDateTimeID,
			&i.EventInfoID,
			&i.StartDate,
			&i.Name,
			&i.PublishCheckInSteps,
			&i.CheckInMethod,
			&i.EventDate,
			&i.Type,
			&i.IsActive,
			&i.NeedBands,
			&i.NeedTickets,
			&i.AbsorbBandCharge,
			&i.EventStatus,
			&i.Note,
			&i.EndDate,
			&i.SubCategoryType,
			&i.EventType,
			&i.OptionStatus,
			&i.TimeZone,
			&i.StartTime,
			&i.EndTime,
			&i.HostNameOption,
			&i.CoverImage,
			&i.OptionID,
			&i.ScanCode,
			&i.Reservations,
			&i.HostType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTimeNoLimit = `-- name: ListEventDateTimeNoLimit :many
SELECT id, event_info_id, start_date, name, publish_check_in_steps, check_in_method, event_dates, deep_link_id, type, is_active, need_bands, need_tickets, absorb_band_charge, status, note, end_date, created_at, updated_at
FROM event_date_times
WHERE event_info_id = $1 AND is_active = true
`

func (q *Queries) ListEventDateTimeNoLimit(ctx context.Context, eventInfoID uuid.UUID) ([]EventDateTime, error) {
	rows, err := q.db.Query(ctx, listEventDateTimeNoLimit, eventInfoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventDateTime{}
	for rows.Next() {
		var i EventDateTime
		if err := rows.Scan(
			&i.ID,
			&i.EventInfoID,
			&i.StartDate,
			&i.Name,
			&i.PublishCheckInSteps,
			&i.CheckInMethod,
			&i.EventDates,
			&i.DeepLinkID,
			&i.Type,
			&i.IsActive,
			&i.NeedBands,
			&i.NeedTickets,
			&i.AbsorbBandCharge,
			&i.Status,
			&i.Note,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventDateTimeOnSale = `-- name: ListEventDateTimeOnSale :many
SELECT id, event_info_id, start_date, name, publish_check_in_steps, check_in_method, event_dates, deep_link_id, type, is_active, need_bands, need_tickets, absorb_band_charge, status, note, end_date, ed.created_at, ed.updated_at, edd.event_date_time_id, start_time, end_time, time_zone, edd.created_at, edd.updated_at, e_d_l.event_date_time_id, street, city, state, country, postcode, geolocation, e_d_l.created_at, e_d_l.updated_at
FROM event_date_times ed
    JOIN event_date_details edd on edd.event_date_time_id = ed.id
    JOIN event_date_locations e_d_l on e_d_l.event_date_time_id = ed.id
WHERE ed.event_info_id = $1 AND ed.status = $2 AND ed.is_active = true
`

type ListEventDateTimeOnSaleParams struct {
	EventInfoID uuid.UUID `json:"event_info_id"`
	Status      string    `json:"status"`
}

type ListEventDateTimeOnSaleRow struct {
	ID                  uuid.UUID    `json:"id"`
	EventInfoID         uuid.UUID    `json:"event_info_id"`
	StartDate           time.Time    `json:"start_date"`
	Name                string       `json:"name"`
	PublishCheckInSteps bool         `json:"publish_check_in_steps"`
	CheckInMethod       string       `json:"check_in_method"`
	EventDates          []string     `json:"event_dates"`
	DeepLinkID          uuid.UUID    `json:"deep_link_id"`
	Type                string       `json:"type"`
	IsActive            bool         `json:"is_active"`
	NeedBands           bool         `json:"need_bands"`
	NeedTickets         bool         `json:"need_tickets"`
	AbsorbBandCharge    bool         `json:"absorb_band_charge"`
	Status              string       `json:"status"`
	Note                string       `json:"note"`
	EndDate             time.Time    `json:"end_date"`
	CreatedAt           time.Time    `json:"created_at"`
	UpdatedAt           time.Time    `json:"updated_at"`
	EventDateTimeID     uuid.UUID    `json:"event_date_time_id"`
	StartTime           string       `json:"start_time"`
	EndTime             string       `json:"end_time"`
	TimeZone            string       `json:"time_zone"`
	CreatedAt_2         time.Time    `json:"created_at_2"`
	UpdatedAt_2         time.Time    `json:"updated_at_2"`
	EventDateTimeID_2   uuid.UUID    `json:"event_date_time_id_2"`
	Street              string       `json:"street"`
	City                string       `json:"city"`
	State               string       `json:"state"`
	Country             string       `json:"country"`
	Postcode            string       `json:"postcode"`
	Geolocation         pgtype.Point `json:"geolocation"`
	CreatedAt_3         time.Time    `json:"created_at_3"`
	UpdatedAt_3         time.Time    `json:"updated_at_3"`
}

func (q *Queries) ListEventDateTimeOnSale(ctx context.Context, arg ListEventDateTimeOnSaleParams) ([]ListEventDateTimeOnSaleRow, error) {
	rows, err := q.db.Query(ctx, listEventDateTimeOnSale, arg.EventInfoID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventDateTimeOnSaleRow{}
	for rows.Next() {
		var i ListEventDateTimeOnSaleRow
		if err := rows.Scan(
			&i.ID,
			&i.EventInfoID,
			&i.StartDate,
			&i.Name,
			&i.PublishCheckInSteps,
			&i.CheckInMethod,
			&i.EventDates,
			&i.DeepLinkID,
			&i.Type,
			&i.IsActive,
			&i.NeedBands,
			&i.NeedTickets,
			&i.AbsorbBandCharge,
			&i.Status,
			&i.Note,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EventDateTimeID,
			&i.StartTime,
			&i.EndTime,
			&i.TimeZone,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.EventDateTimeID_2,
			&i.Street,
			&i.City,
			&i.State,
			&i.Country,
			&i.Postcode,
			&i.Geolocation,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllEventDateTime = `-- name: RemoveAllEventDateTime :exec
DELETE FROM event_date_times
WHERE event_info_id = $1 AND is_active = true
`

func (q *Queries) RemoveAllEventDateTime(ctx context.Context, eventInfoID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAllEventDateTime, eventInfoID)
	return err
}

const removeEventDateTime = `-- name: RemoveEventDateTime :exec
DELETE FROM event_date_times
WHERE id = $1 AND is_active = true
`

func (q *Queries) RemoveEventDateTime(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeEventDateTime, id)
	return err
}

const updateEventDateTime = `-- name: UpdateEventDateTime :one
UPDATE event_date_times
SET 
   start_date = COALESCE($1, start_date),
   note = COALESCE($2, note),
   end_date = COALESCE($3, end_date),
   status = COALESCE($4, status),
   name = COALESCE($5, name),
   publish_check_in_steps = COALESCE($6, publish_check_in_steps),
   event_dates = COALESCE($7, event_dates),
   is_active = COALESCE($8, is_active),
   need_bands = COALESCE($9, need_bands),
   need_tickets = COALESCE($10, need_tickets),
   absorb_band_charge = COALESCE($11, absorb_band_charge),
   updated_at = NOW()
WHERE id = $12 AND type = $13 AND is_active = true
RETURNING id, event_info_id, start_date, name, publish_check_in_steps, check_in_method, event_dates, deep_link_id, type, is_active, need_bands, need_tickets, absorb_band_charge, status, note, end_date, created_at, updated_at
`

type UpdateEventDateTimeParams struct {
	StartDate           pgtype.Date `json:"start_date"`
	Note                pgtype.Text `json:"note"`
	EndDate             pgtype.Date `json:"end_date"`
	Status              pgtype.Text `json:"status"`
	Name                pgtype.Text `json:"name"`
	PublishCheckInSteps pgtype.Bool `json:"publish_check_in_steps"`
	EventDates          []string    `json:"event_dates"`
	IsActive            pgtype.Bool `json:"is_active"`
	NeedBands           pgtype.Bool `json:"need_bands"`
	NeedTickets         pgtype.Bool `json:"need_tickets"`
	AbsorbBandCharge    pgtype.Bool `json:"absorb_band_charge"`
	ID                  uuid.UUID   `json:"id"`
	Type                string      `json:"type"`
}

func (q *Queries) UpdateEventDateTime(ctx context.Context, arg UpdateEventDateTimeParams) (EventDateTime, error) {
	row := q.db.QueryRow(ctx, updateEventDateTime,
		arg.StartDate,
		arg.Note,
		arg.EndDate,
		arg.Status,
		arg.Name,
		arg.PublishCheckInSteps,
		arg.EventDates,
		arg.IsActive,
		arg.NeedBands,
		arg.NeedTickets,
		arg.AbsorbBandCharge,
		arg.ID,
		arg.Type,
	)
	var i EventDateTime
	err := row.Scan(
		&i.ID,
		&i.EventInfoID,
		&i.StartDate,
		&i.Name,
		&i.PublishCheckInSteps,
		&i.CheckInMethod,
		&i.EventDates,
		&i.DeepLinkID,
		&i.Type,
		&i.IsActive,
		&i.NeedBands,
		&i.NeedTickets,
		&i.AbsorbBandCharge,
		&i.Status,
		&i.Note,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEventDateTimeActive = `-- name: UpdateEventDateTimeActive :one
UPDATE event_date_times
SET 
    is_active = COALESCE($1, is_active),
    updated_at = NOW()
WHERE id = $2 AND is_active = true
RETURNING id, event_info_id, start_date, name, publish_check_in_steps, check_in_method, event_dates, deep_link_id, type, is_active, need_bands, need_tickets, absorb_band_charge, status, note, end_date, created_at, updated_at
`

type UpdateEventDateTimeActiveParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateEventDateTimeActive(ctx context.Context, arg UpdateEventDateTimeActiveParams) (EventDateTime, error) {
	row := q.db.QueryRow(ctx, updateEventDateTimeActive, arg.IsActive, arg.ID)
	var i EventDateTime
	err := row.Scan(
		&i.ID,
		&i.EventInfoID,
		&i.StartDate,
		&i.Name,
		&i.PublishCheckInSteps,
		&i.CheckInMethod,
		&i.EventDates,
		&i.DeepLinkID,
		&i.Type,
		&i.IsActive,
		&i.NeedBands,
		&i.NeedTickets,
		&i.AbsorbBandCharge,
		&i.Status,
		&i.Note,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEventDateTimeDates = `-- name: UpdateEventDateTimeDates :one
UPDATE event_date_times
SET 
    event_dates = $1,
    updated_at = NOW()
WHERE id = $2 AND is_active = true
RETURNING id, event_info_id, start_date, name, publish_check_in_steps, check_in_method, event_dates, deep_link_id, type, is_active, need_bands, need_tickets, absorb_band_charge, status, note, end_date, created_at, updated_at
`

type UpdateEventDateTimeDatesParams struct {
	EventDates []string  `json:"event_dates"`
	ID         uuid.UUID `json:"id"`
}

func (q *Queries) UpdateEventDateTimeDates(ctx context.Context, arg UpdateEventDateTimeDatesParams) (EventDateTime, error) {
	row := q.db.QueryRow(ctx, updateEventDateTimeDates, arg.EventDates, arg.ID)
	var i EventDateTime
	err := row.Scan(
		&i.ID,
		&i.EventInfoID,
		&i.StartDate,
		&i.Name,
		&i.PublishCheckInSteps,
		&i.CheckInMethod,
		&i.EventDates,
		&i.DeepLinkID,
		&i.Type,
		&i.IsActive,
		&i.NeedBands,
		&i.NeedTickets,
		&i.AbsorbBandCharge,
		&i.Status,
		&i.Note,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEventPublishCheckInStep = `-- name: UpdateEventPublishCheckInStep :one
UPDATE event_date_times
SET 
    publish_check_in_steps = CASE WHEN publish_check_in_steps = false THEN true ELSE false END,
    updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING publish_check_in_steps
`

func (q *Queries) UpdateEventPublishCheckInStep(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, updateEventPublishCheckInStep, id)
	var publish_check_in_steps bool
	err := row.Scan(&publish_check_in_steps)
	return publish_check_in_steps, err
}
