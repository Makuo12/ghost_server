// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: charge_ticket_references.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countChargeTicketReference = `-- name: CountChargeTicketReference :one
SELECT Count(*)
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE ct.ticket_id == $1 AND ct.cancelled = $2 AND ce.is_complete = $3
`

type CountChargeTicketReferenceParams struct {
	TicketID   uuid.UUID `json:"ticket_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) CountChargeTicketReference(ctx context.Context, arg CountChargeTicketReferenceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeTicketReference, arg.TicketID, arg.Cancelled, arg.IsComplete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChargeTicketReferenceAny = `-- name: CountChargeTicketReferenceAny :one
SELECT Count(*)
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE ct.ticket_id == $1
`

func (q *Queries) CountChargeTicketReferenceAny(ctx context.Context, ticketID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeTicketReferenceAny, ticketID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChargeTicketReferenceByEventDateID = `-- name: CountChargeTicketReferenceByEventDateID :one
SELECT Count(*)
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE cd.event_date_id = $1  AND ct.cancelled = $2 AND ce.is_complete = $3
`

type CountChargeTicketReferenceByEventDateIDParams struct {
	EventDateID uuid.UUID `json:"event_date_id"`
	Cancelled   bool      `json:"cancelled"`
	IsComplete  bool      `json:"is_complete"`
}

func (q *Queries) CountChargeTicketReferenceByEventDateID(ctx context.Context, arg CountChargeTicketReferenceByEventDateIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeTicketReferenceByEventDateID, arg.EventDateID, arg.Cancelled, arg.IsComplete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChargeTicketReferenceByEventDateIDAny = `-- name: CountChargeTicketReferenceByEventDateIDAny :one
SELECT Count(*)
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE cd.event_date_id = $1
`

func (q *Queries) CountChargeTicketReferenceByEventDateIDAny(ctx context.Context, eventDateID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeTicketReferenceByEventDateIDAny, eventDateID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChargeTicketReferenceByStartDate = `-- name: CountChargeTicketReferenceByStartDate :one
SELECT Count(*)
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE DATE(cd.start_date) = DATE($1) AND cd.event_date_id = $2 AND ct.cancelled = $3 AND ce.is_complete = $4 AND ct.ticket_id = $5
`

type CountChargeTicketReferenceByStartDateParams struct {
	Date        interface{} `json:"date"`
	EventDateID uuid.UUID   `json:"event_date_id"`
	Cancelled   bool        `json:"cancelled"`
	IsComplete  bool        `json:"is_complete"`
	TicketID    uuid.UUID   `json:"ticket_id"`
}

func (q *Queries) CountChargeTicketReferenceByStartDate(ctx context.Context, arg CountChargeTicketReferenceByStartDateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeTicketReferenceByStartDate,
		arg.Date,
		arg.EventDateID,
		arg.Cancelled,
		arg.IsComplete,
		arg.TicketID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChargeTicketReferenceCurrent = `-- name: CountChargeTicketReferenceCurrent :one
SELECT COUNT(*)
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN event_date_times e_d_t on e_d_t.id = cd.event_date_id
    JOIN event_date_details e_d_d on e_d_d.event_date_time_id = cd.event_date_id
    LEFT JOIN event_date_locations e_d_l on e_d_l.event_date_time_id = cd.event_date_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN event_infos e_i on e_i.option_id = o_i.id
    JOIN options_info_photos o_p_p on o_i.id = o_p_p.option_id
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
    JOIN users u on u.id = o_i.host_id
	LEFT JOIN charge_reviews cr on cr.charge_id = ct.id
WHERE ce.user_id = $1 AND ct.cancelled = $2 AND ce.is_complete = $3 AND (NOW() <= cd.end_date + INTERVAL '13 days' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id AND cr.is_published = false) OR NOW() <= cd.end_date + INTERVAL '13 days' AND NOT EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id))
`

type CountChargeTicketReferenceCurrentParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) CountChargeTicketReferenceCurrent(ctx context.Context, arg CountChargeTicketReferenceCurrentParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeTicketReferenceCurrent, arg.UserID, arg.Cancelled, arg.IsComplete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChargeTicketReferenceVisited = `-- name: CountChargeTicketReferenceVisited :one
SELECT COUNT(*)
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN event_date_times e_d_t on e_d_t.id = cd.event_date_id
    JOIN event_date_details e_d_d on e_d_d.event_date_time_id = cd.event_date_id
    LEFT JOIN event_date_locations e_d_l on e_d_l.event_date_time_id = cd.event_date_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN event_infos e_i on e_i.option_id = o_i.id
    JOIN options_info_photos o_p_p on o_i.id = o_p_p.option_id
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
    JOIN users u on u.id = o_i.host_id
	LEFT JOIN charge_reviews cr on cr.charge_id = ct.id
WHERE ce.user_id = $1 AND ct.cancelled = $2 AND ce.is_complete = $3 AND (NOW() > cd.end_date + INTERVAL '8 hours' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id AND cr.is_published = TRUE) OR NOW() > cd.end_date + INTERVAL '13 days')
`

type CountChargeTicketReferenceVisitedParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) CountChargeTicketReferenceVisited(ctx context.Context, arg CountChargeTicketReferenceVisitedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChargeTicketReferenceVisited, arg.UserID, arg.Cancelled, arg.IsComplete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTicketPaymentUser = `-- name: CountTicketPaymentUser :one
SELECT Count(*)
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE ce.user_id = $1 AND ce.is_complete = $2
`

type CountTicketPaymentUserParams struct {
	UserID     uuid.UUID `json:"user_id"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) CountTicketPaymentUser(ctx context.Context, arg CountTicketPaymentUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTicketPaymentUser, arg.UserID, arg.IsComplete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChargeTicketReference = `-- name: CreateChargeTicketReference :one
INSERT INTO charge_ticket_references (
    charge_date_id,
    ticket_id,
    grade,
    price,
    service_fee,
    absorb_fee,
    type,
    date_booked,
    ticket_type,
    group_price
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, charge_date_id, ticket_id, grade, type, date_booked, price, service_fee, absorb_fee, ticket_type, group_price, gifted, cancelled, created_at, updated_at
`

type CreateChargeTicketReferenceParams struct {
	ChargeDateID uuid.UUID `json:"charge_date_id"`
	TicketID     uuid.UUID `json:"ticket_id"`
	Grade        string    `json:"grade"`
	Price        int64     `json:"price"`
	ServiceFee   int64     `json:"service_fee"`
	AbsorbFee    int64     `json:"absorb_fee"`
	Type         string    `json:"type"`
	DateBooked   time.Time `json:"date_booked"`
	TicketType   string    `json:"ticket_type"`
	GroupPrice   int64     `json:"group_price"`
}

func (q *Queries) CreateChargeTicketReference(ctx context.Context, arg CreateChargeTicketReferenceParams) (ChargeTicketReference, error) {
	row := q.db.QueryRow(ctx, createChargeTicketReference,
		arg.ChargeDateID,
		arg.TicketID,
		arg.Grade,
		arg.Price,
		arg.ServiceFee,
		arg.AbsorbFee,
		arg.Type,
		arg.DateBooked,
		arg.TicketType,
		arg.GroupPrice,
	)
	var i ChargeTicketReference
	err := row.Scan(
		&i.ID,
		&i.ChargeDateID,
		&i.TicketID,
		&i.Grade,
		&i.Type,
		&i.DateBooked,
		&i.Price,
		&i.ServiceFee,
		&i.AbsorbFee,
		&i.TicketType,
		&i.GroupPrice,
		&i.Gifted,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChargeTicketReference = `-- name: GetChargeTicketReference :one
SELECT ct.id, cd.start_date, cd.end_date
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE ct.id = $1 AND ce.user_id = $2 AND ct.cancelled = $3 AND ce.is_complete = $4
`

type GetChargeTicketReferenceParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeTicketReferenceRow struct {
	ID        uuid.UUID `json:"id"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) GetChargeTicketReference(ctx context.Context, arg GetChargeTicketReferenceParams) (GetChargeTicketReferenceRow, error) {
	row := q.db.QueryRow(ctx, getChargeTicketReference,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var i GetChargeTicketReferenceRow
	err := row.Scan(&i.ID, &i.StartDate, &i.EndDate)
	return i, err
}

const getChargeTicketReferenceByChargeID = `-- name: GetChargeTicketReferenceByChargeID :one
SELECT mp.is_complete AS main_payout_complete, cd.start_date, ct.date_booked, c_p.type_one AS cancel_policy_one, ct.id AS charge_id, u.first_name AS user_first_name, us.first_name AS host_first_name, us.user_id AS host_user_id, o_i_d.host_name_option, mp.type AS charge_type, cd.end_date, u.user_id AS guest_user_id, cd.id AS date_time_id
FROM charge_ticket_references ct
    JOIN main_payouts mp on mp.charge_id = ct.id
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN cancel_policies c_p on c_p.option_id = o_i.id
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
    JOIN users u on u.user_id = ce.user_id
    JOIN users us on us.id = o_i.host_id
WHERE ct.cancelled = $1 AND ce.is_complete = $2 AND ct.id = $3
`

type GetChargeTicketReferenceByChargeIDParams struct {
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
	ID         uuid.UUID `json:"id"`
}

type GetChargeTicketReferenceByChargeIDRow struct {
	MainPayoutComplete bool      `json:"main_payout_complete"`
	StartDate          time.Time `json:"start_date"`
	DateBooked         time.Time `json:"date_booked"`
	CancelPolicyOne    string    `json:"cancel_policy_one"`
	ChargeID           uuid.UUID `json:"charge_id"`
	UserFirstName      string    `json:"user_first_name"`
	HostFirstName      string    `json:"host_first_name"`
	HostUserID         uuid.UUID `json:"host_user_id"`
	HostNameOption     string    `json:"host_name_option"`
	ChargeType         string    `json:"charge_type"`
	EndDate            time.Time `json:"end_date"`
	GuestUserID        uuid.UUID `json:"guest_user_id"`
	DateTimeID         uuid.UUID `json:"date_time_id"`
}

func (q *Queries) GetChargeTicketReferenceByChargeID(ctx context.Context, arg GetChargeTicketReferenceByChargeIDParams) (GetChargeTicketReferenceByChargeIDRow, error) {
	row := q.db.QueryRow(ctx, getChargeTicketReferenceByChargeID, arg.Cancelled, arg.IsComplete, arg.ID)
	var i GetChargeTicketReferenceByChargeIDRow
	err := row.Scan(
		&i.MainPayoutComplete,
		&i.StartDate,
		&i.DateBooked,
		&i.CancelPolicyOne,
		&i.ChargeID,
		&i.UserFirstName,
		&i.HostFirstName,
		&i.HostUserID,
		&i.HostNameOption,
		&i.ChargeType,
		&i.EndDate,
		&i.GuestUserID,
		&i.DateTimeID,
	)
	return i, err
}

const getChargeTicketReferenceByUserID = `-- name: GetChargeTicketReferenceByUserID :one
SELECT mp.is_complete AS main_payout_complete, cd.start_date, ct.date_booked, c_p.type_one AS cancel_policy_one, ct.id AS charge_id, u.first_name AS user_first_name, us.first_name AS host_first_name, us.user_id AS host_user_id, o_i_d.host_name_option, mp.type AS charge_type, cd.end_date, e_d_d.time_zone, ct.service_fee, ct.price AS total_fee, ce.currency
FROM charge_ticket_references ct
    JOIN main_payouts mp on mp.charge_id = ct.id
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN cancel_policies c_p on c_p.option_id = o_i.id
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
    JOIN event_date_details e_d_d on e_d_d.event_date_time_id = cd.event_date_id
    JOIN users u on u.user_id = ce.user_id
    JOIN users us on us.id = o_i.host_id
WHERE ce.user_id = $1 AND ct.cancelled = $2 AND ce.is_complete = $3 AND ct.id = $4
`

type GetChargeTicketReferenceByUserIDParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
	ID         uuid.UUID `json:"id"`
}

type GetChargeTicketReferenceByUserIDRow struct {
	MainPayoutComplete bool      `json:"main_payout_complete"`
	StartDate          time.Time `json:"start_date"`
	DateBooked         time.Time `json:"date_booked"`
	CancelPolicyOne    string    `json:"cancel_policy_one"`
	ChargeID           uuid.UUID `json:"charge_id"`
	UserFirstName      string    `json:"user_first_name"`
	HostFirstName      string    `json:"host_first_name"`
	HostUserID         uuid.UUID `json:"host_user_id"`
	HostNameOption     string    `json:"host_name_option"`
	ChargeType         string    `json:"charge_type"`
	EndDate            time.Time `json:"end_date"`
	TimeZone           string    `json:"time_zone"`
	ServiceFee         int64     `json:"service_fee"`
	TotalFee           int64     `json:"total_fee"`
	Currency           string    `json:"currency"`
}

func (q *Queries) GetChargeTicketReferenceByUserID(ctx context.Context, arg GetChargeTicketReferenceByUserIDParams) (GetChargeTicketReferenceByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getChargeTicketReferenceByUserID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
		arg.ID,
	)
	var i GetChargeTicketReferenceByUserIDRow
	err := row.Scan(
		&i.MainPayoutComplete,
		&i.StartDate,
		&i.DateBooked,
		&i.CancelPolicyOne,
		&i.ChargeID,
		&i.UserFirstName,
		&i.HostFirstName,
		&i.HostUserID,
		&i.HostNameOption,
		&i.ChargeType,
		&i.EndDate,
		&i.TimeZone,
		&i.ServiceFee,
		&i.TotalFee,
		&i.Currency,
	)
	return i, err
}

const getChargeTicketReferenceCheckInStep = `-- name: GetChargeTicketReferenceCheckInStep :many
SELECT e_i_s.photo, e_i_s.des, e_i_s.id
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN event_date_times e_d_t on e_d_t.id = cd.event_date_id
    JOIN event_check_in_steps e_i_s on e_d_t.id = e_i_s.event_date_time_id
WHERE ct.id = $1 AND ce.user_id = $2 AND ct.cancelled = $3 AND e_d_t.publish_check_in_steps = true AND ce.is_complete=$4
ORDER BY e_i_s.created_at
`

type GetChargeTicketReferenceCheckInStepParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeTicketReferenceCheckInStepRow struct {
	Photo string    `json:"photo"`
	Des   string    `json:"des"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) GetChargeTicketReferenceCheckInStep(ctx context.Context, arg GetChargeTicketReferenceCheckInStepParams) ([]GetChargeTicketReferenceCheckInStepRow, error) {
	rows, err := q.db.Query(ctx, getChargeTicketReferenceCheckInStep,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChargeTicketReferenceCheckInStepRow{}
	for rows.Next() {
		var i GetChargeTicketReferenceCheckInStepRow
		if err := rows.Scan(&i.Photo, &i.Des, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChargeTicketReferenceDirection = `-- name: GetChargeTicketReferenceDirection :one
SELECT l.street, l.city, l.state, l.country, l.postcode, o_e_i.info, l.geolocation
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN event_date_locations l on cd.event_date_id = l.event_date_time_id
    LEFT JOIN options_extra_infos o_e_i on o_e_i.option_id = o_i.id
WHERE ct.id = $1 AND o_e_i.type = $2 AND ce.user_id = $3 AND ct.cancelled = $4 AND ce.is_complete=$5
`

type GetChargeTicketReferenceDirectionParams struct {
	ID         uuid.UUID `json:"id"`
	Type       string    `json:"type"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeTicketReferenceDirectionRow struct {
	Street      string       `json:"street"`
	City        string       `json:"city"`
	State       string       `json:"state"`
	Country     string       `json:"country"`
	Postcode    string       `json:"postcode"`
	Info        pgtype.Text  `json:"info"`
	Geolocation pgtype.Point `json:"geolocation"`
}

func (q *Queries) GetChargeTicketReferenceDirection(ctx context.Context, arg GetChargeTicketReferenceDirectionParams) (GetChargeTicketReferenceDirectionRow, error) {
	row := q.db.QueryRow(ctx, getChargeTicketReferenceDirection,
		arg.ID,
		arg.Type,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var i GetChargeTicketReferenceDirectionRow
	err := row.Scan(
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Info,
		&i.Geolocation,
	)
	return i, err
}

const getChargeTicketReferenceHelp = `-- name: GetChargeTicketReferenceHelp :one
SELECT o_e_i.info
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN options_extra_infos o_e_i on o_e_i.option_id = o_i.id
WHERE ct.id = $1 AND o_e_i.type = $2 AND ce.user_id = $3 AND ct.cancelled = $4 AND ce.is_complete=$5
`

type GetChargeTicketReferenceHelpParams struct {
	ID         uuid.UUID `json:"id"`
	Type       string    `json:"type"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) GetChargeTicketReferenceHelp(ctx context.Context, arg GetChargeTicketReferenceHelpParams) (string, error) {
	row := q.db.QueryRow(ctx, getChargeTicketReferenceHelp,
		arg.ID,
		arg.Type,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var info string
	err := row.Scan(&info)
	return info, err
}

const getChargeTicketReferenceReceipt = `-- name: GetChargeTicketReferenceReceipt :one
SELECT o_i_d.host_name_option, ct.grade, ct.price, ct.ticket_type, ct.type, ce.currency
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
WHERE ct.id = $1 AND ce.user_id = $2 AND ct.cancelled = $3 AND ce.is_complete=$4
`

type GetChargeTicketReferenceReceiptParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeTicketReferenceReceiptRow struct {
	HostNameOption string `json:"host_name_option"`
	Grade          string `json:"grade"`
	Price          int64  `json:"price"`
	TicketType     string `json:"ticket_type"`
	Type           string `json:"type"`
	Currency       string `json:"currency"`
}

func (q *Queries) GetChargeTicketReferenceReceipt(ctx context.Context, arg GetChargeTicketReferenceReceiptParams) (GetChargeTicketReferenceReceiptRow, error) {
	row := q.db.QueryRow(ctx, getChargeTicketReferenceReceipt,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var i GetChargeTicketReferenceReceiptRow
	err := row.Scan(
		&i.HostNameOption,
		&i.Grade,
		&i.Price,
		&i.TicketType,
		&i.Type,
		&i.Currency,
	)
	return i, err
}

const getChargeTicketReferenceWifi = `-- name: GetChargeTicketReferenceWifi :one
SELECT w_d.network_name, w_d.password
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN wifi_details w_d on w_d.option_id = o_i.id
WHERE ct.id = $1 AND ce.user_id = $2 AND ct.cancelled = $3 AND ce.is_complete=$4
`

type GetChargeTicketReferenceWifiParams struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
}

type GetChargeTicketReferenceWifiRow struct {
	NetworkName string `json:"network_name"`
	Password    string `json:"password"`
}

func (q *Queries) GetChargeTicketReferenceWifi(ctx context.Context, arg GetChargeTicketReferenceWifiParams) (GetChargeTicketReferenceWifiRow, error) {
	row := q.db.QueryRow(ctx, getChargeTicketReferenceWifi,
		arg.ID,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
	)
	var i GetChargeTicketReferenceWifiRow
	err := row.Scan(&i.NetworkName, &i.Password)
	return i, err
}

const listAllChargeTicketReferencePayoutInsights = `-- name: ListAllChargeTicketReferencePayoutInsights :many
SELECT mp.amount, mp.time_paid, mp.currency, mp.account_number, mp.charge_id, ct.cancelled
FROM charge_ticket_references ct
    JOIN main_payouts mp on mp.charge_id = ct.id
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos oi on oi.option_user_id = ce.option_user_id
    LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
    FROM option_co_hosts AS och
    WHERE och.co_user_id = $1 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $2 OR och_subquery.option_id IS NOT NULL) AND (oi.host_id = $2 OR och_subquery.insights = true) AND DATE(cd.start_date) = DATE($3) AND ce.is_complete = $5 AND cd.event_date_id = $4 AND mp.type = 'charge_ticket_reference'
`

type ListAllChargeTicketReferencePayoutInsightsParams struct {
	CoUserID        string      `json:"co_user_id"`
	HostID          uuid.UUID   `json:"host_id"`
	Date            interface{} `json:"date"`
	EventDateID     uuid.UUID   `json:"event_date_id"`
	PaymentComplete bool        `json:"payment_complete"`
}

type ListAllChargeTicketReferencePayoutInsightsRow struct {
	Amount        int64     `json:"amount"`
	TimePaid      time.Time `json:"time_paid"`
	Currency      string    `json:"currency"`
	AccountNumber string    `json:"account_number"`
	ChargeID      uuid.UUID `json:"charge_id"`
	Cancelled     bool      `json:"cancelled"`
}

func (q *Queries) ListAllChargeTicketReferencePayoutInsights(ctx context.Context, arg ListAllChargeTicketReferencePayoutInsightsParams) ([]ListAllChargeTicketReferencePayoutInsightsRow, error) {
	rows, err := q.db.Query(ctx, listAllChargeTicketReferencePayoutInsights,
		arg.CoUserID,
		arg.HostID,
		arg.Date,
		arg.EventDateID,
		arg.PaymentComplete,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllChargeTicketReferencePayoutInsightsRow{}
	for rows.Next() {
		var i ListAllChargeTicketReferencePayoutInsightsRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.Currency,
			&i.AccountNumber,
			&i.ChargeID,
			&i.Cancelled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeTicketReferenceByEventDateID = `-- name: ListChargeTicketReferenceByEventDateID :many
SELECT ct.id, charge_date_id, ticket_id, grade, type, ct.date_booked, price, ct.service_fee, absorb_fee, ticket_type, group_price, gifted, cancelled, ct.created_at, ct.updated_at, cd.id, charge_event_id, event_date_id, start_date, end_date, cd.date_booked, start_time, end_time, total_date_fee, total_date_service_fee, total_date_absorb_fee, cd.created_at, cd.updated_at, ce.id, user_id, option_user_id, total_fee, ce.service_fee, total_absorb_fee, currency, ce.date_booked, can_instant_book, require_request, request_type, reference, payment_reference, request_approved, is_complete, ce.created_at, ce.updated_at
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE cd.event_date_id = $1  AND ct.cancelled = $2 AND ce.is_complete = $3
`

type ListChargeTicketReferenceByEventDateIDParams struct {
	EventDateID uuid.UUID `json:"event_date_id"`
	Cancelled   bool      `json:"cancelled"`
	IsComplete  bool      `json:"is_complete"`
}

type ListChargeTicketReferenceByEventDateIDRow struct {
	ID                  uuid.UUID `json:"id"`
	ChargeDateID        uuid.UUID `json:"charge_date_id"`
	TicketID            uuid.UUID `json:"ticket_id"`
	Grade               string    `json:"grade"`
	Type                string    `json:"type"`
	DateBooked          time.Time `json:"date_booked"`
	Price               int64     `json:"price"`
	ServiceFee          int64     `json:"service_fee"`
	AbsorbFee           int64     `json:"absorb_fee"`
	TicketType          string    `json:"ticket_type"`
	GroupPrice          int64     `json:"group_price"`
	Gifted              string    `json:"gifted"`
	Cancelled           bool      `json:"cancelled"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
	ID_2                uuid.UUID `json:"id_2"`
	ChargeEventID       uuid.UUID `json:"charge_event_id"`
	EventDateID         uuid.UUID `json:"event_date_id"`
	StartDate           time.Time `json:"start_date"`
	EndDate             time.Time `json:"end_date"`
	DateBooked_2        time.Time `json:"date_booked_2"`
	StartTime           string    `json:"start_time"`
	EndTime             string    `json:"end_time"`
	TotalDateFee        int64     `json:"total_date_fee"`
	TotalDateServiceFee int64     `json:"total_date_service_fee"`
	TotalDateAbsorbFee  int64     `json:"total_date_absorb_fee"`
	CreatedAt_2         time.Time `json:"created_at_2"`
	UpdatedAt_2         time.Time `json:"updated_at_2"`
	ID_3                uuid.UUID `json:"id_3"`
	UserID              uuid.UUID `json:"user_id"`
	OptionUserID        uuid.UUID `json:"option_user_id"`
	TotalFee            int64     `json:"total_fee"`
	ServiceFee_2        int64     `json:"service_fee_2"`
	TotalAbsorbFee      int64     `json:"total_absorb_fee"`
	Currency            string    `json:"currency"`
	DateBooked_3        time.Time `json:"date_booked_3"`
	CanInstantBook      bool      `json:"can_instant_book"`
	RequireRequest      bool      `json:"require_request"`
	RequestType         string    `json:"request_type"`
	Reference           string    `json:"reference"`
	PaymentReference    string    `json:"payment_reference"`
	RequestApproved     bool      `json:"request_approved"`
	IsComplete          bool      `json:"is_complete"`
	CreatedAt_3         time.Time `json:"created_at_3"`
	UpdatedAt_3         time.Time `json:"updated_at_3"`
}

func (q *Queries) ListChargeTicketReferenceByEventDateID(ctx context.Context, arg ListChargeTicketReferenceByEventDateIDParams) ([]ListChargeTicketReferenceByEventDateIDRow, error) {
	rows, err := q.db.Query(ctx, listChargeTicketReferenceByEventDateID, arg.EventDateID, arg.Cancelled, arg.IsComplete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeTicketReferenceByEventDateIDRow{}
	for rows.Next() {
		var i ListChargeTicketReferenceByEventDateIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ChargeDateID,
			&i.TicketID,
			&i.Grade,
			&i.Type,
			&i.DateBooked,
			&i.Price,
			&i.ServiceFee,
			&i.AbsorbFee,
			&i.TicketType,
			&i.GroupPrice,
			&i.Gifted,
			&i.Cancelled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.ChargeEventID,
			&i.EventDateID,
			&i.StartDate,
			&i.EndDate,
			&i.DateBooked_2,
			&i.StartTime,
			&i.EndTime,
			&i.TotalDateFee,
			&i.TotalDateServiceFee,
			&i.TotalDateAbsorbFee,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.ID_3,
			&i.UserID,
			&i.OptionUserID,
			&i.TotalFee,
			&i.ServiceFee_2,
			&i.TotalAbsorbFee,
			&i.Currency,
			&i.DateBooked_3,
			&i.CanInstantBook,
			&i.RequireRequest,
			&i.RequestType,
			&i.Reference,
			&i.PaymentReference,
			&i.RequestApproved,
			&i.IsComplete,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeTicketReferenceCurrent = `-- name: ListChargeTicketReferenceCurrent :many
SELECT o_i.main_option_type, u.user_id, o_i_d.host_name_option, cd.start_date, u.photo, cd.end_date, u.first_name, ct.id AS charge_id, ct.grade, e_d_d.start_time, e_d_d.end_time, e_d_d.time_zone, e_d_t.check_in_method, o_p_p.cover_image, o_p_p.photo, ct.ticket_type, e_i.event_type, e_d_l.street, e_d_l.state, e_d_l.city, e_d_l.country, o_p_p.public_cover_image, o_p_p.public_photo AS option_public_photo, u.public_photo AS host_public_photo,
CASE
    WHEN NOW() > cd.end_date + INTERVAL '4 hours' AND NOT EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id) THEN 'started'
    WHEN NOW() > cd.end_date + INTERVAL '4 hours' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id) THEN cr.status
    ELSE 'none'
END AS review_stage 
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN event_date_times e_d_t on e_d_t.id = cd.event_date_id
    JOIN event_date_details e_d_d on e_d_d.event_date_time_id = cd.event_date_id
    LEFT JOIN event_date_locations e_d_l on e_d_l.event_date_time_id = cd.event_date_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN event_infos e_i on e_i.option_id = o_i.id
    JOIN options_info_photos o_p_p on o_i.id = o_p_p.option_id
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
    JOIN users u on u.id = o_i.host_id
	LEFT JOIN charge_reviews cr on cr.charge_id = ct.id
WHERE ce.user_id = $1 AND ct.cancelled = $2 AND ce.is_complete = $3 AND (NOW() <= cd.end_date + INTERVAL '13 days' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id AND cr.is_published = false) OR NOW() <= cd.end_date + INTERVAL '13 days' AND NOT EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id))
ORDER BY
CASE
    WHEN cd.end_date + INTERVAL '13 days' <= NOW() AND NOT EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id) THEN 1
    WHEN cd.end_date + INTERVAL '13 days' <= NOW() AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id AND cr.is_published = false) THEN 2
    WHEN cd.start_date = CURRENT_DATE OR cd.start_date - INTERVAL '1 day' <= CURRENT_DATE THEN 3
    ELSE 4
END, cd.start_date ASC 
LIMIT $4
OFFSET $5
`

type ListChargeTicketReferenceCurrentParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type ListChargeTicketReferenceCurrentRow struct {
	MainOptionType    string      `json:"main_option_type"`
	UserID            uuid.UUID   `json:"user_id"`
	HostNameOption    string      `json:"host_name_option"`
	StartDate         time.Time   `json:"start_date"`
	Photo             string      `json:"photo"`
	EndDate           time.Time   `json:"end_date"`
	FirstName         string      `json:"first_name"`
	ChargeID          uuid.UUID   `json:"charge_id"`
	Grade             string      `json:"grade"`
	StartTime         string      `json:"start_time"`
	EndTime           string      `json:"end_time"`
	TimeZone          string      `json:"time_zone"`
	CheckInMethod     string      `json:"check_in_method"`
	CoverImage        string      `json:"cover_image"`
	Photo_2           []string    `json:"photo_2"`
	TicketType        string      `json:"ticket_type"`
	EventType         string      `json:"event_type"`
	Street            pgtype.Text `json:"street"`
	State             pgtype.Text `json:"state"`
	City              pgtype.Text `json:"city"`
	Country           pgtype.Text `json:"country"`
	PublicCoverImage  string      `json:"public_cover_image"`
	OptionPublicPhoto []string    `json:"option_public_photo"`
	HostPublicPhoto   string      `json:"host_public_photo"`
	ReviewStage       string      `json:"review_stage"`
}

func (q *Queries) ListChargeTicketReferenceCurrent(ctx context.Context, arg ListChargeTicketReferenceCurrentParams) ([]ListChargeTicketReferenceCurrentRow, error) {
	rows, err := q.db.Query(ctx, listChargeTicketReferenceCurrent,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeTicketReferenceCurrentRow{}
	for rows.Next() {
		var i ListChargeTicketReferenceCurrentRow
		if err := rows.Scan(
			&i.MainOptionType,
			&i.UserID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Photo,
			&i.EndDate,
			&i.FirstName,
			&i.ChargeID,
			&i.Grade,
			&i.StartTime,
			&i.EndTime,
			&i.TimeZone,
			&i.CheckInMethod,
			&i.CoverImage,
			&i.Photo_2,
			&i.TicketType,
			&i.EventType,
			&i.Street,
			&i.State,
			&i.City,
			&i.Country,
			&i.PublicCoverImage,
			&i.OptionPublicPhoto,
			&i.HostPublicPhoto,
			&i.ReviewStage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeTicketReferenceIDByStartDate = `-- name: ListChargeTicketReferenceIDByStartDate :many
SELECT ct.id AS charge_id
FROM charge_ticket_references ct
    JOIN main_payouts mp on mp.charge_id = ct.id
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE DATE(cd.start_date) = DATE($1) AND ct.cancelled = $2 AND ce.is_complete = $3 AND cd.event_date_id = $4
`

type ListChargeTicketReferenceIDByStartDateParams struct {
	Date        interface{} `json:"date"`
	Cancelled   bool        `json:"cancelled"`
	IsComplete  bool        `json:"is_complete"`
	EventDateID uuid.UUID   `json:"event_date_id"`
}

func (q *Queries) ListChargeTicketReferenceIDByStartDate(ctx context.Context, arg ListChargeTicketReferenceIDByStartDateParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, listChargeTicketReferenceIDByStartDate,
		arg.Date,
		arg.Cancelled,
		arg.IsComplete,
		arg.EventDateID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var charge_id uuid.UUID
		if err := rows.Scan(&charge_id); err != nil {
			return nil, err
		}
		items = append(items, charge_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeTicketReferencePayout = `-- name: ListChargeTicketReferencePayout :many
SELECT mp.amount, mp.time_paid, mp.currency, mp.account_number
FROM charge_ticket_references ct
    JOIN main_payouts mp on mp.charge_id = ct.id
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
WHERE DATE(cd.start_date) = DATE($1) AND ct.cancelled = $2 AND ce.is_complete = $4 AND cd.event_date_id = $3 AND mp.is_complete = $5 AND mp.type = 'charge_ticket_reference'
`

type ListChargeTicketReferencePayoutParams struct {
	Date            interface{} `json:"date"`
	Cancelled       bool        `json:"cancelled"`
	EventDateID     uuid.UUID   `json:"event_date_id"`
	PaymentComplete bool        `json:"payment_complete"`
	PayoutComplete  bool        `json:"payout_complete"`
}

type ListChargeTicketReferencePayoutRow struct {
	Amount        int64     `json:"amount"`
	TimePaid      time.Time `json:"time_paid"`
	Currency      string    `json:"currency"`
	AccountNumber string    `json:"account_number"`
}

func (q *Queries) ListChargeTicketReferencePayout(ctx context.Context, arg ListChargeTicketReferencePayoutParams) ([]ListChargeTicketReferencePayoutRow, error) {
	rows, err := q.db.Query(ctx, listChargeTicketReferencePayout,
		arg.Date,
		arg.Cancelled,
		arg.EventDateID,
		arg.PaymentComplete,
		arg.PayoutComplete,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeTicketReferencePayoutRow{}
	for rows.Next() {
		var i ListChargeTicketReferencePayoutRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.Currency,
			&i.AccountNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeTicketReferencePayoutInsights = `-- name: ListChargeTicketReferencePayoutInsights :many
SELECT mp.amount, mp.time_paid, mp.currency, mp.account_number, mp.charge_id, ct.cancelled
FROM charge_ticket_references ct
    JOIN main_payouts mp on mp.charge_id = ct.id
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos oi on oi.option_user_id = ce.option_user_id
    LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
    FROM option_co_hosts AS och
    WHERE och.co_user_id = $1 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $2 OR och_subquery.option_id IS NOT NULL) AND (oi.host_id = $2 OR och_subquery.insights = true) AND DATE(cd.start_date) = DATE($3) AND ce.is_complete = $6 AND cd.event_date_id = $4 AND oi.option_user_id = $5 AND mp.type = 'charge_ticket_reference'
`

type ListChargeTicketReferencePayoutInsightsParams struct {
	CoUserID        string      `json:"co_user_id"`
	HostID          uuid.UUID   `json:"host_id"`
	Date            interface{} `json:"date"`
	EventDateID     uuid.UUID   `json:"event_date_id"`
	OptionUserID    uuid.UUID   `json:"option_user_id"`
	PaymentComplete bool        `json:"payment_complete"`
}

type ListChargeTicketReferencePayoutInsightsRow struct {
	Amount        int64     `json:"amount"`
	TimePaid      time.Time `json:"time_paid"`
	Currency      string    `json:"currency"`
	AccountNumber string    `json:"account_number"`
	ChargeID      uuid.UUID `json:"charge_id"`
	Cancelled     bool      `json:"cancelled"`
}

func (q *Queries) ListChargeTicketReferencePayoutInsights(ctx context.Context, arg ListChargeTicketReferencePayoutInsightsParams) ([]ListChargeTicketReferencePayoutInsightsRow, error) {
	rows, err := q.db.Query(ctx, listChargeTicketReferencePayoutInsights,
		arg.CoUserID,
		arg.HostID,
		arg.Date,
		arg.EventDateID,
		arg.OptionUserID,
		arg.PaymentComplete,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeTicketReferencePayoutInsightsRow{}
	for rows.Next() {
		var i ListChargeTicketReferencePayoutInsightsRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.Currency,
			&i.AccountNumber,
			&i.ChargeID,
			&i.Cancelled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargeTicketReferenceVisited = `-- name: ListChargeTicketReferenceVisited :many
SELECT o_i.main_option_type, u.user_id, o_i_d.host_name_option, cd.start_date, u.photo, cd.end_date, u.first_name, ct.id AS charge_id, ct.grade, e_d_d.start_time, e_d_d.end_time, e_d_d.time_zone, e_d_t.check_in_method, o_p_p.cover_image, o_p_p.photo, ct.ticket_type, e_i.event_type, e_d_l.street, e_d_l.state, e_d_l.city, e_d_l.country, o_p_p.public_cover_image, o_p_p.public_photo AS option_public_photo, u.public_photo AS host_public_photo
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN event_date_times e_d_t on e_d_t.id = cd.event_date_id
    JOIN event_date_details e_d_d on e_d_d.event_date_time_id = cd.event_date_id
    LEFT JOIN event_date_locations e_d_l on e_d_l.event_date_time_id = cd.event_date_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN event_infos e_i on e_i.option_id = o_i.id
    JOIN options_info_photos o_p_p on o_i.id = o_p_p.option_id
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
    JOIN users u on u.id = o_i.host_id
	LEFT JOIN charge_reviews cr on cr.charge_id = ct.id
WHERE ce.user_id = $1 AND ct.cancelled = $2 AND ce.is_complete = $3 AND (NOW() > cd.end_date + INTERVAL '8 hours' AND EXISTS (SELECT 1 FROM charge_reviews cr WHERE cr.charge_id = ct.id AND cr.is_published = TRUE) OR NOW() > cd.end_date + INTERVAL '13 days')
ORDER BY cd.end_date DESC
LIMIT $4
OFFSET $5
`

type ListChargeTicketReferenceVisitedParams struct {
	UserID     uuid.UUID `json:"user_id"`
	Cancelled  bool      `json:"cancelled"`
	IsComplete bool      `json:"is_complete"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type ListChargeTicketReferenceVisitedRow struct {
	MainOptionType    string      `json:"main_option_type"`
	UserID            uuid.UUID   `json:"user_id"`
	HostNameOption    string      `json:"host_name_option"`
	StartDate         time.Time   `json:"start_date"`
	Photo             string      `json:"photo"`
	EndDate           time.Time   `json:"end_date"`
	FirstName         string      `json:"first_name"`
	ChargeID          uuid.UUID   `json:"charge_id"`
	Grade             string      `json:"grade"`
	StartTime         string      `json:"start_time"`
	EndTime           string      `json:"end_time"`
	TimeZone          string      `json:"time_zone"`
	CheckInMethod     string      `json:"check_in_method"`
	CoverImage        string      `json:"cover_image"`
	Photo_2           []string    `json:"photo_2"`
	TicketType        string      `json:"ticket_type"`
	EventType         string      `json:"event_type"`
	Street            pgtype.Text `json:"street"`
	State             pgtype.Text `json:"state"`
	City              pgtype.Text `json:"city"`
	Country           pgtype.Text `json:"country"`
	PublicCoverImage  string      `json:"public_cover_image"`
	OptionPublicPhoto []string    `json:"option_public_photo"`
	HostPublicPhoto   string      `json:"host_public_photo"`
}

func (q *Queries) ListChargeTicketReferenceVisited(ctx context.Context, arg ListChargeTicketReferenceVisitedParams) ([]ListChargeTicketReferenceVisitedRow, error) {
	rows, err := q.db.Query(ctx, listChargeTicketReferenceVisited,
		arg.UserID,
		arg.Cancelled,
		arg.IsComplete,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChargeTicketReferenceVisitedRow{}
	for rows.Next() {
		var i ListChargeTicketReferenceVisitedRow
		if err := rows.Scan(
			&i.MainOptionType,
			&i.UserID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Photo,
			&i.EndDate,
			&i.FirstName,
			&i.ChargeID,
			&i.Grade,
			&i.StartTime,
			&i.EndTime,
			&i.TimeZone,
			&i.CheckInMethod,
			&i.CoverImage,
			&i.Photo_2,
			&i.TicketType,
			&i.EventType,
			&i.Street,
			&i.State,
			&i.City,
			&i.Country,
			&i.PublicCoverImage,
			&i.OptionPublicPhoto,
			&i.HostPublicPhoto,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketPaymentUser = `-- name: ListTicketPaymentUser :many
SELECT o_i.main_option_type, u.user_id, o_i_d.host_name_option, cd.start_date, u.photo, cd.end_date, u.first_name, ct.id, ct.grade, ct.ticket_type, ct.price, ct.cancelled, ce.currency, ct.date_booked
FROM charge_ticket_references ct
    JOIN charge_date_references cd on cd.id = ct.charge_date_id
    JOIN charge_event_references ce on ce.id = cd.charge_event_id
    JOIN options_infos o_i on o_i.option_user_id = ce.option_user_id
    JOIN options_info_details o_i_d on o_i.id = o_i_d.option_id
    JOIN users u on u.id = o_i.host_id
WHERE ce.user_id = $1 AND ce.is_complete = $2
LIMIT $3
OFFSET $4
`

type ListTicketPaymentUserParams struct {
	UserID     uuid.UUID `json:"user_id"`
	IsComplete bool      `json:"is_complete"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type ListTicketPaymentUserRow struct {
	MainOptionType string    `json:"main_option_type"`
	UserID         uuid.UUID `json:"user_id"`
	HostNameOption string    `json:"host_name_option"`
	StartDate      time.Time `json:"start_date"`
	Photo          string    `json:"photo"`
	EndDate        time.Time `json:"end_date"`
	FirstName      string    `json:"first_name"`
	ID             uuid.UUID `json:"id"`
	Grade          string    `json:"grade"`
	TicketType     string    `json:"ticket_type"`
	Price          int64     `json:"price"`
	Cancelled      bool      `json:"cancelled"`
	Currency       string    `json:"currency"`
	DateBooked     time.Time `json:"date_booked"`
}

func (q *Queries) ListTicketPaymentUser(ctx context.Context, arg ListTicketPaymentUserParams) ([]ListTicketPaymentUserRow, error) {
	rows, err := q.db.Query(ctx, listTicketPaymentUser,
		arg.UserID,
		arg.IsComplete,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTicketPaymentUserRow{}
	for rows.Next() {
		var i ListTicketPaymentUserRow
		if err := rows.Scan(
			&i.MainOptionType,
			&i.UserID,
			&i.HostNameOption,
			&i.StartDate,
			&i.Photo,
			&i.EndDate,
			&i.FirstName,
			&i.ID,
			&i.Grade,
			&i.TicketType,
			&i.Price,
			&i.Cancelled,
			&i.Currency,
			&i.DateBooked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChargeTicketReferenceByID = `-- name: UpdateChargeTicketReferenceByID :one
UPDATE charge_ticket_references
SET 
    cancelled = COALESCE($1, cancelled),
    updated_at = NOW()
WHERE id = $2
RETURNING id, charge_date_id, ticket_id, grade, type, date_booked, price, service_fee, absorb_fee, ticket_type, group_price, gifted, cancelled, created_at, updated_at
`

type UpdateChargeTicketReferenceByIDParams struct {
	Cancelled pgtype.Bool `json:"cancelled"`
	ID        uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateChargeTicketReferenceByID(ctx context.Context, arg UpdateChargeTicketReferenceByIDParams) (ChargeTicketReference, error) {
	row := q.db.QueryRow(ctx, updateChargeTicketReferenceByID, arg.Cancelled, arg.ID)
	var i ChargeTicketReference
	err := row.Scan(
		&i.ID,
		&i.ChargeDateID,
		&i.TicketID,
		&i.Grade,
		&i.Type,
		&i.DateBooked,
		&i.Price,
		&i.ServiceFee,
		&i.AbsorbFee,
		&i.TicketType,
		&i.GroupPrice,
		&i.Gifted,
		&i.Cancelled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
