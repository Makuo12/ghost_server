// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: options_infos_three.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const listOptionInfoPrice = `-- name: ListOptionInfoPrice :many
SELECT price, weekend_price
FROM options_infos oi
    JOIN options_infos_status ois on oi.id = ois.option_id
    JOIN options_prices op on oi.id = op.option_id
    JOIN users u on oi.host_id = u.id
WHERE oi.is_complete = true AND oi.is_active = true AND u.is_active = true AND ois.status != 'unlist' AND ois.status != 'snooze'
ORDER BY op.price
`

type ListOptionInfoPriceRow struct {
	Price        int64 `json:"price"`
	WeekendPrice int64 `json:"weekend_price"`
}

func (q *Queries) ListOptionInfoPrice(ctx context.Context) ([]ListOptionInfoPriceRow, error) {
	rows, err := q.db.Query(ctx, listOptionInfoPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionInfoPriceRow{}
	for rows.Next() {
		var i ListOptionInfoPriceRow
		if err := rows.Scan(&i.Price, &i.WeekendPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionInfoSearch = `-- name: ListOptionInfoSearch :many
SELECT oi.option_user_id, oi.id, oid.host_name_option, oi.is_verified AS option_is_verified, oip.cover_image, oip.photo, oq.host_as_individual, op.price, op.weekend_price, oi.currency, s.type_of_shortlet, l.state, l.country, oi.category, oi.category_two, oi.category_three, oi.category_four, u.first_name AS host_name, u.created_at, id.is_verified AS host_verified, u.photo AS profile_photo, oid.pets_allowed, s.guest_welcomed, oas.advance_notice, oas.auto_block_dates, oas.advance_notice_condition, oas.preparation_time, oas.availability_window, otl.min_stay_day, otl.max_stay_night, otl.manual_approve_request_pass_max, otl.allow_reservation_request, s.space_type, s.check_in_method, obm.instant_book
FROM options_infos oi
    JOIN options_info_details oid on oi.id = oid.option_id
    JOIN options_info_photos oip on oi.id = oip.option_id
    JOIN shortlets s on oi.id = s.option_id
    JOIN options_infos_status ois on oi.id = ois.option_id
    JOIN option_questions oq on oi.id = oq.option_id
    JOIN options_prices op on oi.id = op.option_id
    JOIN locations l on oi.id = l.option_id
    JOIN users u on oi.host_id = u.id
    JOIN option_book_methods obm on oi.id = obm.option_id
    JOIN identity id on u.id = id.user_id
    JOIN option_availability_settings oas on oi.id = oas.option_id
    JOIN option_trip_lengths otl on oi.id = otl.option_id
WHERE oi.is_complete = true AND oi.is_active = true AND u.is_active = true AND ois.status != 'unlist' AND ois.status != 'snooze'
`

type ListOptionInfoSearchRow struct {
	OptionUserID                uuid.UUID `json:"option_user_id"`
	ID                          uuid.UUID `json:"id"`
	HostNameOption              string    `json:"host_name_option"`
	OptionIsVerified            bool      `json:"option_is_verified"`
	CoverImage                  string    `json:"cover_image"`
	Photo                       []string  `json:"photo"`
	HostAsIndividual            bool      `json:"host_as_individual"`
	Price                       int64     `json:"price"`
	WeekendPrice                int64     `json:"weekend_price"`
	Currency                    string    `json:"currency"`
	TypeOfShortlet              string    `json:"type_of_shortlet"`
	State                       string    `json:"state"`
	Country                     string    `json:"country"`
	Category                    string    `json:"category"`
	CategoryTwo                 string    `json:"category_two"`
	CategoryThree               string    `json:"category_three"`
	CategoryFour                string    `json:"category_four"`
	HostName                    string    `json:"host_name"`
	CreatedAt                   time.Time `json:"created_at"`
	HostVerified                bool      `json:"host_verified"`
	ProfilePhoto                string    `json:"profile_photo"`
	PetsAllowed                 bool      `json:"pets_allowed"`
	GuestWelcomed               int32     `json:"guest_welcomed"`
	AdvanceNotice               string    `json:"advance_notice"`
	AutoBlockDates              bool      `json:"auto_block_dates"`
	AdvanceNoticeCondition      string    `json:"advance_notice_condition"`
	PreparationTime             string    `json:"preparation_time"`
	AvailabilityWindow          string    `json:"availability_window"`
	MinStayDay                  int32     `json:"min_stay_day"`
	MaxStayNight                int32     `json:"max_stay_night"`
	ManualApproveRequestPassMax bool      `json:"manual_approve_request_pass_max"`
	AllowReservationRequest     bool      `json:"allow_reservation_request"`
	SpaceType                   string    `json:"space_type"`
	CheckInMethod               string    `json:"check_in_method"`
	InstantBook                 bool      `json:"instant_book"`
}

func (q *Queries) ListOptionInfoSearch(ctx context.Context) ([]ListOptionInfoSearchRow, error) {
	rows, err := q.db.Query(ctx, listOptionInfoSearch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionInfoSearchRow{}
	for rows.Next() {
		var i ListOptionInfoSearchRow
		if err := rows.Scan(
			&i.OptionUserID,
			&i.ID,
			&i.HostNameOption,
			&i.OptionIsVerified,
			&i.CoverImage,
			&i.Photo,
			&i.HostAsIndividual,
			&i.Price,
			&i.WeekendPrice,
			&i.Currency,
			&i.TypeOfShortlet,
			&i.State,
			&i.Country,
			&i.Category,
			&i.CategoryTwo,
			&i.CategoryThree,
			&i.CategoryFour,
			&i.HostName,
			&i.CreatedAt,
			&i.HostVerified,
			&i.ProfilePhoto,
			&i.PetsAllowed,
			&i.GuestWelcomed,
			&i.AdvanceNotice,
			&i.AutoBlockDates,
			&i.AdvanceNoticeCondition,
			&i.PreparationTime,
			&i.AvailabilityWindow,
			&i.MinStayDay,
			&i.MaxStayNight,
			&i.ManualApproveRequestPassMax,
			&i.AllowReservationRequest,
			&i.SpaceType,
			&i.CheckInMethod,
			&i.InstantBook,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionInfoSearchLocation = `-- name: ListOptionInfoSearchLocation :many

SELECT oi.option_user_id, oi.id, oid.host_name_option, oi.is_verified AS option_is_verified, oip.cover_image, oip.photo, oq.host_as_individual, op.price, op.weekend_price, oi.currency, s.type_of_shortlet, l.state, l.country, oi.category, oi.category_two, oi.category_three, oi.category_four, u.first_name AS host_name, u.created_at, id.is_verified AS host_verified, u.photo AS profile_photo, oid.pets_allowed, s.guest_welcomed, oas.advance_notice, oas.auto_block_dates, oas.advance_notice_condition, oas.preparation_time, oas.availability_window, otl.min_stay_day, otl.max_stay_night, otl.manual_approve_request_pass_max, otl.allow_reservation_request, s.space_type, s.check_in_method, obm.instant_book
FROM options_infos oi
    JOIN options_info_details oid on oi.id = oid.option_id
    JOIN options_info_photos oip on oi.id = oip.option_id
    JOIN shortlets s on oi.id = s.option_id
    JOIN options_infos_status ois on oi.id = ois.option_id
    JOIN option_questions oq on oi.id = oq.option_id
    JOIN options_prices op on oi.id = op.option_id
    JOIN locations l on oi.id = l.option_id
    JOIN users u on oi.host_id = u.id
    JOIN option_book_methods obm on oi.id = obm.option_id
    JOIN identity id on u.id = id.user_id
    JOIN option_availability_settings oas on oi.id = oas.option_id
    JOIN option_trip_lengths otl on oi.id = otl.option_id
WHERE oi.is_complete = true AND oi.is_active = true AND u.is_active = true AND ois.status != 'unlist' AND ois.status != 'snooze' AND (l.state = $1 OR l.city = $2 OR l.country = $3 OR l.street ILIKE $4 OR CAST(earth_distance(
        ll_to_earth(l.geolocation[1], l.geolocation[0]),
        ll_to_earth($5, $6)
    ) AS FLOAT) < CAST($7 AS FLOAT))
`

type ListOptionInfoSearchLocationParams struct {
	State       string  `json:"state"`
	City        string  `json:"city"`
	Country     string  `json:"country"`
	Street      string  `json:"street"`
	LlToEarth   float64 `json:"ll_to_earth"`
	LlToEarth_2 float64 `json:"ll_to_earth_2"`
	Column7     float64 `json:"column_7"`
}

type ListOptionInfoSearchLocationRow struct {
	OptionUserID                uuid.UUID `json:"option_user_id"`
	ID                          uuid.UUID `json:"id"`
	HostNameOption              string    `json:"host_name_option"`
	OptionIsVerified            bool      `json:"option_is_verified"`
	CoverImage                  string    `json:"cover_image"`
	Photo                       []string  `json:"photo"`
	HostAsIndividual            bool      `json:"host_as_individual"`
	Price                       int64     `json:"price"`
	WeekendPrice                int64     `json:"weekend_price"`
	Currency                    string    `json:"currency"`
	TypeOfShortlet              string    `json:"type_of_shortlet"`
	State                       string    `json:"state"`
	Country                     string    `json:"country"`
	Category                    string    `json:"category"`
	CategoryTwo                 string    `json:"category_two"`
	CategoryThree               string    `json:"category_three"`
	CategoryFour                string    `json:"category_four"`
	HostName                    string    `json:"host_name"`
	CreatedAt                   time.Time `json:"created_at"`
	HostVerified                bool      `json:"host_verified"`
	ProfilePhoto                string    `json:"profile_photo"`
	PetsAllowed                 bool      `json:"pets_allowed"`
	GuestWelcomed               int32     `json:"guest_welcomed"`
	AdvanceNotice               string    `json:"advance_notice"`
	AutoBlockDates              bool      `json:"auto_block_dates"`
	AdvanceNoticeCondition      string    `json:"advance_notice_condition"`
	PreparationTime             string    `json:"preparation_time"`
	AvailabilityWindow          string    `json:"availability_window"`
	MinStayDay                  int32     `json:"min_stay_day"`
	MaxStayNight                int32     `json:"max_stay_night"`
	ManualApproveRequestPassMax bool      `json:"manual_approve_request_pass_max"`
	AllowReservationRequest     bool      `json:"allow_reservation_request"`
	SpaceType                   string    `json:"space_type"`
	CheckInMethod               string    `json:"check_in_method"`
	InstantBook                 bool      `json:"instant_book"`
}

// Mostly for handling filters
func (q *Queries) ListOptionInfoSearchLocation(ctx context.Context, arg ListOptionInfoSearchLocationParams) ([]ListOptionInfoSearchLocationRow, error) {
	rows, err := q.db.Query(ctx, listOptionInfoSearchLocation,
		arg.State,
		arg.City,
		arg.Country,
		arg.Street,
		arg.LlToEarth,
		arg.LlToEarth_2,
		arg.Column7,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionInfoSearchLocationRow{}
	for rows.Next() {
		var i ListOptionInfoSearchLocationRow
		if err := rows.Scan(
			&i.OptionUserID,
			&i.ID,
			&i.HostNameOption,
			&i.OptionIsVerified,
			&i.CoverImage,
			&i.Photo,
			&i.HostAsIndividual,
			&i.Price,
			&i.WeekendPrice,
			&i.Currency,
			&i.TypeOfShortlet,
			&i.State,
			&i.Country,
			&i.Category,
			&i.CategoryTwo,
			&i.CategoryThree,
			&i.CategoryFour,
			&i.HostName,
			&i.CreatedAt,
			&i.HostVerified,
			&i.ProfilePhoto,
			&i.PetsAllowed,
			&i.GuestWelcomed,
			&i.AdvanceNotice,
			&i.AutoBlockDates,
			&i.AdvanceNoticeCondition,
			&i.PreparationTime,
			&i.AvailabilityWindow,
			&i.MinStayDay,
			&i.MaxStayNight,
			&i.ManualApproveRequestPassMax,
			&i.AllowReservationRequest,
			&i.SpaceType,
			&i.CheckInMethod,
			&i.InstantBook,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
