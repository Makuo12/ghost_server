// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: complete_option_info.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createCompleteOptionInfo = `-- name: CreateCompleteOptionInfo :one
INSERT INTO complete_option_info (
    option_id,
    current_state,
    previous_state
    )
VALUES ($1, $2, $3)
RETURNING option_id, current_state, previous_state, created_at, updated_at
`

type CreateCompleteOptionInfoParams struct {
	OptionID      uuid.UUID `json:"option_id"`
	CurrentState  string    `json:"current_state"`
	PreviousState string    `json:"previous_state"`
}

func (q *Queries) CreateCompleteOptionInfo(ctx context.Context, arg CreateCompleteOptionInfoParams) (CompleteOptionInfo, error) {
	row := q.db.QueryRow(ctx, createCompleteOptionInfo, arg.OptionID, arg.CurrentState, arg.PreviousState)
	var i CompleteOptionInfo
	err := row.Scan(
		&i.OptionID,
		&i.CurrentState,
		&i.PreviousState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompleteOptionInfo = `-- name: GetCompleteOptionInfo :one
SELECT c_o_i.option_id
FROM complete_option_info c_o_i
JOIN options_infos o_i on c_o_i.option_id = o_i.id
WHERE c_o_i.option_id = $1 AND o_i.host_id = $2
`

type GetCompleteOptionInfoParams struct {
	OptionID uuid.UUID `json:"option_id"`
	HostID   uuid.UUID `json:"host_id"`
}

func (q *Queries) GetCompleteOptionInfo(ctx context.Context, arg GetCompleteOptionInfoParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getCompleteOptionInfo, arg.OptionID, arg.HostID)
	var option_id uuid.UUID
	err := row.Scan(&option_id)
	return option_id, err
}

const getCompleteOptionInfoAll = `-- name: GetCompleteOptionInfoAll :one
SELECT option_id, current_state, previous_state, c_o_i.created_at, c_o_i.updated_at, id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, o_i.created_at, completed, o_i.updated_at
FROM complete_option_info c_o_i
JOIN options_infos o_i on c_o_i.option_id = o_i.id
WHERE c_o_i.option_id = $1 AND o_i.host_id = $2
`

type GetCompleteOptionInfoAllParams struct {
	OptionID uuid.UUID `json:"option_id"`
	HostID   uuid.UUID `json:"host_id"`
}

type GetCompleteOptionInfoAllRow struct {
	OptionID       uuid.UUID `json:"option_id"`
	CurrentState   string    `json:"current_state"`
	PreviousState  string    `json:"previous_state"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	ID             uuid.UUID `json:"id"`
	CoHostID       uuid.UUID `json:"co_host_id"`
	OptionUserID   uuid.UUID `json:"option_user_id"`
	HostID         uuid.UUID `json:"host_id"`
	DeepLinkID     uuid.UUID `json:"deep_link_id"`
	PrimaryUserID  uuid.UUID `json:"primary_user_id"`
	IsActive       bool      `json:"is_active"`
	IsComplete     bool      `json:"is_complete"`
	IsVerified     bool      `json:"is_verified"`
	Category       string    `json:"category"`
	CategoryTwo    string    `json:"category_two"`
	CategoryThree  string    `json:"category_three"`
	CategoryFour   string    `json:"category_four"`
	IsTopSeller    bool      `json:"is_top_seller"`
	TimeZone       string    `json:"time_zone"`
	Currency       string    `json:"currency"`
	OptionImg      string    `json:"option_img"`
	OptionType     string    `json:"option_type"`
	MainOptionType string    `json:"main_option_type"`
	CreatedAt_2    time.Time `json:"created_at_2"`
	Completed      time.Time `json:"completed"`
	UpdatedAt_2    time.Time `json:"updated_at_2"`
}

func (q *Queries) GetCompleteOptionInfoAll(ctx context.Context, arg GetCompleteOptionInfoAllParams) (GetCompleteOptionInfoAllRow, error) {
	row := q.db.QueryRow(ctx, getCompleteOptionInfoAll, arg.OptionID, arg.HostID)
	var i GetCompleteOptionInfoAllRow
	err := row.Scan(
		&i.OptionID,
		&i.CurrentState,
		&i.PreviousState,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID,
		&i.CoHostID,
		&i.OptionUserID,
		&i.HostID,
		&i.DeepLinkID,
		&i.PrimaryUserID,
		&i.IsActive,
		&i.IsComplete,
		&i.IsVerified,
		&i.Category,
		&i.CategoryTwo,
		&i.CategoryThree,
		&i.CategoryFour,
		&i.IsTopSeller,
		&i.TimeZone,
		&i.Currency,
		&i.OptionImg,
		&i.OptionType,
		&i.MainOptionType,
		&i.CreatedAt_2,
		&i.Completed,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getCompleteOptionInfoTwo = `-- name: GetCompleteOptionInfoTwo :one
SELECT option_id, current_state, previous_state, created_at, updated_at
FROM complete_option_info
WHERE option_id = $1
`

func (q *Queries) GetCompleteOptionInfoTwo(ctx context.Context, optionID uuid.UUID) (CompleteOptionInfo, error) {
	row := q.db.QueryRow(ctx, getCompleteOptionInfoTwo, optionID)
	var i CompleteOptionInfo
	err := row.Scan(
		&i.OptionID,
		&i.CurrentState,
		&i.PreviousState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeCompleteOptionInfo = `-- name: RemoveCompleteOptionInfo :exec
DELETE FROM complete_option_info
WHERE option_id = $1
`

func (q *Queries) RemoveCompleteOptionInfo(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeCompleteOptionInfo, optionID)
	return err
}

const removeCompleteOptionInfoByID = `-- name: RemoveCompleteOptionInfoByID :exec

DELETE
FROM complete_option_info
WHERE option_id = $1
`

// -- name: RemoveCompleteOptionInfo :exec
// DELETE
// FROM complete_option_info
// USING complete_option_info
// JOIN options_infos on complete_option_info.option_id = options_infos.id
// WHERE complete_option_info.option_id = $1 AND options_infos.host_id = $2;
func (q *Queries) RemoveCompleteOptionInfoByID(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeCompleteOptionInfoByID, optionID)
	return err
}

const updateCompleteOptionInfo = `-- name: UpdateCompleteOptionInfo :one
UPDATE complete_option_info
SET current_state = $2,
    previous_state = $3,
    updated_at = NOW()
WHERE option_id = $1
RETURNING option_id, current_state, previous_state, created_at, updated_at
`

type UpdateCompleteOptionInfoParams struct {
	OptionID      uuid.UUID `json:"option_id"`
	CurrentState  string    `json:"current_state"`
	PreviousState string    `json:"previous_state"`
}

func (q *Queries) UpdateCompleteOptionInfo(ctx context.Context, arg UpdateCompleteOptionInfoParams) (CompleteOptionInfo, error) {
	row := q.db.QueryRow(ctx, updateCompleteOptionInfo, arg.OptionID, arg.CurrentState, arg.PreviousState)
	var i CompleteOptionInfo
	err := row.Scan(
		&i.OptionID,
		&i.CurrentState,
		&i.PreviousState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
