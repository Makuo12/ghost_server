// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: refund_payouts.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRefundPayout = `-- name: CountRefundPayout :one
SELECT
    Count(*)
FROM refund_payouts AS re
JOIN main_payouts AS mp ON mp.charge_id = re.charge_id
LEFT JOIN charge_option_references AS co
    ON mp.Type = 'charge_option_reference'
    AND re.charge_id = co.id
LEFT JOIN charge_ticket_references AS ct
    ON mp.Type = 'charge_ticket_references'
    AND re.charge_id = ct.id
LEFT JOIN charge_date_references AS cd
    ON mp.Type = 'charge_ticket_references'
    AND ct.charge_date_id = cd.id
LEFT JOIN charge_event_references AS ce
    ON mp.Type = 'charge_ticket_references'
    AND cd.charge_event_id = ce.id
LEFT JOIN options_infos AS oi
    ON (mp.Type = 'charge_option_reference' AND co.option_user_id = oi.option_user_id)
    OR (mp.Type = 'charge_ticket_references' AND ce.option_user_id = oi.option_user_id)
LEFT JOIN options_info_details AS od ON oi.id = od.option_id
LEFT JOIN users AS u
    ON (mp.Type = 'charge_option_reference' AND co.user_id = u.user_id)
    OR (mp.Type = 'charge_ticket_references' AND ce.user_id = u.user_id)
WHERE re.is_complete = $1 AND re.user_id = $2
`

type CountRefundPayoutParams struct {
	PayoutIsComplete bool      `json:"payout_is_complete"`
	UID              uuid.UUID `json:"u_id"`
}

func (q *Queries) CountRefundPayout(ctx context.Context, arg CountRefundPayoutParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRefundPayout, arg.PayoutIsComplete, arg.UID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRefundPayout = `-- name: CreateRefundPayout :one
INSERT INTO refund_payouts (
    charge_id,
    amount,
    user_id,
    currency,
    service_fee
) VALUES ($1, $2, $3, $4, $5)
RETURNING charge_id, amount, service_fee, user_id, time_paid, currency, account_number, is_complete, created_at, updated_at
`

type CreateRefundPayoutParams struct {
	ChargeID   uuid.UUID `json:"charge_id"`
	Amount     int64     `json:"amount"`
	UserID     uuid.UUID `json:"user_id"`
	Currency   string    `json:"currency"`
	ServiceFee int64     `json:"service_fee"`
}

func (q *Queries) CreateRefundPayout(ctx context.Context, arg CreateRefundPayoutParams) (RefundPayout, error) {
	row := q.db.QueryRow(ctx, createRefundPayout,
		arg.ChargeID,
		arg.Amount,
		arg.UserID,
		arg.Currency,
		arg.ServiceFee,
	)
	var i RefundPayout
	err := row.Scan(
		&i.ChargeID,
		&i.Amount,
		&i.ServiceFee,
		&i.UserID,
		&i.TimePaid,
		&i.Currency,
		&i.AccountNumber,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRefundPayout = `-- name: ListRefundPayout :many
SELECT
    re.amount, re.time_paid, od.host_name_option, oi.main_option_type, u.first_name AS guest_name, ct.grade, co.cancelled AS option_cancelled, ct.cancelled AS ticket_cancelled, co.end_date AS option_end_date, cd.end_date AS event_end_date, co.start_date AS option_start_date, cd.start_date AS event_start_date, mp.type, co.currency AS option_currency, ce.currency AS event_currency
FROM refund_payouts AS re
JOIN main_payouts AS mp ON mp.charge_id = re.charge_id
LEFT JOIN charge_option_references AS co
    ON mp.Type = 'charge_option_reference'
    AND re.charge_id = co.id
LEFT JOIN charge_ticket_references AS ct
    ON mp.Type = 'charge_ticket_references'
    AND re.charge_id = ct.id
LEFT JOIN charge_date_references AS cd
    ON mp.Type = 'charge_ticket_references'
    AND ct.charge_date_id = cd.id
LEFT JOIN charge_event_references AS ce
    ON mp.Type = 'charge_ticket_references'
    AND cd.charge_event_id = ce.id
LEFT JOIN options_infos AS oi
    ON (mp.Type = 'charge_option_reference' AND co.option_user_id = oi.option_user_id)
    OR (mp.Type = 'charge_ticket_references' AND ce.option_user_id = oi.option_user_id)
LEFT JOIN options_info_details AS od ON oi.id = od.option_id
LEFT JOIN users AS u
    ON (mp.Type = 'charge_option_reference' AND co.user_id = u.user_id)
    OR (mp.Type = 'charge_ticket_references' AND ce.user_id = u.user_id)
WHERE re.is_complete = $3 AND re.user_id = $4
LIMIT $1
OFFSET $2
`

type ListRefundPayoutParams struct {
	Limit            int32     `json:"limit"`
	Offset           int32     `json:"offset"`
	PayoutIsComplete bool      `json:"payout_is_complete"`
	UID              uuid.UUID `json:"u_id"`
}

type ListRefundPayoutRow struct {
	Amount          int64       `json:"amount"`
	TimePaid        time.Time   `json:"time_paid"`
	HostNameOption  pgtype.Text `json:"host_name_option"`
	MainOptionType  pgtype.Text `json:"main_option_type"`
	GuestName       pgtype.Text `json:"guest_name"`
	Grade           pgtype.Text `json:"grade"`
	OptionCancelled pgtype.Bool `json:"option_cancelled"`
	TicketCancelled pgtype.Bool `json:"ticket_cancelled"`
	OptionEndDate   pgtype.Date `json:"option_end_date"`
	EventEndDate    pgtype.Date `json:"event_end_date"`
	OptionStartDate pgtype.Date `json:"option_start_date"`
	EventStartDate  pgtype.Date `json:"event_start_date"`
	Type            string      `json:"type"`
	OptionCurrency  pgtype.Text `json:"option_currency"`
	EventCurrency   pgtype.Text `json:"event_currency"`
}

func (q *Queries) ListRefundPayout(ctx context.Context, arg ListRefundPayoutParams) ([]ListRefundPayoutRow, error) {
	rows, err := q.db.Query(ctx, listRefundPayout,
		arg.Limit,
		arg.Offset,
		arg.PayoutIsComplete,
		arg.UID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRefundPayoutRow{}
	for rows.Next() {
		var i ListRefundPayoutRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.HostNameOption,
			&i.MainOptionType,
			&i.GuestName,
			&i.Grade,
			&i.OptionCancelled,
			&i.TicketCancelled,
			&i.OptionEndDate,
			&i.EventEndDate,
			&i.OptionStartDate,
			&i.EventStartDate,
			&i.Type,
			&i.OptionCurrency,
			&i.EventCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefundPayoutWithUser = `-- name: ListRefundPayoutWithUser :many
SELECT r_p.charge_id, us.id AS host_id, us.user_id AS host_user_id, us.default_account_id AS host_default_account_id, us.first_name AS host_name, r_p.amount, r_p.currency
FROM refund_payouts r_p
    JOIN users us on us.id = r_p.user_id
WHERE r_p.is_complete = $1
`

type ListRefundPayoutWithUserRow struct {
	ChargeID             uuid.UUID `json:"charge_id"`
	HostID               uuid.UUID `json:"host_id"`
	HostUserID           uuid.UUID `json:"host_user_id"`
	HostDefaultAccountID string    `json:"host_default_account_id"`
	HostName             string    `json:"host_name"`
	Amount               int64     `json:"amount"`
	Currency             string    `json:"currency"`
}

func (q *Queries) ListRefundPayoutWithUser(ctx context.Context, isComplete bool) ([]ListRefundPayoutWithUserRow, error) {
	rows, err := q.db.Query(ctx, listRefundPayoutWithUser, isComplete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRefundPayoutWithUserRow{}
	for rows.Next() {
		var i ListRefundPayoutWithUserRow
		if err := rows.Scan(
			&i.ChargeID,
			&i.HostID,
			&i.HostUserID,
			&i.HostDefaultAccountID,
			&i.HostName,
			&i.Amount,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRefundPayout = `-- name: RemoveRefundPayout :exec
DELETE FROM refund_payouts WHERE charge_id = $1
`

func (q *Queries) RemoveRefundPayout(ctx context.Context, chargeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeRefundPayout, chargeID)
	return err
}

const updateRefundPayout = `-- name: UpdateRefundPayout :exec
UPDATE refund_payouts
SET is_complete = $1,
    account_number = $2,
    time_paid = $3,
    updated_at = NOW()
WHERE charge_id = $4
`

type UpdateRefundPayoutParams struct {
	IsComplete    bool      `json:"is_complete"`
	AccountNumber string    `json:"account_number"`
	TimePaid      time.Time `json:"time_paid"`
	ChargeID      uuid.UUID `json:"charge_id"`
}

func (q *Queries) UpdateRefundPayout(ctx context.Context, arg UpdateRefundPayoutParams) error {
	_, err := q.db.Exec(ctx, updateRefundPayout,
		arg.IsComplete,
		arg.AccountNumber,
		arg.TimePaid,
		arg.ChargeID,
	)
	return err
}
