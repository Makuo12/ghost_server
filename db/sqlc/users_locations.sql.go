// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: users_locations.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUserLocation = `-- name: CreateUserLocation :one
INSERT INTO users_locations (
    user_id,
    street,
    city,
    state,
    country,
    postcode,
    geolocation
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING state, country
`

type CreateUserLocationParams struct {
	UserID      uuid.UUID    `json:"user_id"`
	Street      string       `json:"street"`
	City        string       `json:"city"`
	State       string       `json:"state"`
	Country     string       `json:"country"`
	Postcode    string       `json:"postcode"`
	Geolocation pgtype.Point `json:"geolocation"`
}

type CreateUserLocationRow struct {
	State   string `json:"state"`
	Country string `json:"country"`
}

func (q *Queries) CreateUserLocation(ctx context.Context, arg CreateUserLocationParams) (CreateUserLocationRow, error) {
	row := q.db.QueryRow(ctx, createUserLocation,
		arg.UserID,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.Postcode,
		arg.Geolocation,
	)
	var i CreateUserLocationRow
	err := row.Scan(&i.State, &i.Country)
	return i, err
}

const getUserLocationHalf = `-- name: GetUserLocationHalf :one
SELECT state, country
FROM users_locations
WHERE user_id = $1
`

type GetUserLocationHalfRow struct {
	State   string `json:"state"`
	Country string `json:"country"`
}

func (q *Queries) GetUserLocationHalf(ctx context.Context, userID uuid.UUID) (GetUserLocationHalfRow, error) {
	row := q.db.QueryRow(ctx, getUserLocationHalf, userID)
	var i GetUserLocationHalfRow
	err := row.Scan(&i.State, &i.Country)
	return i, err
}

const removeUserLocation = `-- name: RemoveUserLocation :exec
DELETE  FROM users_locations
WHERE user_id = $1
`

func (q *Queries) RemoveUserLocation(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeUserLocation, userID)
	return err
}

const updateUserLocation = `-- name: UpdateUserLocation :one
UPDATE users_locations 
SET
    street = $1,
    city = $2,
    state = $3,
    country = $4,
    postcode = $5,
    geolocation = $6,
    updated_at = NOW()
WHERE user_id = $7
RETURNING state, country
`

type UpdateUserLocationParams struct {
	Street      string       `json:"street"`
	City        string       `json:"city"`
	State       string       `json:"state"`
	Country     string       `json:"country"`
	Postcode    string       `json:"postcode"`
	Geolocation pgtype.Point `json:"geolocation"`
	UserID      uuid.UUID    `json:"user_id"`
}

type UpdateUserLocationRow struct {
	State   string `json:"state"`
	Country string `json:"country"`
}

func (q *Queries) UpdateUserLocation(ctx context.Context, arg UpdateUserLocationParams) (UpdateUserLocationRow, error) {
	row := q.db.QueryRow(ctx, updateUserLocation,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.Postcode,
		arg.Geolocation,
		arg.UserID,
	)
	var i UpdateUserLocationRow
	err := row.Scan(&i.State, &i.Country)
	return i, err
}
