// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: option_questions.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOptionQuestion = `-- name: CreateOptionQuestion :one
INSERT INTO option_questions (
    option_id,
    organization_name,
    host_as_individual,
    geolocation,
    legal_represents
    )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
    )
RETURNING option_id, host_as_individual, organization_name, organization_email, legal_represents, street, city, state, country, postcode, geolocation, created_at, updated_at
`

type CreateOptionQuestionParams struct {
	OptionID         uuid.UUID    `json:"option_id"`
	OrganizationName string       `json:"organization_name"`
	HostAsIndividual bool         `json:"host_as_individual"`
	Geolocation      pgtype.Point `json:"geolocation"`
	LegalRepresents  []string     `json:"legal_represents"`
}

func (q *Queries) CreateOptionQuestion(ctx context.Context, arg CreateOptionQuestionParams) (OptionQuestion, error) {
	row := q.db.QueryRow(ctx, createOptionQuestion,
		arg.OptionID,
		arg.OrganizationName,
		arg.HostAsIndividual,
		arg.Geolocation,
		arg.LegalRepresents,
	)
	var i OptionQuestion
	err := row.Scan(
		&i.OptionID,
		&i.HostAsIndividual,
		&i.OrganizationName,
		&i.OrganizationEmail,
		&i.LegalRepresents,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Geolocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionQuestion = `-- name: GetOptionQuestion :one
SELECT option_id, host_as_individual, organization_name, organization_email, legal_represents, street, city, state, country, postcode, geolocation, created_at, updated_at
FROM option_questions
WHERE option_id = $1
`

func (q *Queries) GetOptionQuestion(ctx context.Context, optionID uuid.UUID) (OptionQuestion, error) {
	row := q.db.QueryRow(ctx, getOptionQuestion, optionID)
	var i OptionQuestion
	err := row.Scan(
		&i.OptionID,
		&i.HostAsIndividual,
		&i.OrganizationName,
		&i.OrganizationEmail,
		&i.LegalRepresents,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postcode,
		&i.Geolocation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionQuestionLegal = `-- name: GetOptionQuestionLegal :one
SELECT legal_represents
FROM option_questions
WHERE option_id = $1
`

func (q *Queries) GetOptionQuestionLegal(ctx context.Context, optionID uuid.UUID) ([]string, error) {
	row := q.db.QueryRow(ctx, getOptionQuestionLegal, optionID)
	var legal_represents []string
	err := row.Scan(&legal_represents)
	return legal_represents, err
}

const removeOptionQuestion = `-- name: RemoveOptionQuestion :exec
DELETE FROM option_questions
WHERE option_id = $1
`

func (q *Queries) RemoveOptionQuestion(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeOptionQuestion, optionID)
	return err
}

const updateOptionQuestion = `-- name: UpdateOptionQuestion :one
UPDATE option_questions 
SET
    host_as_individual = COALESCE($2, host_as_individual),
    organization_name = COALESCE($3, organization_name),
    organization_email = COALESCE($4, organization_email),
    geolocation = COALESCE($5, geolocation),
    updated_at = NOW()
WHERE option_id = $1
RETURNING host_as_individual, organization_name, organization_email
`

type UpdateOptionQuestionParams struct {
	OptionID          uuid.UUID    `json:"option_id"`
	HostAsIndividual  pgtype.Bool  `json:"host_as_individual"`
	OrganizationName  pgtype.Text  `json:"organization_name"`
	OrganizationEmail pgtype.Text  `json:"organization_email"`
	Geolocation       pgtype.Point `json:"geolocation"`
}

type UpdateOptionQuestionRow struct {
	HostAsIndividual  bool   `json:"host_as_individual"`
	OrganizationName  string `json:"organization_name"`
	OrganizationEmail string `json:"organization_email"`
}

func (q *Queries) UpdateOptionQuestion(ctx context.Context, arg UpdateOptionQuestionParams) (UpdateOptionQuestionRow, error) {
	row := q.db.QueryRow(ctx, updateOptionQuestion,
		arg.OptionID,
		arg.HostAsIndividual,
		arg.OrganizationName,
		arg.OrganizationEmail,
		arg.Geolocation,
	)
	var i UpdateOptionQuestionRow
	err := row.Scan(&i.HostAsIndividual, &i.OrganizationName, &i.OrganizationEmail)
	return i, err
}

const updateOptionQuestionLegal = `-- name: UpdateOptionQuestionLegal :one
UPDATE option_questions 
SET
    legal_represents = $1,
    updated_at = NOW()
WHERE option_id = $1
RETURNING legal_represents
`

func (q *Queries) UpdateOptionQuestionLegal(ctx context.Context, legalRepresents []string) ([]string, error) {
	row := q.db.QueryRow(ctx, updateOptionQuestionLegal, legalRepresents)
	var legal_represents []string
	err := row.Scan(&legal_represents)
	return legal_represents, err
}

const updateOptionQuestionLocation = `-- name: UpdateOptionQuestionLocation :one
UPDATE option_questions 
SET
    street = $1,
    city = $2,
    state = $3,
    country = $4,
    postcode = $5,
    geolocation = $6,
    updated_at = NOW()
WHERE option_id = $7
RETURNING state, city, state, postcode, country, geolocation
`

type UpdateOptionQuestionLocationParams struct {
	Street      string       `json:"street"`
	City        string       `json:"city"`
	State       string       `json:"state"`
	Country     string       `json:"country"`
	Postcode    string       `json:"postcode"`
	Geolocation pgtype.Point `json:"geolocation"`
	OptionID    uuid.UUID    `json:"option_id"`
}

type UpdateOptionQuestionLocationRow struct {
	State       string       `json:"state"`
	City        string       `json:"city"`
	State_2     string       `json:"state_2"`
	Postcode    string       `json:"postcode"`
	Country     string       `json:"country"`
	Geolocation pgtype.Point `json:"geolocation"`
}

func (q *Queries) UpdateOptionQuestionLocation(ctx context.Context, arg UpdateOptionQuestionLocationParams) (UpdateOptionQuestionLocationRow, error) {
	row := q.db.QueryRow(ctx, updateOptionQuestionLocation,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.Postcode,
		arg.Geolocation,
		arg.OptionID,
	)
	var i UpdateOptionQuestionLocationRow
	err := row.Scan(
		&i.State,
		&i.City,
		&i.State_2,
		&i.Postcode,
		&i.Country,
		&i.Geolocation,
	)
	return i, err
}
