// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: main_payouts.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countOptionMainPayout = `-- name: CountOptionMainPayout :one
SELECT Count(*)
FROM main_payouts mp
    JOIN charge_option_references co ON mp.charge_id = co.id
    JOIN options_infos oi ON oi.option_user_id = co.option_user_id
    JOIN options_info_details od ON oi.id = od.option_id
    JOIN users u ON oi.host_id = u.id
WHERE mp.is_complete = $1 AND co.is_complete = $2 AND co.cancelled = $3 AND u.id = $4
`

type CountOptionMainPayoutParams struct {
	PayoutComplete        bool      `json:"payout_complete"`
	ChargePaymentComplete bool      `json:"charge_payment_complete"`
	ChargeCancelled       bool      `json:"charge_cancelled"`
	HostID                uuid.UUID `json:"host_id"`
}

func (q *Queries) CountOptionMainPayout(ctx context.Context, arg CountOptionMainPayoutParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOptionMainPayout,
		arg.PayoutComplete,
		arg.ChargePaymentComplete,
		arg.ChargeCancelled,
		arg.HostID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMainPayout = `-- name: CreateMainPayout :exec
INSERT INTO main_payouts (
    charge_id,
    type, 
    amount,
    service_fee,
    currency,
    is_complete
) VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateMainPayoutParams struct {
	ChargeID   uuid.UUID `json:"charge_id"`
	Type       string    `json:"type"`
	Amount     int64     `json:"amount"`
	ServiceFee int64     `json:"service_fee"`
	Currency   string    `json:"currency"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) CreateMainPayout(ctx context.Context, arg CreateMainPayoutParams) error {
	_, err := q.db.Exec(ctx, createMainPayout,
		arg.ChargeID,
		arg.Type,
		arg.Amount,
		arg.ServiceFee,
		arg.Currency,
		arg.IsComplete,
	)
	return err
}

const getMainPayout = `-- name: GetMainPayout :one
SELECT charge_id, type, amount, time_paid, service_fee, currency, account_number, is_complete, created_at, updated_at
FROM main_payouts
WHERE charge_id = $1
`

func (q *Queries) GetMainPayout(ctx context.Context, chargeID uuid.UUID) (MainPayout, error) {
	row := q.db.QueryRow(ctx, getMainPayout, chargeID)
	var i MainPayout
	err := row.Scan(
		&i.ChargeID,
		&i.Type,
		&i.Amount,
		&i.TimePaid,
		&i.ServiceFee,
		&i.Currency,
		&i.AccountNumber,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllOptionMainPayoutInsights = `-- name: ListAllOptionMainPayoutInsights :many
SELECT mp.amount, mp.time_paid, u.first_name AS guest_name, mp.account_number, co.start_date, co.end_date, mp.currency, mp.service_fee, co.cancelled, mp.charge_id
FROM main_payouts mp
    JOIN charge_option_references co ON mp.charge_id = co.id
    JOIN options_infos oi ON oi.option_user_id = co.option_user_id
    JOIN users u on u.user_id = co.user_id
    LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
    FROM option_co_hosts AS och
    WHERE och.co_user_id = $1 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $2 OR och_subquery.option_id IS NOT NULL) AND (oi.host_id = $2 OR och_subquery.insights = true) AND co.is_complete= true AND CAST(EXTRACT(YEAR FROM start_date) AS INTEGER) = CAST($3 AS INTEGER) AND mp.type = 'charge_option_reference'
`

type ListAllOptionMainPayoutInsightsParams struct {
	CoUserID string    `json:"co_user_id"`
	HostID   uuid.UUID `json:"host_id"`
	Year     int32     `json:"year"`
}

type ListAllOptionMainPayoutInsightsRow struct {
	Amount        int64     `json:"amount"`
	TimePaid      time.Time `json:"time_paid"`
	GuestName     string    `json:"guest_name"`
	AccountNumber string    `json:"account_number"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
	Currency      string    `json:"currency"`
	ServiceFee    int64     `json:"service_fee"`
	Cancelled     bool      `json:"cancelled"`
	ChargeID      uuid.UUID `json:"charge_id"`
}

func (q *Queries) ListAllOptionMainPayoutInsights(ctx context.Context, arg ListAllOptionMainPayoutInsightsParams) ([]ListAllOptionMainPayoutInsightsRow, error) {
	rows, err := q.db.Query(ctx, listAllOptionMainPayoutInsights, arg.CoUserID, arg.HostID, arg.Year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllOptionMainPayoutInsightsRow{}
	for rows.Next() {
		var i ListAllOptionMainPayoutInsightsRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.GuestName,
			&i.AccountNumber,
			&i.StartDate,
			&i.EndDate,
			&i.Currency,
			&i.ServiceFee,
			&i.Cancelled,
			&i.ChargeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionMainPayout = `-- name: ListOptionMainPayout :many
SELECT mp.amount, mp.time_paid, u.first_name AS guest_name, mp.account_number, co.start_date, co.end_date, od.host_name_option, mp.currency, mp.service_fee
FROM main_payouts mp
    JOIN charge_option_references co ON mp.charge_id = co.id
    JOIN options_infos oi ON oi.option_user_id = co.option_user_id
    JOIN options_info_details od ON oi.id = od.option_id
    JOIN users u ON oi.host_id = u.id
WHERE mp.is_complete = $3 AND co.is_complete = $4 AND co.cancelled = $5 AND u.id = $6 AND mp.type = 'charge_option_reference'
LIMIT $1
OFFSET $2
`

type ListOptionMainPayoutParams struct {
	Limit                 int32     `json:"limit"`
	Offset                int32     `json:"offset"`
	PayoutComplete        bool      `json:"payout_complete"`
	ChargePaymentComplete bool      `json:"charge_payment_complete"`
	ChargeCancelled       bool      `json:"charge_cancelled"`
	HostID                uuid.UUID `json:"host_id"`
}

type ListOptionMainPayoutRow struct {
	Amount         int64     `json:"amount"`
	TimePaid       time.Time `json:"time_paid"`
	GuestName      string    `json:"guest_name"`
	AccountNumber  string    `json:"account_number"`
	StartDate      time.Time `json:"start_date"`
	EndDate        time.Time `json:"end_date"`
	HostNameOption string    `json:"host_name_option"`
	Currency       string    `json:"currency"`
	ServiceFee     int64     `json:"service_fee"`
}

func (q *Queries) ListOptionMainPayout(ctx context.Context, arg ListOptionMainPayoutParams) ([]ListOptionMainPayoutRow, error) {
	rows, err := q.db.Query(ctx, listOptionMainPayout,
		arg.Limit,
		arg.Offset,
		arg.PayoutComplete,
		arg.ChargePaymentComplete,
		arg.ChargeCancelled,
		arg.HostID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionMainPayoutRow{}
	for rows.Next() {
		var i ListOptionMainPayoutRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.GuestName,
			&i.AccountNumber,
			&i.StartDate,
			&i.EndDate,
			&i.HostNameOption,
			&i.Currency,
			&i.ServiceFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionMainPayoutInsights = `-- name: ListOptionMainPayoutInsights :many
SELECT mp.amount, mp.time_paid, u.first_name AS guest_name, mp.account_number, co.start_date, co.end_date, mp.currency, mp.service_fee, co.cancelled, mp.charge_id
FROM main_payouts mp
    JOIN charge_option_references co ON mp.charge_id = co.id
    JOIN options_infos oi ON oi.option_user_id = co.option_user_id
    JOIN users u on u.user_id = co.user_id
    LEFT JOIN (
    SELECT DISTINCT option_id, scan_code, reservations, post, calender, edit_co_hosts, insights, edit_option_info, edit_event_dates_times
    FROM option_co_hosts AS och
    WHERE och.co_user_id = $1 AND och.accepted = true
) AS och_subquery ON oi.id = och_subquery.option_id
WHERE (oi.host_id = $2 OR och_subquery.option_id IS NOT NULL) AND (oi.host_id = $2 OR och_subquery.insights = true) AND co.is_complete= true AND oi.option_user_id = $3 AND CAST(EXTRACT(YEAR FROM start_date) AS INTEGER) = CAST($4 AS INTEGER) AND mp.type = 'charge_option_reference'
`

type ListOptionMainPayoutInsightsParams struct {
	CoUserID     string    `json:"co_user_id"`
	HostID       uuid.UUID `json:"host_id"`
	OptionUserID uuid.UUID `json:"option_user_id"`
	Year         int32     `json:"year"`
}

type ListOptionMainPayoutInsightsRow struct {
	Amount        int64     `json:"amount"`
	TimePaid      time.Time `json:"time_paid"`
	GuestName     string    `json:"guest_name"`
	AccountNumber string    `json:"account_number"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
	Currency      string    `json:"currency"`
	ServiceFee    int64     `json:"service_fee"`
	Cancelled     bool      `json:"cancelled"`
	ChargeID      uuid.UUID `json:"charge_id"`
}

func (q *Queries) ListOptionMainPayoutInsights(ctx context.Context, arg ListOptionMainPayoutInsightsParams) ([]ListOptionMainPayoutInsightsRow, error) {
	rows, err := q.db.Query(ctx, listOptionMainPayoutInsights,
		arg.CoUserID,
		arg.HostID,
		arg.OptionUserID,
		arg.Year,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionMainPayoutInsightsRow{}
	for rows.Next() {
		var i ListOptionMainPayoutInsightsRow
		if err := rows.Scan(
			&i.Amount,
			&i.TimePaid,
			&i.GuestName,
			&i.AccountNumber,
			&i.StartDate,
			&i.EndDate,
			&i.Currency,
			&i.ServiceFee,
			&i.Cancelled,
			&i.ChargeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionMainPayoutWithCharge = `-- name: ListOptionMainPayoutWithCharge :many
SELECT mp.amount, u.default_account_id, u.id AS host_id, mp.currency, mp.charge_id, u.user_id AS host_user_id, co.start_date, u.first_name  
FROM main_payouts mp
    JOIN charge_option_references co ON mp.charge_id = co.id
    JOIN options_infos oi ON oi.option_user_id = co.option_user_id
    JOIN users u ON oi.host_id = u.id
WHERE mp.is_complete = $1 AND co.is_complete = $2 AND co.cancelled = $3 AND NOW() + INTERVAL '1 hour' > (co.start_date + INTERVAL '38 hours') AND mp.type = 'charge_option_reference'
`

type ListOptionMainPayoutWithChargeParams struct {
	PayoutComplete        bool `json:"payout_complete"`
	ChargePaymentComplete bool `json:"charge_payment_complete"`
	ChargeCancelled       bool `json:"charge_cancelled"`
}

type ListOptionMainPayoutWithChargeRow struct {
	Amount           int64     `json:"amount"`
	DefaultAccountID string    `json:"default_account_id"`
	HostID           uuid.UUID `json:"host_id"`
	Currency         string    `json:"currency"`
	ChargeID         uuid.UUID `json:"charge_id"`
	HostUserID       uuid.UUID `json:"host_user_id"`
	StartDate        time.Time `json:"start_date"`
	FirstName        string    `json:"first_name"`
}

func (q *Queries) ListOptionMainPayoutWithCharge(ctx context.Context, arg ListOptionMainPayoutWithChargeParams) ([]ListOptionMainPayoutWithChargeRow, error) {
	rows, err := q.db.Query(ctx, listOptionMainPayoutWithCharge, arg.PayoutComplete, arg.ChargePaymentComplete, arg.ChargeCancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionMainPayoutWithChargeRow{}
	for rows.Next() {
		var i ListOptionMainPayoutWithChargeRow
		if err := rows.Scan(
			&i.Amount,
			&i.DefaultAccountID,
			&i.HostID,
			&i.Currency,
			&i.ChargeID,
			&i.HostUserID,
			&i.StartDate,
			&i.FirstName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketMainPayoutWithCharge = `-- name: ListTicketMainPayoutWithCharge :many
SELECT mp.amount, u.default_account_id, u.id AS host_id, mp.currency, mp.charge_id, u.user_id AS host_user_id, u.first_name, cd.start_date, cd.end_date
FROM main_payouts mp
    JOIN charge_ticket_references ct ON ct.id = mp.charge_id
    JOIN charge_date_references cd ON cd.id = ct.charge_date_id
    JOIN charge_event_references ce ON ce.id = cd.charge_event_id
    JOIN options_infos oi ON oi.option_user_id = ce.option_user_id
    JOIN users u ON oi.host_id = u.id
WHERE mp.is_complete = $1 AND ce.is_complete = $2 AND ct.cancelled = $3 AND NOW() + INTERVAL '1 hour' < (cd.end_date + INTERVAL '40 hours') AND mp.type = 'charge_ticket_reference'
`

type ListTicketMainPayoutWithChargeParams struct {
	PayoutComplete        bool `json:"payout_complete"`
	ChargePaymentComplete bool `json:"charge_payment_complete"`
	ChargeCancelled       bool `json:"charge_cancelled"`
}

type ListTicketMainPayoutWithChargeRow struct {
	Amount           int64     `json:"amount"`
	DefaultAccountID string    `json:"default_account_id"`
	HostID           uuid.UUID `json:"host_id"`
	Currency         string    `json:"currency"`
	ChargeID         uuid.UUID `json:"charge_id"`
	HostUserID       uuid.UUID `json:"host_user_id"`
	FirstName        string    `json:"first_name"`
	StartDate        time.Time `json:"start_date"`
	EndDate          time.Time `json:"end_date"`
}

func (q *Queries) ListTicketMainPayoutWithCharge(ctx context.Context, arg ListTicketMainPayoutWithChargeParams) ([]ListTicketMainPayoutWithChargeRow, error) {
	rows, err := q.db.Query(ctx, listTicketMainPayoutWithCharge, arg.PayoutComplete, arg.ChargePaymentComplete, arg.ChargeCancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTicketMainPayoutWithChargeRow{}
	for rows.Next() {
		var i ListTicketMainPayoutWithChargeRow
		if err := rows.Scan(
			&i.Amount,
			&i.DefaultAccountID,
			&i.HostID,
			&i.Currency,
			&i.ChargeID,
			&i.HostUserID,
			&i.FirstName,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMainPayout = `-- name: UpdateMainPayout :exec
UPDATE main_payouts
SET is_complete = $1,
    account_number = $2,
    time_paid = $3,
    updated_at = NOW()
WHERE charge_id = $4
`

type UpdateMainPayoutParams struct {
	IsComplete    bool      `json:"is_complete"`
	AccountNumber string    `json:"account_number"`
	TimePaid      time.Time `json:"time_paid"`
	ChargeID      uuid.UUID `json:"charge_id"`
}

func (q *Queries) UpdateMainPayout(ctx context.Context, arg UpdateMainPayoutParams) error {
	_, err := q.db.Exec(ctx, updateMainPayout,
		arg.IsComplete,
		arg.AccountNumber,
		arg.TimePaid,
		arg.ChargeID,
	)
	return err
}
