// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: option_co_hosts.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOptionCOHost = `-- name: CountOptionCOHost :one
SELECT Count(*)
FROM option_co_hosts
WHERE is_active = true AND option_id = $1
`

func (q *Queries) CountOptionCOHost(ctx context.Context, optionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOptionCOHost, optionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOptionCoHostByCoHost = `-- name: CountOptionCoHostByCoHost :one
SELECT Count(*)
FROM option_co_hosts oc
    JOIN options_infos oi on  oi.id = oc.option_id
    JOIN users u on u.id = oi.host_id
    JOIN options_info_details od on od.option_id = oi.id
    JOIN options_info_photos op on oi.id = op.option_id
WHERE oc.is_active = true AND oc.co_user_id = $1 AND oc.accepted = true
`

func (q *Queries) CountOptionCoHostByCoHost(ctx context.Context, coUserID string) (int64, error) {
	row := q.db.QueryRow(ctx, countOptionCoHostByCoHost, coUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOptionCOHost = `-- name: CreateOptionCOHost :one
INSERT INTO option_co_hosts (
    option_id,
    email,
    reservations,
    post,
    scan_code,
    calender,
    edit_option_info,
    edit_event_dates_times,
    insights,
    edit_co_hosts
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING email, id, accepted, created_at
`

type CreateOptionCOHostParams struct {
	OptionID            uuid.UUID `json:"option_id"`
	Email               string    `json:"email"`
	Reservations        bool      `json:"reservations"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Calender            bool      `json:"calender"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	Insights            bool      `json:"insights"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
}

type CreateOptionCOHostRow struct {
	Email     string    `json:"email"`
	ID        uuid.UUID `json:"id"`
	Accepted  bool      `json:"accepted"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateOptionCOHost(ctx context.Context, arg CreateOptionCOHostParams) (CreateOptionCOHostRow, error) {
	row := q.db.QueryRow(ctx, createOptionCOHost,
		arg.OptionID,
		arg.Email,
		arg.Reservations,
		arg.Post,
		arg.ScanCode,
		arg.Calender,
		arg.EditOptionInfo,
		arg.EditEventDatesTimes,
		arg.Insights,
		arg.EditCoHosts,
	)
	var i CreateOptionCOHostRow
	err := row.Scan(
		&i.Email,
		&i.ID,
		&i.Accepted,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateCoHost = `-- name: DeactivateCoHost :one
UPDATE option_co_hosts
SET 
    is_active = false,
    updated_at = NOW()
WHERE is_active = true AND co_user_id = $1 AND id = $2
RETURNING id
`

type DeactivateCoHostParams struct {
	CoUserID string    `json:"co_user_id"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) DeactivateCoHost(ctx context.Context, arg DeactivateCoHostParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deactivateCoHost, arg.CoUserID, arg.ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getDeactivateOptionCOHostByID = `-- name: GetDeactivateOptionCOHostByID :one
SELECT 
    oc.email AS co_host_email,
    accepted,
    reservations,
    post,
    scan_code,
    calender,
    edit_option_info,
    edit_event_dates_times,
    edit_co_hosts,
    oc.id AS co_id,
    od.host_name_option,
    oi.main_option_type,
    u.first_name AS main_host_name,
    u.user_id AS main_user_id,
    u.email AS main_user_email,
    us.first_name AS co_user_first_name,
    oc.created_at
FROM option_co_hosts oc
    JOIN options_infos oi ON oc.option_id = oi.id
    JOIN options_info_details od ON od.option_id = oi.id
    JOIN users u ON u.id = oi.host_id
    LEFT JOIN users us ON us.user_id::varchar = oc.co_user_id
WHERE oc.id = $1 AND oc.is_active = false
`

type GetDeactivateOptionCOHostByIDRow struct {
	CoHostEmail         string      `json:"co_host_email"`
	Accepted            bool        `json:"accepted"`
	Reservations        bool        `json:"reservations"`
	Post                bool        `json:"post"`
	ScanCode            bool        `json:"scan_code"`
	Calender            bool        `json:"calender"`
	EditOptionInfo      bool        `json:"edit_option_info"`
	EditEventDatesTimes bool        `json:"edit_event_dates_times"`
	EditCoHosts         bool        `json:"edit_co_hosts"`
	CoID                uuid.UUID   `json:"co_id"`
	HostNameOption      string      `json:"host_name_option"`
	MainOptionType      string      `json:"main_option_type"`
	MainHostName        string      `json:"main_host_name"`
	MainUserID          uuid.UUID   `json:"main_user_id"`
	MainUserEmail       string      `json:"main_user_email"`
	CoUserFirstName     pgtype.Text `json:"co_user_first_name"`
	CreatedAt           time.Time   `json:"created_at"`
}

func (q *Queries) GetDeactivateOptionCOHostByID(ctx context.Context, id uuid.UUID) (GetDeactivateOptionCOHostByIDRow, error) {
	row := q.db.QueryRow(ctx, getDeactivateOptionCOHostByID, id)
	var i GetDeactivateOptionCOHostByIDRow
	err := row.Scan(
		&i.CoHostEmail,
		&i.Accepted,
		&i.Reservations,
		&i.Post,
		&i.ScanCode,
		&i.Calender,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.EditCoHosts,
		&i.CoID,
		&i.HostNameOption,
		&i.MainOptionType,
		&i.MainHostName,
		&i.MainUserID,
		&i.MainUserEmail,
		&i.CoUserFirstName,
		&i.CreatedAt,
	)
	return i, err
}

const getOptionCOHost = `-- name: GetOptionCOHost :one
SELECT 
    oc.email AS co_host_email,
    accepted,
    reservations,
    post,
    scan_code,
    calender,
    edit_option_info,
    edit_event_dates_times,
    edit_co_hosts,
    oc.id AS co_id,
    od.host_name_option,
    oi.main_option_type,
    u.first_name AS main_host_name,
    oc.created_at
FROM option_co_hosts oc
    JOIN options_infos oi ON oc.option_id = oi.id
    JOIN options_info_details od ON od.option_id = oi.id
    JOIN users u ON u.id = oi.host_id
WHERE oc.is_active = true AND oc.option_id = $1 AND oc.id = $2
`

type GetOptionCOHostParams struct {
	OptionID uuid.UUID `json:"option_id"`
	ID       uuid.UUID `json:"id"`
}

type GetOptionCOHostRow struct {
	CoHostEmail         string    `json:"co_host_email"`
	Accepted            bool      `json:"accepted"`
	Reservations        bool      `json:"reservations"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Calender            bool      `json:"calender"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	CoID                uuid.UUID `json:"co_id"`
	HostNameOption      string    `json:"host_name_option"`
	MainOptionType      string    `json:"main_option_type"`
	MainHostName        string    `json:"main_host_name"`
	CreatedAt           time.Time `json:"created_at"`
}

func (q *Queries) GetOptionCOHost(ctx context.Context, arg GetOptionCOHostParams) (GetOptionCOHostRow, error) {
	row := q.db.QueryRow(ctx, getOptionCOHost, arg.OptionID, arg.ID)
	var i GetOptionCOHostRow
	err := row.Scan(
		&i.CoHostEmail,
		&i.Accepted,
		&i.Reservations,
		&i.Post,
		&i.ScanCode,
		&i.Calender,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.EditCoHosts,
		&i.CoID,
		&i.HostNameOption,
		&i.MainOptionType,
		&i.MainHostName,
		&i.CreatedAt,
	)
	return i, err
}

const getOptionCOHostByCoHost = `-- name: GetOptionCOHostByCoHost :one
SELECT 
    email,
    accepted,
    reservations,
    post,
    scan_code,
    calender,
    edit_option_info,
    edit_event_dates_times,
    edit_co_hosts,
    insights,
    id,
    created_at
FROM option_co_hosts
WHERE is_active = true AND id = $1 AND co_user_id = $2
`

type GetOptionCOHostByCoHostParams struct {
	ID       uuid.UUID `json:"id"`
	CoUserID string    `json:"co_user_id"`
}

type GetOptionCOHostByCoHostRow struct {
	Email               string    `json:"email"`
	Accepted            bool      `json:"accepted"`
	Reservations        bool      `json:"reservations"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Calender            bool      `json:"calender"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	Insights            bool      `json:"insights"`
	ID                  uuid.UUID `json:"id"`
	CreatedAt           time.Time `json:"created_at"`
}

func (q *Queries) GetOptionCOHostByCoHost(ctx context.Context, arg GetOptionCOHostByCoHostParams) (GetOptionCOHostByCoHostRow, error) {
	row := q.db.QueryRow(ctx, getOptionCOHostByCoHost, arg.ID, arg.CoUserID)
	var i GetOptionCOHostByCoHostRow
	err := row.Scan(
		&i.Email,
		&i.Accepted,
		&i.Reservations,
		&i.Post,
		&i.ScanCode,
		&i.Calender,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.EditCoHosts,
		&i.Insights,
		&i.ID,
		&i.CreatedAt,
	)
	return i, err
}

const getOptionCOHostByID = `-- name: GetOptionCOHostByID :one
SELECT 
    oc.email AS co_host_email,
    accepted,
    reservations,
    post,
    scan_code,
    calender,
    edit_option_info,
    edit_event_dates_times,
    edit_co_hosts,
    oc.id AS co_id,
    u.user_id,
    od.host_name_option,
    oi.main_option_type,
    u.first_name AS main_host_name,
    oc.created_at
FROM option_co_hosts oc
    JOIN options_infos oi ON oc.option_id = oi.id
    JOIN options_info_details od ON od.option_id = oi.id
    JOIN users u ON u.id = oi.host_id
WHERE oc.id = $1
`

type GetOptionCOHostByIDRow struct {
	CoHostEmail         string    `json:"co_host_email"`
	Accepted            bool      `json:"accepted"`
	Reservations        bool      `json:"reservations"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Calender            bool      `json:"calender"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	CoID                uuid.UUID `json:"co_id"`
	UserID              uuid.UUID `json:"user_id"`
	HostNameOption      string    `json:"host_name_option"`
	MainOptionType      string    `json:"main_option_type"`
	MainHostName        string    `json:"main_host_name"`
	CreatedAt           time.Time `json:"created_at"`
}

func (q *Queries) GetOptionCOHostByID(ctx context.Context, id uuid.UUID) (GetOptionCOHostByIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionCOHostByID, id)
	var i GetOptionCOHostByIDRow
	err := row.Scan(
		&i.CoHostEmail,
		&i.Accepted,
		&i.Reservations,
		&i.Post,
		&i.ScanCode,
		&i.Calender,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.EditCoHosts,
		&i.CoID,
		&i.UserID,
		&i.HostNameOption,
		&i.MainOptionType,
		&i.MainHostName,
		&i.CreatedAt,
	)
	return i, err
}

const getOptionCOHostByUserID = `-- name: GetOptionCOHostByUserID :one
SELECT 
    email,
    accepted,
    reservations,
    post,
    scan_code,
    calender,
    edit_option_info,
    edit_event_dates_times,
    edit_co_hosts,
    id,
    created_at
FROM option_co_hosts
WHERE is_active = true AND option_id = $1 AND co_user_id = $2
`

type GetOptionCOHostByUserIDParams struct {
	OptionID uuid.UUID `json:"option_id"`
	CoUserID string    `json:"co_user_id"`
}

type GetOptionCOHostByUserIDRow struct {
	Email               string    `json:"email"`
	Accepted            bool      `json:"accepted"`
	Reservations        bool      `json:"reservations"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Calender            bool      `json:"calender"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	ID                  uuid.UUID `json:"id"`
	CreatedAt           time.Time `json:"created_at"`
}

func (q *Queries) GetOptionCOHostByUserID(ctx context.Context, arg GetOptionCOHostByUserIDParams) (GetOptionCOHostByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getOptionCOHostByUserID, arg.OptionID, arg.CoUserID)
	var i GetOptionCOHostByUserIDRow
	err := row.Scan(
		&i.Email,
		&i.Accepted,
		&i.Reservations,
		&i.Post,
		&i.ScanCode,
		&i.Calender,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.EditCoHosts,
		&i.ID,
		&i.CreatedAt,
	)
	return i, err
}

const listCOHostReservation = `-- name: ListCOHostReservation :many
SELECT o_i.id 
FROM option_co_hosts o_c_h
    JOIN options_infos o_i on o_i.id = o_c_h.option_id
WHERE is_active = true AND o_c_h.co_user_id = $1 AND o_c_h.reservations = $2 AND o_i.main_option_type = $3 AND o_i.is_complete = $4
`

type ListCOHostReservationParams struct {
	CoUserID       string `json:"co_user_id"`
	Reservations   bool   `json:"reservations"`
	MainOptionType string `json:"main_option_type"`
	IsComplete     bool   `json:"is_complete"`
}

func (q *Queries) ListCOHostReservation(ctx context.Context, arg ListCOHostReservationParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, listCOHostReservation,
		arg.CoUserID,
		arg.Reservations,
		arg.MainOptionType,
		arg.IsComplete,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionCOHost = `-- name: ListOptionCOHost :many
SELECT 
    email, id, accepted, created_at, co_user_id 
FROM option_co_hosts
WHERE is_active = true AND option_id = $1
LIMIT $2
OFFSET $3
`

type ListOptionCOHostParams struct {
	OptionID uuid.UUID `json:"option_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListOptionCOHostRow struct {
	Email     string    `json:"email"`
	ID        uuid.UUID `json:"id"`
	Accepted  bool      `json:"accepted"`
	CreatedAt time.Time `json:"created_at"`
	CoUserID  string    `json:"co_user_id"`
}

func (q *Queries) ListOptionCOHost(ctx context.Context, arg ListOptionCOHostParams) ([]ListOptionCOHostRow, error) {
	rows, err := q.db.Query(ctx, listOptionCOHost, arg.OptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionCOHostRow{}
	for rows.Next() {
		var i ListOptionCOHostRow
		if err := rows.Scan(
			&i.Email,
			&i.ID,
			&i.Accepted,
			&i.CreatedAt,
			&i.CoUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionCOHostEmail = `-- name: ListOptionCOHostEmail :many
SELECT 
    email
FROM option_co_hosts
WHERE is_active = true AND option_id = $1
`

func (q *Queries) ListOptionCOHostEmail(ctx context.Context, optionID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, listOptionCOHostEmail, optionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionCOHostUser = `-- name: ListOptionCOHostUser :many
SELECT 
    co.id, option_id, co_user_id, accepted, co.email, co.is_active, reservations, post, scan_code, calender, insights, edit_option_info, edit_event_dates_times, edit_co_hosts, co.created_at, co.updated_at, u.id, user_id, firebase_id, public_id, hashed_password, deep_link_id, firebase_password, u.email, phone_number, first_name, username, last_name, date_of_birth, dial_code, dial_country, current_option_id, currency, default_card, default_payout_card, default_account_id, u.is_active, photo, password_changed_at, u.created_at, u.updated_at
FROM option_co_hosts co
    JOIN users u on u.user_id::varchar = co.co_host_id
WHERE is_active = true AND option_id = $1
`

type ListOptionCOHostUserRow struct {
	ID                  uuid.UUID `json:"id"`
	OptionID            uuid.UUID `json:"option_id"`
	CoUserID            string    `json:"co_user_id"`
	Accepted            bool      `json:"accepted"`
	Email               string    `json:"email"`
	IsActive            bool      `json:"is_active"`
	Reservations        bool      `json:"reservations"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Calender            bool      `json:"calender"`
	Insights            bool      `json:"insights"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
	ID_2                uuid.UUID `json:"id_2"`
	UserID              uuid.UUID `json:"user_id"`
	FirebaseID          uuid.UUID `json:"firebase_id"`
	PublicID            uuid.UUID `json:"public_id"`
	HashedPassword      string    `json:"hashed_password"`
	DeepLinkID          uuid.UUID `json:"deep_link_id"`
	FirebasePassword    string    `json:"firebase_password"`
	Email_2             string    `json:"email_2"`
	PhoneNumber         string    `json:"phone_number"`
	FirstName           string    `json:"first_name"`
	Username            string    `json:"username"`
	LastName            string    `json:"last_name"`
	DateOfBirth         time.Time `json:"date_of_birth"`
	DialCode            string    `json:"dial_code"`
	DialCountry         string    `json:"dial_country"`
	CurrentOptionID     string    `json:"current_option_id"`
	Currency            string    `json:"currency"`
	DefaultCard         string    `json:"default_card"`
	DefaultPayoutCard   string    `json:"default_payout_card"`
	DefaultAccountID    string    `json:"default_account_id"`
	IsActive_2          bool      `json:"is_active_2"`
	Photo               string    `json:"photo"`
	PasswordChangedAt   time.Time `json:"password_changed_at"`
	CreatedAt_2         time.Time `json:"created_at_2"`
	UpdatedAt_2         time.Time `json:"updated_at_2"`
}

func (q *Queries) ListOptionCOHostUser(ctx context.Context, optionID uuid.UUID) ([]ListOptionCOHostUserRow, error) {
	rows, err := q.db.Query(ctx, listOptionCOHostUser, optionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionCOHostUserRow{}
	for rows.Next() {
		var i ListOptionCOHostUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionID,
			&i.CoUserID,
			&i.Accepted,
			&i.Email,
			&i.IsActive,
			&i.Reservations,
			&i.Post,
			&i.ScanCode,
			&i.Calender,
			&i.Insights,
			&i.EditOptionInfo,
			&i.EditEventDatesTimes,
			&i.EditCoHosts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.UserID,
			&i.FirebaseID,
			&i.PublicID,
			&i.HashedPassword,
			&i.DeepLinkID,
			&i.FirebasePassword,
			&i.Email_2,
			&i.PhoneNumber,
			&i.FirstName,
			&i.Username,
			&i.LastName,
			&i.DateOfBirth,
			&i.DialCode,
			&i.DialCountry,
			&i.CurrentOptionID,
			&i.Currency,
			&i.DefaultCard,
			&i.DefaultPayoutCard,
			&i.DefaultAccountID,
			&i.IsActive_2,
			&i.Photo,
			&i.PasswordChangedAt,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionCoHostByCoHost = `-- name: ListOptionCoHostByCoHost :many
SELECT u.first_name, od.host_name_option, oi.co_host_id, oi.main_option_type, op.cover_image, oc.id, oi.primary_user_id
FROM option_co_hosts oc
    JOIN options_infos oi on  oi.id = oc.option_id
    JOIN users u on u.id = oi.host_id
    JOIN options_info_details od on od.option_id = oi.id
    JOIN options_info_photos op on oi.id = op.option_id
WHERE oc.is_active = true AND oc.co_user_id = $3 AND oc.accepted = true
LIMIT $1
OFFSET $2
`

type ListOptionCoHostByCoHostParams struct {
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
	CoUserID string `json:"co_user_id"`
}

type ListOptionCoHostByCoHostRow struct {
	FirstName      string    `json:"first_name"`
	HostNameOption string    `json:"host_name_option"`
	CoHostID       uuid.UUID `json:"co_host_id"`
	MainOptionType string    `json:"main_option_type"`
	CoverImage     string    `json:"cover_image"`
	ID             uuid.UUID `json:"id"`
	PrimaryUserID  uuid.UUID `json:"primary_user_id"`
}

func (q *Queries) ListOptionCoHostByCoHost(ctx context.Context, arg ListOptionCoHostByCoHostParams) ([]ListOptionCoHostByCoHostRow, error) {
	rows, err := q.db.Query(ctx, listOptionCoHostByCoHost, arg.Limit, arg.Offset, arg.CoUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOptionCoHostByCoHostRow{}
	for rows.Next() {
		var i ListOptionCoHostByCoHostRow
		if err := rows.Scan(
			&i.FirstName,
			&i.HostNameOption,
			&i.CoHostID,
			&i.MainOptionType,
			&i.CoverImage,
			&i.ID,
			&i.PrimaryUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllOptionCOHost = `-- name: RemoveAllOptionCOHost :exec
DELETE FROM option_co_hosts
WHERE is_active = true AND option_id = $1
`

func (q *Queries) RemoveAllOptionCOHost(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAllOptionCOHost, optionID)
	return err
}

const removeOptionCOHost = `-- name: RemoveOptionCOHost :exec
DELETE FROM option_co_hosts
WHERE is_active = true AND option_id = $1 AND id = $2
`

type RemoveOptionCOHostParams struct {
	OptionID uuid.UUID `json:"option_id"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) RemoveOptionCOHost(ctx context.Context, arg RemoveOptionCOHostParams) error {
	_, err := q.db.Exec(ctx, removeOptionCOHost, arg.OptionID, arg.ID)
	return err
}

const updateOptionCOHost = `-- name: UpdateOptionCOHost :one
UPDATE option_co_hosts 
SET
    reservations = $1,
    post = $2,
    scan_code = $3,
    calender = $4,
    edit_option_info = $5,
    edit_event_dates_times = $6,
    edit_co_hosts = $7,
    insights = $8,
    updated_at = NOW()
WHERE is_active = true AND option_id = $9 AND id = $10
RETURNING email,
    id,
    accepted,
    reservations,
    post,
    scan_code,
    calender,
    edit_option_info,
    edit_event_dates_times,
    created_at,
    co_user_id,
    insights,
    edit_co_hosts
`

type UpdateOptionCOHostParams struct {
	Reservations        bool      `json:"reservations"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Calender            bool      `json:"calender"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
	Insights            bool      `json:"insights"`
	OptionID            uuid.UUID `json:"option_id"`
	ID                  uuid.UUID `json:"id"`
}

type UpdateOptionCOHostRow struct {
	Email               string    `json:"email"`
	ID                  uuid.UUID `json:"id"`
	Accepted            bool      `json:"accepted"`
	Reservations        bool      `json:"reservations"`
	Post                bool      `json:"post"`
	ScanCode            bool      `json:"scan_code"`
	Calender            bool      `json:"calender"`
	EditOptionInfo      bool      `json:"edit_option_info"`
	EditEventDatesTimes bool      `json:"edit_event_dates_times"`
	CreatedAt           time.Time `json:"created_at"`
	CoUserID            string    `json:"co_user_id"`
	Insights            bool      `json:"insights"`
	EditCoHosts         bool      `json:"edit_co_hosts"`
}

func (q *Queries) UpdateOptionCOHost(ctx context.Context, arg UpdateOptionCOHostParams) (UpdateOptionCOHostRow, error) {
	row := q.db.QueryRow(ctx, updateOptionCOHost,
		arg.Reservations,
		arg.Post,
		arg.ScanCode,
		arg.Calender,
		arg.EditOptionInfo,
		arg.EditEventDatesTimes,
		arg.EditCoHosts,
		arg.Insights,
		arg.OptionID,
		arg.ID,
	)
	var i UpdateOptionCOHostRow
	err := row.Scan(
		&i.Email,
		&i.ID,
		&i.Accepted,
		&i.Reservations,
		&i.Post,
		&i.ScanCode,
		&i.Calender,
		&i.EditOptionInfo,
		&i.EditEventDatesTimes,
		&i.CreatedAt,
		&i.CoUserID,
		&i.Insights,
		&i.EditCoHosts,
	)
	return i, err
}

const updateOptionCOHostTwo = `-- name: UpdateOptionCOHostTwo :one
UPDATE option_co_hosts
SET 
    email = COALESCE($1, email),
    co_user_id = COALESCE($2, co_user_id),
    accepted = COALESCE($3, accepted),
    updated_at = NOW()
WHERE is_active = true AND id = $4 AND co_user_id <> $5 AND accepted = false 
RETURNING option_id, id
`

type UpdateOptionCOHostTwoParams struct {
	Email        pgtype.Text `json:"email"`
	CoUserID     pgtype.Text `json:"co_user_id"`
	Accepted     pgtype.Bool `json:"accepted"`
	ID           uuid.UUID   `json:"id"`
	CoUserUsedID string      `json:"co_user_used_id"`
}

type UpdateOptionCOHostTwoRow struct {
	OptionID uuid.UUID `json:"option_id"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateOptionCOHostTwo(ctx context.Context, arg UpdateOptionCOHostTwoParams) (UpdateOptionCOHostTwoRow, error) {
	row := q.db.QueryRow(ctx, updateOptionCOHostTwo,
		arg.Email,
		arg.CoUserID,
		arg.Accepted,
		arg.ID,
		arg.CoUserUsedID,
	)
	var i UpdateOptionCOHostTwoRow
	err := row.Scan(&i.OptionID, &i.ID)
	return i, err
}
