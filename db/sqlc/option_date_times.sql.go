// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: option_date_times.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOptionDateTime = `-- name: CreateOptionDateTime :one
INSERT INTO option_date_times (
      option_id,
      date,
      available,
      price,
      note 
      )
VALUES (
      $1, $2, $3, $4, $5
   )
RETURNING id, option_id, date, available, price, note, created_at, updated_at
`

type CreateOptionDateTimeParams struct {
	OptionID  uuid.UUID `json:"option_id"`
	Date      time.Time `json:"date"`
	Available bool      `json:"available"`
	Price     int64     `json:"price"`
	Note      string    `json:"note"`
}

func (q *Queries) CreateOptionDateTime(ctx context.Context, arg CreateOptionDateTimeParams) (OptionDateTime, error) {
	row := q.db.QueryRow(ctx, createOptionDateTime,
		arg.OptionID,
		arg.Date,
		arg.Available,
		arg.Price,
		arg.Note,
	)
	var i OptionDateTime
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.Date,
		&i.Available,
		&i.Price,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionDateTime = `-- name: GetOptionDateTime :one
SELECT id, option_id, date, available, price, note, created_at, updated_at
FROM option_date_times
WHERE id = $1
`

func (q *Queries) GetOptionDateTime(ctx context.Context, id uuid.UUID) (OptionDateTime, error) {
	row := q.db.QueryRow(ctx, getOptionDateTime, id)
	var i OptionDateTime
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.Date,
		&i.Available,
		&i.Price,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOptionDateTimeByOption = `-- name: GetOptionDateTimeByOption :one
SELECT o_p.price
FROM option_date_times o_d_t
   JOIN options_infos o_i on o_i.id = o_d_t.option_id
   JOIN options_prices o_p on o_p.option_id = o_i.id
   JOIN users u on u.id = o_i.host_id
WHERE o_d_t.id = $1 AND u.id = $2 AND o_i.id = $3 AND o_i.is_complete = $4
`

type GetOptionDateTimeByOptionParams struct {
	ID         uuid.UUID `json:"id"`
	ID_2       uuid.UUID `json:"id_2"`
	ID_3       uuid.UUID `json:"id_3"`
	IsComplete bool      `json:"is_complete"`
}

func (q *Queries) GetOptionDateTimeByOption(ctx context.Context, arg GetOptionDateTimeByOptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, getOptionDateTimeByOption,
		arg.ID,
		arg.ID_2,
		arg.ID_3,
		arg.IsComplete,
	)
	var price int64
	err := row.Scan(&price)
	return price, err
}

const getOptionDateTimeCount = `-- name: GetOptionDateTimeCount :one
SELECT COUNT(*)
FROM option_date_times
WHERE option_id = $1
`

func (q *Queries) GetOptionDateTimeCount(ctx context.Context, optionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getOptionDateTimeCount, optionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOptionDateTimeNoteByOption = `-- name: GetOptionDateTimeNoteByOption :one
SELECT o_d_t.note, o_d_t.id
FROM option_date_times o_d_t
   JOIN options_infos o_i on o_i.id = o_d_t.option_id
   JOIN users u on u.id = o_i.host_id
WHERE o_d_t.id = $1 AND u.id = $2 AND o_i.id = $3 AND o_i.is_complete = $4
`

type GetOptionDateTimeNoteByOptionParams struct {
	ID         uuid.UUID `json:"id"`
	ID_2       uuid.UUID `json:"id_2"`
	ID_3       uuid.UUID `json:"id_3"`
	IsComplete bool      `json:"is_complete"`
}

type GetOptionDateTimeNoteByOptionRow struct {
	Note string    `json:"note"`
	ID   uuid.UUID `json:"id"`
}

func (q *Queries) GetOptionDateTimeNoteByOption(ctx context.Context, arg GetOptionDateTimeNoteByOptionParams) (GetOptionDateTimeNoteByOptionRow, error) {
	row := q.db.QueryRow(ctx, getOptionDateTimeNoteByOption,
		arg.ID,
		arg.ID_2,
		arg.ID_3,
		arg.IsComplete,
	)
	var i GetOptionDateTimeNoteByOptionRow
	err := row.Scan(&i.Note, &i.ID)
	return i, err
}

const listAllOptionDateTime = `-- name: ListAllOptionDateTime :many
SELECT id, option_id, date, available, price, note, created_at, updated_at
FROM option_date_times
WHERE option_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAllOptionDateTime(ctx context.Context, optionID uuid.UUID) ([]OptionDateTime, error) {
	rows, err := q.db.Query(ctx, listAllOptionDateTime, optionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OptionDateTime{}
	for rows.Next() {
		var i OptionDateTime
		if err := rows.Scan(
			&i.ID,
			&i.OptionID,
			&i.Date,
			&i.Available,
			&i.Price,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllOptionDateTimeByOUD = `-- name: ListAllOptionDateTimeByOUD :many
SELECT od.id, option_id, date, available, price, note, od.created_at, od.updated_at, oi.id, co_host_id, option_user_id, host_id, deep_link_id, primary_user_id, is_active, is_complete, is_verified, category, category_two, category_three, category_four, is_top_seller, time_zone, currency, option_img, option_type, main_option_type, oi.created_at, completed, oi.updated_at
FROM option_date_times od
JOIN options_infos oi ON oi.id = od.option_id
WHERE oi.option_user_id = $1
ORDER BY od.created_at DESC
`

type ListAllOptionDateTimeByOUDRow struct {
	ID             uuid.UUID `json:"id"`
	OptionID       uuid.UUID `json:"option_id"`
	Date           time.Time `json:"date"`
	Available      bool      `json:"available"`
	Price          int64     `json:"price"`
	Note           string    `json:"note"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	ID_2           uuid.UUID `json:"id_2"`
	CoHostID       uuid.UUID `json:"co_host_id"`
	OptionUserID   uuid.UUID `json:"option_user_id"`
	HostID         uuid.UUID `json:"host_id"`
	DeepLinkID     uuid.UUID `json:"deep_link_id"`
	PrimaryUserID  uuid.UUID `json:"primary_user_id"`
	IsActive       bool      `json:"is_active"`
	IsComplete     bool      `json:"is_complete"`
	IsVerified     bool      `json:"is_verified"`
	Category       string    `json:"category"`
	CategoryTwo    string    `json:"category_two"`
	CategoryThree  string    `json:"category_three"`
	CategoryFour   string    `json:"category_four"`
	IsTopSeller    bool      `json:"is_top_seller"`
	TimeZone       string    `json:"time_zone"`
	Currency       string    `json:"currency"`
	OptionImg      string    `json:"option_img"`
	OptionType     string    `json:"option_type"`
	MainOptionType string    `json:"main_option_type"`
	CreatedAt_2    time.Time `json:"created_at_2"`
	Completed      time.Time `json:"completed"`
	UpdatedAt_2    time.Time `json:"updated_at_2"`
}

func (q *Queries) ListAllOptionDateTimeByOUD(ctx context.Context, optionUserID uuid.UUID) ([]ListAllOptionDateTimeByOUDRow, error) {
	rows, err := q.db.Query(ctx, listAllOptionDateTimeByOUD, optionUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllOptionDateTimeByOUDRow{}
	for rows.Next() {
		var i ListAllOptionDateTimeByOUDRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionID,
			&i.Date,
			&i.Available,
			&i.Price,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.CoHostID,
			&i.OptionUserID,
			&i.HostID,
			&i.DeepLinkID,
			&i.PrimaryUserID,
			&i.IsActive,
			&i.IsComplete,
			&i.IsVerified,
			&i.Category,
			&i.CategoryTwo,
			&i.CategoryThree,
			&i.CategoryFour,
			&i.IsTopSeller,
			&i.TimeZone,
			&i.Currency,
			&i.OptionImg,
			&i.OptionType,
			&i.MainOptionType,
			&i.CreatedAt_2,
			&i.Completed,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionDateTime = `-- name: ListOptionDateTime :many
SELECT id, option_id, date, available, price, note, created_at, updated_at
FROM option_date_times
WHERE option_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type ListOptionDateTimeParams struct {
	OptionID uuid.UUID `json:"option_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListOptionDateTime(ctx context.Context, arg ListOptionDateTimeParams) ([]OptionDateTime, error) {
	rows, err := q.db.Query(ctx, listOptionDateTime, arg.OptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OptionDateTime{}
	for rows.Next() {
		var i OptionDateTime
		if err := rows.Scan(
			&i.ID,
			&i.OptionID,
			&i.Date,
			&i.Available,
			&i.Price,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllOptionDateTime = `-- name: RemoveAllOptionDateTime :exec
DELETE FROM option_date_times
WHERE option_id = $1
`

func (q *Queries) RemoveAllOptionDateTime(ctx context.Context, optionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAllOptionDateTime, optionID)
	return err
}

const removeOptionDateTime = `-- name: RemoveOptionDateTime :exec
DELETE FROM option_date_times
WHERE id = $1 AND option_id = $2
`

type RemoveOptionDateTimeParams struct {
	ID       uuid.UUID `json:"id"`
	OptionID uuid.UUID `json:"option_id"`
}

func (q *Queries) RemoveOptionDateTime(ctx context.Context, arg RemoveOptionDateTimeParams) error {
	_, err := q.db.Exec(ctx, removeOptionDateTime, arg.ID, arg.OptionID)
	return err
}

const updateAllOptionDateTime = `-- name: UpdateAllOptionDateTime :one
UPDATE option_date_times
SET 
   note = $1,
   available = $2,
   price = $3,
   updated_at = NOW()
WHERE id = $4
RETURNING id, option_id, date, available, price, note, created_at, updated_at
`

type UpdateAllOptionDateTimeParams struct {
	Note      string    `json:"note"`
	Available bool      `json:"available"`
	Price     int64     `json:"price"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) UpdateAllOptionDateTime(ctx context.Context, arg UpdateAllOptionDateTimeParams) (OptionDateTime, error) {
	row := q.db.QueryRow(ctx, updateAllOptionDateTime,
		arg.Note,
		arg.Available,
		arg.Price,
		arg.ID,
	)
	var i OptionDateTime
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.Date,
		&i.Available,
		&i.Price,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOptionDateTime = `-- name: UpdateOptionDateTime :one
UPDATE option_date_times
SET 
   date = COALESCE($1, date),
   note = COALESCE($2, note),
   available = COALESCE($3, available),
   price = COALESCE($4, price),
   updated_at = NOW()
WHERE id = $5 
RETURNING id, option_id, date, available, price, note, created_at, updated_at
`

type UpdateOptionDateTimeParams struct {
	Date      pgtype.Date `json:"date"`
	Note      pgtype.Text `json:"note"`
	Available pgtype.Bool `json:"available"`
	Price     pgtype.Int8 `json:"price"`
	ID        uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateOptionDateTime(ctx context.Context, arg UpdateOptionDateTimeParams) (OptionDateTime, error) {
	row := q.db.QueryRow(ctx, updateOptionDateTime,
		arg.Date,
		arg.Note,
		arg.Available,
		arg.Price,
		arg.ID,
	)
	var i OptionDateTime
	err := row.Scan(
		&i.ID,
		&i.OptionID,
		&i.Date,
		&i.Available,
		&i.Price,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
